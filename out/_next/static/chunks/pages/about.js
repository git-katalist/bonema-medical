(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/about"],{

/***/ "./pages/about.js":
/*!************************!*\
  !*** ./pages/about.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ About; }
/* harmony export */ });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* module decorator */ module = __webpack_require__.hmd(module);


var _jsxFileName = "C:\\Users\\tsote\\Desktop\\bonema\\bonema-medical\\pages\\about.js";
function About() {
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("h1", {
      children: "I am the ABout Page"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 4,
      columnNumber: 13
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: "Lorem ipsum dolor sit amet consectetur adipisicing elit. Quidem ipsum, sint esse tenetur dicta harum repellendus assumenda est itaque? Laborum, adipisci quasi laboriosam sapiente aliquam facilis illo excepturi fugit sint, vitae dignissimos amet sequi atque harum fugiat error iusto voluptatibus delectus. Sit eos, illo voluptates deserunt excepturi harum voluptatem sint maiores dolor, saepe qui necessitatibus impedit assumenda consequatur labore provident architecto dicta dolores corrupti quia libero accusamus! Odio voluptates voluptas reiciendis cum modi nulla recusandae minima autem, veritatis consectetur ipsum eos ad laudantium itaque placeat facilis quos labore? Adipisci minus tenetur accusantium pariatur, recusandae in inventore tempore maiores omnis porro consequatur expedita vel repellat vitae totam quo, corporis similique laudantium, reprehenderit unde neque rerum! Sapiente ab asperiores itaque. Reiciendis velit rem, tempora deleniti cum blanditiis odio maiores illo ut, non numquam est? Ut minus inventore nam commodi. Esse animi ut molestiae aliquam ipsam, totam perspiciatis quis magnam? Obcaecati vel ratione rerum, nobis, accusantium autem voluptas alias temporibus doloribus labore a nesciunt atque explicabo tempora excepturi aliquid nostrum, repellat natus laudantium? Ex inventore dicta fuga libero cum debitis hic aliquam assumenda mollitia odio architecto dolore voluptas delectus quisquam placeat, facere tempore laborum, quae perferendis saepe maxime quia. Earum nostrum id similique sequi, suscipit veritatis commodi voluptatum perspiciatis aut repellat impedit, explicabo debitis neque nam porro modi consequatur ex aliquid in, maiores libero dicta. Dignissimos, facilis corrupti similique quibusdam, accusantium perspiciatis beatae numquam quia soluta pariatur, doloremque suscipit magni sapiente reprehenderit harum perferendis exercitationem repellendus voluptatem nostrum architecto commodi. Tempore, et saepe? Exercitationem eaque consequuntur amet molestiae fugit veritatis, perferendis unde officia, ducimus architecto temporibus pariatur tempore quia, eum voluptates rem? Doloremque cupiditate exercitationem corrupti laborum voluptas at, aliquam voluptatum aliquid vero. Laborum amet quos iusto excepturi repellat maiores neque atque nostrum officiis, expedita error placeat, perferendis nesciunt, molestiae ab. Possimus veniam et illo animi dolores saepe odit sunt quia consectetur, quisquam molestias, unde illum quod. Tenetur cum eius at beatae, dolores laborum consequatur autem iste nisi quisquam omnis perferendis adipisci a minima, sapiente unde maiores, id placeat neque. Explicabo repellendus consectetur aspernatur, vel totam, quibusdam libero aut porro quidem quisquam suscipit molestias unde! Dolorum ea est esse fugit provident omnis suscipit id soluta! Quia quam eos minus tempora? Quibusdam odit debitis voluptas tenetur magnam at aut ea. Ab iure ad eos quia a doloremque dignissimos consequuntur molestiae. Natus, corrupti qui quaerat numquam modi asperiores. Iste unde id at cumque architecto quibusdam voluptas. Optio, facilis! Ipsam perspiciatis iste temporibus ut exercitationem dolor deserunt? Ab dicta esse, unde, provident iusto similique, quo quod itaque voluptate illo neque ad? Quod, nobis quis. Esse eum rerum, ducimus sapiente repellendus reiciendis eaque vero culpa ea distinctio. Laborum neque delectus eum, possimus deserunt consequatur blanditiis error voluptas fugiat asperiores nihil voluptates numquam qui aut consequuntur architecto voluptatibus beatae eaque quidem quibusdam nobis quaerat distinctio? Hic, provident nesciunt reprehenderit magnam, aperiam vero quibusdam cum est aliquam molestiae aut voluptatibus! Nihil molestiae totam accusantium fugiat, nobis, ullam corrupti officiis minus provident, quam earum nostrum laudantium facere alias numquam blanditiis adipisci veritatis voluptate labore quaerat tenetur? Sit nostrum, laborum amet excepturi vero neque illum dolorum assumenda animi dolorem ducimus unde fuga odio perferendis labore sequi voluptatem aperiam quo sapiente sed nulla suscipit laudantium atque quae. Dicta, dignissimos quaerat rem ex fugiat mollitia magni debitis voluptates repudiandae ipsum, animi aperiam possimus at laboriosam sit et ipsam exercitationem autem obcaecati perferendis vero maxime hic quam. Officia cupiditate natus impedit modi sequi adipisci ea autem libero sunt quia iure ducimus doloribus blanditiis quo aperiam, officiis dolor ipsa voluptatibus perferendis placeat voluptatem. Quo doloribus dolor debitis minima assumenda, nam iure quibusdam maxime quidem voluptates quam ullam itaque impedit consequuntur rem quas, quaerat libero quia perspiciatis laboriosam! Repudiandae accusamus optio mollitia quo, a ipsum deleniti laboriosam obcaecati, veniam facere eius sapiente ipsa exercitationem, dolorem rem ex nam vitae odio! Excepturi consequuntur iste quia corrupti iure exercitationem soluta unde consectetur suscipit! Soluta minima voluptatum mollitia animi officiis molestiae similique, hic maiores ipsam pariatur provident illo placeat nam quis quo veniam suscipit, consectetur saepe esse rerum aut ratione voluptate. Maiores perspiciatis error fugiat minima a doloribus cum magni tenetur neque aliquam? Nisi perferendis ipsam explicabo dolorum deserunt repudiandae tempora error ipsa. Aperiam quidem ad distinctio eum et est officiis iure, dolore, odit iste incidunt dolorum minus quisquam nemo, placeat perferendis. Quidem obcaecati soluta error consequatur dolorum facilis eum, at consectetur necessitatibus sed nulla doloremque nisi quos modi enim fugit dolores aliquam vitae exercitationem, eligendi odio ipsam adipisci. Ea dolor dolores autem vel debitis fuga consequuntur asperiores magnam placeat ipsa, reprehenderit est deleniti laudantium maxime dolorem perferendis minima totam accusamus facere porro? Illo, natus iure! Modi, harum distinctio consectetur fuga et labore maxime placeat voluptates est nemo omnis beatae error esse inventore reprehenderit, doloribus deleniti dolorem ratione odit exercitationem nam soluta delectus corporis minima. Consequatur impedit consectetur cupiditate sed dolores! Dolorem iure fugit saepe eos nesciunt doloribus repellendus sit amet! Architecto deserunt soluta aliquam adipisci ullam molestias animi molestiae, nam necessitatibus? Aliquam autem, minima molestias veritatis in quasi beatae accusamus dolorem modi perspiciatis itaque doloribus quaerat illum reiciendis saepe libero ducimus dicta delectus consequatur aliquid! Expedita at iure necessitatibus quia labore! Quae commodi veniam rerum omnis, tempore consectetur, asperiores corrupti inventore ex labore ab quam quas neque saepe non temporibus expedita similique dignissimos itaque distinctio optio vero repudiandae deleniti mollitia! Id, in molestiae possimus vel fugit eius cum, sunt eum dicta inventore doloribus, nobis reprehenderit! Ex fugit iste cumque ullam similique animi, aliquid maiores quasi facilis porro tenetur, consectetur repellat impedit ipsa labore eius fugiat! Aut sunt est molestiae ratione obcaecati dicta, aliquam officiis, eos maiores in aliquid corporis voluptatibus, soluta dolorum minima quis maxime similique itaque autem? Dolore mollitia numquam tenetur ex natus accusamus error tempore repellat similique est iure voluptate quis, eaque in porro rem asperiores eos iste doloremque vitae voluptas? Totam sit, quas expedita laboriosam cupiditate aperiam at, nam, eum necessitatibus temporibus deleniti fugiat asperiores ipsam omnis dolore repellendus molestias accusamus facere dolorem ad! Non modi porro, cumque necessitatibus earum reiciendis alias cupiditate natus exercitationem, nobis voluptates obcaecati rem eum voluptatem? Ea voluptas dolorum ratione deleniti, quasi molestiae error id architecto placeat, suscipit optio ipsa nostrum porro nemo fugiat deserunt reiciendis quidem vero nam explicabo! Harum vel vitae nostrum expedita quae commodi voluptate dolore nesciunt vero aliquam ut fuga suscipit, tenetur nam ipsam. Quo sint, nesciunt nihil laudantium non consequatur repudiandae quaerat ab possimus fuga, veritatis nisi illum, vel eos quasi mollitia! Dolor pariatur saepe magni maiores repellat sequi necessitatibus minus inventore, iusto vel perspiciatis, nihil voluptas quia, ut facere! Cum vitae fuga magni quis pariatur nihil iusto odio voluptatibus vel ad expedita magnam, consectetur quos dignissimos ex, recusandae ut libero ducimus minima. Velit doloribus itaque suscipit possimus iste eos, ab impedit corrupti dolorem? Officia quos iure blanditiis temporibus soluta nobis nesciunt dolor. Dolores corporis molestiae esse modi veritatis quas laboriosam obcaecati dolore facere. Corporis similique, porro error illum autem necessitatibus quam nesciunt natus quo, sed qui dolorem unde consequatur quidem omnis optio! Voluptatibus nihil odit magni delectus animi id ratione ut culpa. Nulla, commodi nesciunt. Nobis, at enim ab consequuntur ea recusandae, saepe veritatis officia veniam impedit architecto incidunt cupiditate. Iure architecto explicabo qui sapiente dolore sequi reprehenderit labore, perferendis aspernatur expedita illum itaque magnam alias laborum ipsam. Asperiores minus qui sapiente molestias error voluptas ab eum iste maxime culpa repellat doloremque officiis delectus cumque ex voluptates sint ipsam commodi quas aliquam atque assumenda, maiores reprehenderit iure! Vitae modi fugit fuga, recusandae laborum incidunt illo amet nihil! Sit, maiores! At laboriosam explicabo beatae, dignissimos qui voluptatibus sint, unde tempora velit, delectus eos. Explicabo assumenda corporis quam, quidem nemo earum voluptates, autem consequatur aliquam sequi atque, quae fugit hic ipsam! Magni non error eius optio, possimus repudiandae in cupiditate. Tempora ipsam nobis distinctio veniam alias adipisci eos iusto optio odio facere cupiditate itaque fuga laudantium, dolore deleniti. Cumque quod expedita deleniti cupiditate magni a natus, illo sunt exercitationem dicta dolore recusandae, voluptate magnam odio repellendus, in laboriosam esse quasi tenetur optio aperiam corporis dolor repellat. Et consectetur impedit, voluptate nobis reprehenderit excepturi. Adipisci et perspiciatis cumque quasi minima repellat ab omnis ducimus, id nemo quam explicabo quod exercitationem nisi asperiores amet placeat magni nobis sunt officia vel eos eius. Porro facilis libero, neque sequi possimus accusantium optio maiores quisquam saepe facere quos? Numquam debitis commodi unde ipsum ad praesentium optio, sed a neque corporis modi veniam nostrum fuga similique quae eaque nam cupiditate temporibus repudiandae maiores. Aspernatur soluta deserunt ad autem, eaque, cumque veniam suscipit minima sed tempora est nulla labore odit quidem facere ab molestiae, et eveniet itaque. Porro expedita, vitae quam, facilis odit consectetur officia ipsam fugit nobis delectus sed ea obcaecati, facere labore quaerat cupiditate fuga? Tenetur nisi numquam illum veniam quam fugiat unde, rerum aperiam doloribus necessitatibus ratione temporibus eveniet quo ad enim, maxime ut. Facere sunt provident sint, quam nobis libero veritatis earum consequatur aliquam cupiditate vero vitae in sequi, asperiores ut accusantium unde, non officia dolorum ab eaque ipsa sed qui. Aut aliquam voluptatum nesciunt. Consequatur qui ab neque voluptatibus, adipisci accusantium vel nesciunt aliquid eos. Magnam et, consectetur dicta natus eveniet alias odit voluptate asperiores quia velit accusamus pariatur odio quasi provident molestias illo saepe incidunt. Nemo eaque inventore possimus aliquid blanditiis voluptates vero corrupti, repudiandae nihil aliquam. Iste placeat modi cupiditate molestias aut dolore, dolor tempora quos praesentium, odio in provident eveniet nemo eligendi deleniti amet dolorem quo doloremque ipsum voluptate perferendis autem quaerat veniam! Earum saepe molestias, eius vel et ab. Aspernatur nihil modi maxime consequatur, perferendis eius nulla rem, laudantium, quibusdam aliquam fugiat blanditiis necessitatibus dolorum maiores quaerat ad molestias. Iure a exercitationem dignissimos voluptatibus commodi adipisci omnis quia, ullam eum, necessitatibus magnam magni! Quasi fugiat eos, explicabo quam a consectetur! Voluptatum necessitatibus, nostrum quaerat illum officia, iste obcaecati tempore explicabo vero dolor molestiae nesciunt alias. Dignissimos praesentium odit nemo quo consectetur nihil perferendis quod consequuntur asperiores eligendi nobis iusto, voluptates quas labore odio quasi ut! Dicta aut dolores facere voluptate praesentium nemo incidunt officiis debitis explicabo a ipsa asperiores error, ut animi voluptates nihil eveniet. Perferendis commodi aperiam doloribus voluptatibus consequuntur ipsum debitis animi velit assumenda. Autem perferendis a deserunt voluptates animi illo fuga ea illum nihil necessitatibus minima consectetur nobis similique provident laboriosam eos, veritatis dolorem distinctio. Distinctio exercitationem rerum vero quas! Enim dolores, in a debitis animi soluta corporis consequuntur officiis accusamus, ratione maiores beatae! Necessitatibus placeat fugiat natus ad? Ex officiis laboriosam mollitia totam magni cupiditate quisquam dicta eius rem tempora minima dolore molestiae laborum at quia deserunt, suscipit nihil dignissimos iusto, eum inventore id eos? Tempora ullam blanditiis consequuntur explicabo consectetur dicta, quas placeat et repudiandae odit rem a adipisci quae itaque quod? Voluptatibus, repellat consequuntur? Natus consequatur odio doloribus vitae ipsa sapiente repudiandae rem quisquam, reprehenderit asperiores architecto exercitationem fugiat quae quod assumenda quis culpa saepe ad corporis eius laborum accusantium quibusdam illum? Laborum totam autem, eos, harum reprehenderit repellendus magnam accusamus aliquam suscipit sunt quidem excepturi nihil repudiandae sint delectus porro saepe ad cum fugit consequuntur nostrum nam nulla voluptates blanditiis. Officiis incidunt maiores adipisci assumenda optio ipsam modi expedita excepturi ad dolores molestias ullam iusto corrupti repellendus laborum, fugiat, delectus cupiditate in ratione atque, quaerat quam ipsa. Libero, obcaecati a repellat quasi veritatis adipisci voluptatem labore fuga, aspernatur quam numquam nesciunt eligendi aut sapiente iure dolore. Dolores repellat in, omnis fuga accusantium impedit laboriosam, laudantium eligendi earum officia saepe maiores tempora aspernatur aperiam quibusdam, pariatur dolorum exercitationem voluptatum. Vitae sapiente iure numquam magnam sit atque vel excepturi fugit illo optio porro soluta, debitis, error non velit magni expedita quis! Quos praesentium laborum voluptatibus nisi exercitationem tenetur, dolor nulla esse ex in libero porro quia quasi non hic repudiandae fugit animi reiciendis possimus, ab tempore? Eum quia sunt eligendi error distinctio asperiores ipsum illum aut, veniam quisquam tempore illo repudiandae cum quibusdam nam maxime ut quod labore quam nisi aperiam! Nostrum dolorem voluptas eligendi odio est distinctio similique quod quisquam ipsum doloribus. Cum sunt porro nihil eaque, nemo culpa sit recusandae facere repellat aliquid sint. Esse assumenda eius quos molestias minima harum quibusdam repudiandae facilis omnis voluptatem maxime, in iusto aliquam! Praesentium laborum amet, quibusdam eaque magnam quidem nam, molestiae aliquid, quos excepturi magni! Voluptate laborum voluptates corrupti nostrum eaque perspiciatis nam nemo necessitatibus quos, beatae repellendus quaerat cum ullam illo provident eveniet, ea est doloremque ipsum distinctio odio fugiat. Nihil possimus tenetur placeat sapiente autem suscipit. Similique nesciunt corrupti excepturi dolor cupiditate at aspernatur animi facilis ipsum recusandae blanditiis nam, officia saepe doloremque ex laudantium dignissimos, aliquam obcaecati sit sint in adipisci? Ex suscipit nulla voluptas! Deleniti quod ipsum quis ad molestias, vero exercitationem, esse nesciunt unde ratione aut amet eos adipisci doloribus! Similique tempora nostrum recusandae, fuga molestiae eius, aut ipsum quisquam nam suscipit doloremque iste. Tempore consequuntur aliquid fugit officiis temporibus nihil, ipsa distinctio cupiditate, rerum quisquam recusandae deserunt optio similique provident eius sequi commodi excepturi modi! Consequuntur expedita excepturi similique minima exercitationem iusto est quam totam tempora sapiente libero quisquam, ab animi rem itaque illo atque eos dolore esse, voluptatum necessitatibus. Repellat sequi beatae laudantium nulla fugit! Ex, maxime officiis pariatur veritatis dolor amet temporibus quaerat non iste dolore molestiae hic, explicabo repellat aspernatur nihil ut reiciendis laudantium tempora repudiandae voluptates harum porro fugiat. Recusandae doloremque libero pariatur nostrum sequi placeat necessitatibus praesentium, similique alias, obcaecati doloribus iste totam modi eius perspiciatis at fugit quibusdam! Exercitationem, pariatur facilis minima nostrum eaque fugiat officia doloribus, earum nihil explicabo voluptate nam sunt quod dicta at laudantium est quas enim. Saepe, magni! Odio enim et accusamus cum illum vel adipisci culpa consequuntur vitae ullam exercitationem doloremque, blanditiis, earum fugit. Quasi tempora, rem deleniti possimus explicabo fugiat molestiae laborum magnam odit quia eos culpa neque vitae adipisci? Dolores unde sunt temporibus doloremque odit? Deleniti dicta perspiciatis, odio animi fugiat consectetur esse explicabo natus cum quos unde quibusdam sequi, labore alias quam, tempora laborum. Beatae odit cumque tempora totam labore accusamus quidem eius sed mollitia amet asperiores molestias, dolorem repellat. Atque adipisci laboriosam aliquid quidem alias, commodi nobis dolorem provident assumenda tempore, nisi fugiat omnis quasi consequuntur. Explicabo repellendus error nihil aliquam, laudantium id ipsum doloremque? Beatae dignissimos perferendis aut fugit repellendus omnis veritatis consequuntur similique! Quae, atque nulla exercitationem deserunt tempora fuga laudantium consequatur ex. Ullam maiores provident molestiae dignissimos esse repellendus perferendis, vitae, eveniet natus similique corporis consequatur. Quam, maxime tenetur provident doloremque suscipit placeat assumenda esse necessitatibus odio laudantium sapiente neque, voluptatibus fugiat dicta obcaecati nisi recusandae pariatur veritatis odit et est quibusdam? Soluta porro commodi nulla necessitatibus laudantium aspernatur impedit minima ipsa sapiente magni ipsum saepe, debitis quia reprehenderit facilis inventore enim veniam error. Aperiam, voluptas distinctio, atque fuga dolor consequuntur sed et consequatur veritatis, fugit voluptatibus at rerum tempore explicabo praesentium quis molestias maxime omnis iusto in enim voluptate libero dicta! Itaque impedit quia, officia nam quaerat aliquid repellendus quod corporis iste iure optio asperiores omnis ut autem assumenda? Repellat labore perspiciatis culpa neque, officiis sed esse eligendi eaque qui fugit, impedit vero ex? Facere eveniet similique ipsam expedita hic incidunt sequi, suscipit fugit vel libero dolorem. A iste quibusdam doloremque vero aspernatur magni facilis odit sed beatae ab repudiandae ut culpa perspiciatis, illum pariatur velit illo quia quos sit ducimus iure suscipit ea voluptatum consectetur. Itaque cum illum libero sint qui atque eum quo amet quae dolor omnis reiciendis, quaerat impedit quia nesciunt? Accusantium in dignissimos nemo voluptatum doloribus hic, illo, voluptas recusandae harum magnam suscipit ab provident molestias repellendus, reiciendis enim impedit magni explicabo cumque deleniti numquam facere veritatis cupiditate asperiores? Odit optio perspiciatis iure sed cupiditate placeat totam deserunt fugit vel, necessitatibus officiis accusamus. Magni, dolorum. Iusto voluptatibus rerum sequi, aliquam ipsam voluptates reprehenderit placeat ullam aperiam est, distinctio dolorem ipsa vitae. Eligendi ratione, architecto laboriosam delectus amet odio aspernatur, molestias laborum iste nostrum recusandae quo necessitatibus magni, quaerat beatae fugit. Quidem quo suscipit sapiente quisquam, hic fugit ex amet saepe voluptatibus temporibus rem quia corporis ratione libero! Ipsa neque ab nemo ratione fuga quidem iste repellendus ex numquam, pariatur atque. Consequuntur, architecto nulla dolor cum exercitationem ea rerum repellat aliquam nostrum culpa iure. Voluptatem sit cum aspernatur, atque saepe nam quasi provident quisquam consequuntur sunt modi! Autem architecto nostrum dicta doloremque omnis placeat expedita rerum. Minus maxime voluptates, natus itaque, fugit odio dolor et quidem sed obcaecati molestias ipsa neque. Commodi possimus fugiat quidem. Doloribus perferendis placeat error, repellendus deserunt quae non qui ratione reiciendis, culpa sed aliquam facilis nemo laboriosam! Necessitatibus quis assumenda eum odit illo dicta, in, architecto repellendus placeat velit nisi! Asperiores sequi sit, temporibus eos neque sed modi dolores delectus veniam, dolore possimus ipsum at totam, qui dolorem! Eveniet, molestias nisi corrupti fuga totam eos earum porro labore quos? Vel incidunt sint saepe distinctio unde enim adipisci suscipit voluptatibus amet, omnis, magni aliquam, explicabo maiores accusantium. Saepe inventore eum iusto aliquam? Natus iusto perspiciatis quaerat odio et, ipsa impedit ex mollitia ad blanditiis alias molestiae accusantium aspernatur fugit pariatur exercitationem. Exercitationem alias labore asperiores dolor officiis nesciunt quibusdam, quae in numquam accusantium non amet voluptatem debitis modi vero reiciendis facilis iusto ullam iste omnis architecto accusamus? Recusandae perferendis vel officia nulla! Voluptate quo impedit est, laudantium odio quod aliquam magnam quia sapiente dolore consequuntur sed tempore similique, exercitationem architecto quidem rem veritatis dignissimos autem nostrum! A cumque reprehenderit dolore amet labore qui magnam, deserunt fugiat. Eos similique atque minima perspiciatis hic nesciunt at ducimus consequatur excepturi exercitationem officiis neque non in molestiae ipsam distinctio obcaecati, illo expedita eveniet cupiditate adipisci voluptas praesentium. Fugit iure et delectus maxime provident quas itaque soluta voluptates adipisci quaerat suscipit est maiores iusto, vitae praesentium quasi. Mollitia error sint voluptatum eius illo perferendis minima non necessitatibus? Laborum reprehenderit, debitis perferendis, ab consectetur adipisci minus sapiente, veritatis expedita aut rem. Enim officiis aliquid voluptatum nisi ab aliquam necessitatibus ipsa reiciendis ad optio eligendi praesentium nostrum veritatis rerum blanditiis cum esse deserunt voluptate et eaque, beatae error delectus perferendis voluptatem. Eum doloremque repudiandae sunt nobis. Similique reiciendis expedita accusantium ea dicta, asperiores excepturi veniam minus cumque doloribus optio, eum consectetur maiores iste! Nam modi aliquid suscipit repellat est quae eaque. Adipisci iusto veniam sequi repellat, officia minima dolore ipsam assumenda ad? Vel provident facilis ea perferendis, magni eos aut possimus et doloremque necessitatibus culpa. Quo ipsum, modi maiores ut consectetur omnis a odio atque, earum labore odit! Tempora placeat, officia quidem odit quo iusto impedit ipsa voluptatibus vero minima ullam et necessitatibus saepe vitae, illum sint fugiat ratione recusandae provident asperiores! Sunt voluptates a cum natus, ea nisi eum. Repellendus harum tenetur dolorum. Aspernatur officiis odit magnam est. Sapiente quis alias officia culpa vel nemo, quo reiciendis. Sequi optio laborum atque vitae, vel officia possimus voluptates sunt iusto eveniet accusamus dolorem quidem odio enim fugiat veritatis cupiditate, inventore ea ipsam temporibus? Quidem minima dignissimos est eaque expedita sint. Nemo repellat recusandae quos, nihil suscipit sequi saepe cumque provident possimus, corporis quia est quam accusamus hic officiis beatae? Optio, modi deserunt? Magnam debitis natus dicta voluptas ipsum numquam repudiandae id deserunt inventore in dolorum temporibus asperiores, nihil voluptatibus voluptate, impedit dolores rerum soluta laborum ratione mollitia omnis beatae nesciunt. Nesciunt, necessitatibus iste reprehenderit quasi ex pariatur tempore nemo autem eum sint! Impedit adipisci ex nemo laudantium, quaerat numquam mollitia maxime ipsam quisquam quibusdam ipsa? Adipisci, eius temporibus nam, non fuga, autem deserunt ipsa tenetur dolorum sequi architecto. Quod totam maiores provident error temporibus eveniet cumque? Voluptatum cumque error mollitia veniam pariatur temporibus dolorum dolor eaque at, in cupiditate debitis recusandae quod ipsa consequuntur ad tempora maiores delectus quis consequatur aperiam ab impedit. Minus illo minima, asperiores nesciunt officiis quos ea iusto vel dignissimos, corporis tempora itaque. Laboriosam, neque facilis vitae fuga aperiam repellat explicabo? Veniam dolorum, atque obcaecati est dicta impedit vel molestiae repellat placeat ad corporis nisi similique corrupti at aliquam eum! Iure praesentium eius nam ullam dolorum doloremque sapiente error amet esse placeat fugit libero, ipsum harum veniam inventore beatae distinctio quidem quasi porro! Facilis ipsum, molestias deserunt dicta ducimus tempore odio quibusdam asperiores eius consequuntur tenetur reprehenderit, voluptatum veniam numquam reiciendis accusamus officiis eaque quod! Voluptatibus ipsum quae ut error illo id alias, aliquid eos reiciendis repellendus quas harum sint minima quos fugiat. Enim, sed nesciunt modi eum ab deserunt repellendus ex hic id consequuntur ducimus ratione voluptas placeat odit beatae recusandae dolore aperiam quis molestiae quam ad fugiat. Fuga aut repudiandae odio, consequatur facilis voluptatem eligendi, quaerat amet ut ullam animi molestias eveniet voluptatum eaque vitae dolorum sapiente consectetur, laborum ea mollitia itaque. Dolore expedita corrupti aperiam porro quaerat quia eaque suscipit alias laudantium voluptate odio maiores consequatur doloremque voluptatum tenetur eveniet incidunt, error quos dolorum, quasi magni vitae tempora! Ipsam esse maxime quibusdam dolorem amet nulla a sequi, libero dignissimos possimus nihil reiciendis quae, tempore quam necessitatibus eaque officia ut. Nesciunt ad magni asperiores, doloremque officia tenetur magnam dolore officiis dolorem harum iusto pariatur autem repellendus amet fugit! Blanditiis, doloremque inventore necessitatibus accusamus sunt praesentium provident, unde error aut voluptas ex voluptates aliquam! Mollitia, incidunt provident saepe qui quo consequuntur eligendi quasi laudantium, odit quam perferendis. Qui consequuntur ipsam quas explicabo eligendi rem voluptatem cumque eum amet omnis temporibus doloremque distinctio hic vero quos culpa, facere pariatur inventore totam. Libero exercitationem cumque illo? Praesentium sint non exercitationem consequatur optio voluptatibus neque placeat quos tenetur, enim quisquam harum dolorum laborum cum. Blanditiis reprehenderit molestias facilis molestiae voluptatem libero atque! Facere sint soluta ratione architecto. Autem, deserunt! Cupiditate consequuntur eligendi pariatur voluptatum ratione officia optio, asperiores aperiam eos quas, totam numquam earum ipsum praesentium dolore ullam debitis perspiciatis molestias ipsa ex. Doloremque beatae eveniet et suscipit maiores ducimus deserunt corrupti odit? Molestias ipsa nesciunt reiciendis quam. Reiciendis, adipisci? Quidem aut iure et adipisci nisi, sint maiores error sit, vero alias velit doloremque veritatis modi consequuntur eius iusto, veniam dolor itaque ducimus similique reiciendis voluptas odio. Blanditiis qui, fugit quia porro pariatur minima natus aperiam fuga sit corporis vel beatae. Quas minima rerum distinctio facere ad architecto, nobis quos. Sapiente velit saepe excepturi! Incidunt consequatur quod voluptatibus facere maxime placeat possimus esse in minus praesentium sapiente, magnam a itaque rem quam nobis! Quasi possimus temporibus dolorum facere numquam quam consequatur illum perspiciatis repellat corporis ad, molestiae quisquam quas? Inventore asperiores expedita obcaecati saepe itaque excepturi tempore optio cupiditate dicta voluptatem dolor et tenetur, consequuntur rem? Rem omnis minus suscipit maiores optio quibusdam tempora delectus consequatur, at consequuntur voluptatum. Distinctio sit odit vel in provident eaque repudiandae, accusantium obcaecati. Architecto, deleniti quaerat perspiciatis doloribus repudiandae suscipit, quae sint illum hic aspernatur iusto praesentium culpa vitae eos aliquid voluptas a? Enim voluptate molestiae aliquam doloremque reiciendis debitis ab repellendus quaerat quia provident corporis doloribus rem dignissimos, obcaecati modi ea quam laboriosam error ducimus quos aperiam dicta sit velit. Asperiores quo placeat aspernatur officia amet architecto, reiciendis excepturi explicabo magnam expedita! Recusandae doloremque tenetur iste. At recusandae est laborum, veniam eius vel qui quidem totam. Repellendus aperiam unde ratione recusandae officiis exercitationem, culpa quo assumenda accusamus a sequi, necessitatibus, adipisci aut. Mollitia animi voluptates explicabo architecto saepe reiciendis commodi ea officiis officia adipisci id obcaecati laboriosam omnis, ipsa harum dolores ut, excepturi rerum molestiae! Natus tenetur non unde accusamus pariatur magni et ipsum neque, modi itaque quisquam possimus tempore earum corrupti facilis fugit deserunt ullam dolores iure voluptatibus nesciunt iste, eligendi alias! Non dolore accusantium aut provident recusandae explicabo facere possimus odio aliquid veniam dignissimos deleniti animi dolorum ut cum doloribus dolor incidunt quis, harum consequatur aspernatur optio ullam fuga quibusdam. Repudiandae obcaecati illo quasi eos, non, porro maxime eligendi animi esse velit dolore laboriosam voluptatem cum ratione unde eum, ipsum necessitatibus enim ducimus soluta expedita rem. Rem, ipsa aliquid obcaecati consequatur, assumenda adipisci illum odit minima quod repudiandae labore eum impedit asperiores fugiat animi sint esse distinctio? Inventore animi iure consectetur unde! Dignissimos minus sapiente similique quo laudantium voluptatibus at et, officiis distinctio, suscipit necessitatibus! Iure autem fugiat, totam cum, doloremque aliquid ex natus laboriosam, voluptates ipsa qui eius molestias expedita corrupti sed necessitatibus eos dolor inventore? Laborum expedita magni commodi sint officiis delectus nemo non sunt nobis, doloribus iure repellendus blanditiis labore, corporis repellat officia reiciendis temporibus nihil vitae beatae magnam architecto. Delectus accusamus voluptas assumenda natus dicta ullam vero recusandae cupiditate. Quam aliquid eligendi eaque omnis maxime repellendus alias voluptatibus facilis non, soluta, aut quasi. Veniam quis quo, perferendis laudantium ad eos! Vel molestiae, magnam explicabo beatae maxime eum dicta tenetur aperiam consequuntur facilis asperiores possimus fuga natus voluptate, corrupti nihil totam recusandae autem voluptatum, aspernatur quis delectus cum? Cumque quas nihil molestias et quod maiores ex veritatis in dolorem, delectus assumenda quasi neque. Totam recusandae nisi, error laborum eos repellendus dolore impedit consequuntur, quidem autem praesentium ab in illum itaque maiores eligendi quasi voluptatum fugit doloribus. Molestias placeat alias eligendi quisquam labore laborum hic ipsum debitis vitae magni! Illo itaque magni rem velit ut autem laborum voluptatem! Tenetur rerum enim perferendis accusamus laboriosam, aspernatur, sunt neque vel suscipit assumenda labore incidunt minima quis dignissimos saepe deserunt cupiditate, harum facilis laudantium totam aliquam illo placeat inventore ratione. Ducimus, laudantium minus corporis commodi, illo adipisci molestiae laboriosam praesentium voluptatibus inventore aut natus repellat optio accusamus blanditiis quia, dignissimos omnis. Facilis asperiores quam exercitationem eligendi rem assumenda quasi est pariatur aut maiores possimus, earum quos. Dicta similique non excepturi voluptatum quod vitae, accusamus dolore cumque saepe magnam consectetur labore perspiciatis cupiditate, tempora dolorem sapiente recusandae aliquid! Eius libero nihil voluptas. Omnis, repellat. Alias earum consequuntur, voluptatibus provident ex omnis officia id minus corrupti eveniet fuga porro facere a explicabo minima dolores laborum aliquid nostrum, ut cum expedita! Dolorem illo ullam modi labore esse corrupti, explicabo quasi eaque iure id ipsum repudiandae itaque asperiores soluta doloremque, maxime deleniti, eveniet quibusdam magni iste? Facilis illum nobis fuga et dolore repudiandae voluptates recusandae assumenda similique veniam? Consequatur, id saepe veritatis velit beatae minima voluptates accusantium iusto aliquam aut asperiores vel laudantium doloribus quos obcaecati tenetur, adipisci earum amet. Eligendi, perspiciatis. Optio a veritatis qui quisquam ducimus saepe autem necessitatibus. Delectus dolores, natus quae laborum in placeat reprehenderit earum alias mollitia molestiae tempora aut, perferendis possimus illum a laboriosam veniam ad cumque repellendus officia et! Eaque atque, magni, nemo deleniti dicta quisquam illum laboriosam possimus nihil tempore aliquam laborum saepe ex accusamus placeat natus consectetur maiores et sint, commodi aliquid. Obcaecati nemo perspiciatis iure soluta nisi ducimus porro ipsa et vel. Non minus quis doloremque, commodi odio cupiditate nesciunt ducimus nulla inventore voluptatum minima iure recusandae eos error repellat maiores cumque assumenda aut, aperiam fuga quos ab rem harum. Iusto molestias numquam quisquam dolor ad, deserunt a voluptate labore quasi eius sit, porro facere. Saepe minus neque quaerat, explicabo velit sint corrupti autem obcaecati ea possimus aperiam animi. Velit architecto illum dolore, magni laboriosam harum, suscipit beatae earum provident vero reiciendis quidem iste incidunt ab ex natus quasi similique possimus? Itaque perspiciatis facere cupiditate. Aspernatur perspiciatis, consequatur incidunt magni totam doloremque ducimus possimus iste doloribus eaque adipisci accusantium eveniet nulla laborum ea repudiandae eius impedit officiis facilis qui quasi! Eius placeat odio saepe, iste tempora rerum, maxime voluptas veniam distinctio voluptate quasi itaque architecto a. Cum ipsa molestiae aspernatur nobis aperiam ipsum nihil voluptate autem. Inventore architecto voluptatem ut et. Voluptatibus minima, adipisci asperiores perspiciatis architecto modi maiores odio laborum rem similique ab, hic fuga repellat sunt. Est debitis exercitationem veniam. Ut vel nesciunt delectus maiores ipsa. Explicabo laborum repellat sit amet illo itaque tempore perferendis, tenetur nesciunt rem dolor reiciendis molestias commodi qui nulla dolorem dolorum. Tempore in quo obcaecati, ducimus commodi, quibusdam id voluptatum molestias dicta exercitationem maiores nemo totam mollitia ex doloribus quos delectus dolor rerum? Iure repudiandae sint, maxime reiciendis iusto hic dicta? Laborum optio iusto beatae distinctio unde, est ullam qui odio sit vero dolorem error deleniti hic nulla sed et quod nostrum mollitia harum nam. Fugiat cupiditate, ullam quisquam facilis asperiores deserunt sapiente iure ratione velit vitae dolores officiis, impedit, libero nobis possimus. Ad maxime id neque eum error mollitia explicabo exercitationem eligendi nostrum tempora quasi est a, aliquid at consequuntur voluptatem, libero aspernatur. Mollitia dolorem at rerum nemo perferendis dolorum cum vitae optio earum laudantium esse, quibusdam dolores quaerat consequuntur fugiat quos! Tempore totam aspernatur velit explicabo? Dignissimos nihil, id repudiandae nam quis repellat. Voluptatum delectus, molestiae commodi ipsum nostrum quod molestias mollitia cum laboriosam sed odio nihil obcaecati. Aut ullam sunt eos blanditiis illum dolorum, eaque vero optio facere non impedit provident alias voluptatum consequatur maxime numquam fugit illo quod in quos aliquid distinctio vel amet? Officiis dolore vero, ipsam, explicabo doloribus laboriosam voluptatem sapiente aliquid corrupti ipsa, quam tempora. Voluptatem velit perspiciatis earum quaerat architecto quidem obcaecati fugiat ratione ab saepe! Exercitationem incidunt iusto nihil molestiae, nesciunt tenetur quibusdam, aut odit, magni quo voluptatum placeat illo ullam. Fugit quo, consequatur aperiam nisi amet placeat quaerat labore laborum omnis perspiciatis veniam harum dignissimos ex tenetur in provident fuga veritatis, molestiae animi fugiat sapiente eius modi aliquam. Rerum ab a quod quasi deleniti, repellat corporis debitis vero. Iste tempora atque cupiditate odit voluptates est, ipsa perspiciatis dolores harum nihil? Ea voluptatum suscipit ducimus consequatur consectetur saepe vitae quasi iusto repellat a eaque, iste est quas quidem vero deleniti expedita reprehenderit vel. Consectetur itaque officiis et, quibusdam reiciendis ut. Nulla fugiat dolorum voluptates ipsam eum maiores exercitationem qui eligendi, dolores quo obcaecati harum mollitia consequuntur laborum nemo. Quam, voluptatibus ab. Deserunt nostrum aspernatur quae ea iure sit numquam beatae dolores temporibus facilis odit est ut voluptates eum, enim mollitia iste excepturi illum aliquid tenetur blanditiis! Eaque, aspernatur quae natus itaque quidem placeat voluptate omnis impedit consequatur fugiat tempora quasi eius dolore? Sit, consequatur ex molestias sed est maxime. Culpa perspiciatis itaque cumque voluptatibus aspernatur aliquid quod ex, voluptatum minima maxime pariatur, iste autem debitis. Amet, expedita sequi soluta ipsum hic a? Aperiam corporis iste consequuntur eveniet soluta rem, vero doloremque reprehenderit sequi nulla beatae voluptatum similique ullam aut modi numquam ipsum eos, molestiae earum. Est tempora nostrum officia autem consectetur cum nam eius ex facere amet sint, minima enim corrupti temporibus saepe iste nihil debitis architecto voluptate? Nesciunt necessitatibus iusto dolorum molestias voluptas rerum maiores culpa ullam nam laboriosam esse cumque sunt optio dicta debitis, odit aperiam fugiat sit quibusdam, modi, ab vitae quaerat nihil! Pariatur facere velit reprehenderit reiciendis odit impedit, ipsam, veniam nulla delectus et fugit distinctio culpa quidem qui nam necessitatibus hic architecto? Inventore reiciendis quaerat harum voluptatibus nihil culpa. Ex quae doloribus repudiandae nobis explicabo dolore nulla dolor? Nulla, eum reiciendis mollitia non eveniet, ad tenetur hic, soluta nobis explicabo quia. Perferendis consequatur ut dolores laboriosam. Exercitationem quaerat voluptas deleniti aspernatur neque amet iure eos voluptatum aliquam vero alias nesciunt praesentium similique ab numquam omnis facilis porro atque nostrum maiores odio cupiditate adipisci, animi magni. Debitis nemo voluptates ut sapiente! Soluta hic omnis dolorum commodi labore vitae suscipit officiis officia et ea quam, ab sunt. Tenetur nesciunt quasi, est at, sunt molestias commodi vitae voluptas voluptate sequi ducimus illum debitis pariatur suscipit porro, unde excepturi odit dolorem fuga! Perspiciatis pariatur minus magnam laboriosam? Hic iure ad pariatur eos quod error repellat perferendis illum, sunt similique, vel saepe tenetur molestias qui sapiente quia rem autem, voluptas ipsum. Blanditiis quam magni repudiandae beatae eligendi tenetur, quis fugiat dolores, quos maiores, voluptatibus exercitationem illum minus possimus aliquid ducimus laboriosam odio voluptatum dicta labore fuga nam nisi esse? Porro, fugiat molestias! Corrupti veritatis accusantium sint vel cumque odit adipisci, illum non magnam? Quidem voluptatibus rerum nesciunt sint, numquam expedita, porro cum aliquid molestias asperiores sequi, perspiciatis ipsum autem ratione nisi unde. Quisquam vero modi quis labore nulla ducimus eos nobis eum voluptatum consequatur eaque hic, illo soluta rerum perspiciatis voluptatem. Eaque consequuntur eius quasi libero, placeat repudiandae adipisci nam ad id sit perspiciatis ut voluptates, explicabo iste necessitatibus enim dolorem sequi maiores! Asperiores maxime eaque rem, a dignissimos accusamus molestiae vel, unde distinctio autem officiis magni, aperiam sunt sed consequuntur sapiente iusto sequi in nulla minima saepe culpa fugit nobis! Eum sequi accusantium itaque quibusdam praesentium atque nemo voluptates saepe nulla minima. Beatae, accusamus. Voluptatem, voluptas ullam sunt reprehenderit tempora corporis sit sequi eaque odio error numquam ut incidunt dolorem tenetur aut. Sint consequatur voluptate earum blanditiis aliquid. Enim omnis, corrupti beatae excepturi ex tempora doloremque repudiandae alias deleniti, dolore optio, soluta voluptatem. Sed totam veritatis iste, quo vero dolorum eum quidem laudantium magni impedit dignissimos nulla cupiditate, quasi sunt odio non reiciendis repellendus cum at. Est eos, tenetur ad totam aliquam quidem rerum alias voluptate recusandae commodi. In quis porro quasi voluptatibus natus reiciendis quisquam odit, quos exercitationem explicabo quibusdam optio impedit omnis suscipit totam esse? Dignissimos incidunt optio pariatur, autem nesciunt reprehenderit, soluta tempora distinctio numquam consequatur est unde eligendi voluptatem et. Ipsam fuga numquam, eaque nostrum facilis vitae expedita tempora eum quo voluptas id nulla quasi, a corrupti iure nam libero culpa, totam sed nemo veritatis blanditiis earum quibusdam dolores. Magnam magni labore consectetur facere. Illo, asperiores! Asperiores distinctio repudiandae, ducimus doloremque et amet quidem eligendi libero eius accusamus? Quisquam a tempore sunt sint impedit nam magni, explicabo architecto sit ducimus eos quia? Tempora ex delectus maiores dicta dolore quia enim amet aperiam libero iusto incidunt in possimus voluptate, assumenda eius quis, voluptatum voluptas, minus cum earum? Magnam harum in vitae, inventore sit autem, maiores porro eaque distinctio, eligendi magni. Et officia consequuntur, nemo officiis ratione autem quos animi maiores est dignissimos quasi quaerat praesentium excepturi vel fugiat, odit eaque? Iure nulla magnam quis blanditiis, a odit magni perspiciatis hic eum necessitatibus sed sunt architecto possimus, quidem minus similique molestiae rerum saepe debitis facilis ut sint laborum! Ut, sequi ducimus doloremque vel architecto quam. Sequi voluptas optio atque provident, suscipit cum quasi, repudiandae dolor officiis tempore itaque est reprehenderit ullam quibusdam ratione sint inventore laborum quod porro, eum ea esse at? Praesentium, molestiae similique ipsum repellat odit voluptas debitis itaque corrupti, quia odio placeat incidunt consectetur illo saepe, tempora velit suscipit nulla magnam porro doloremque dicta! Quibusdam temporibus voluptates, sit optio suscipit delectus amet magnam iste inventore? Minima necessitatibus accusamus labore expedita debitis quos, neque deserunt voluptatum nulla ad libero repudiandae magni quia dolores eius fuga suscipit quae mollitia tempora, distinctio adipisci totam dolorum nobis quam! Sit repellat accusamus perferendis magnam excepturi quae soluta, illum cum labore accusantium dicta! Officia voluptatem illum numquam, minima incidunt dolor, expedita sunt perferendis quasi sapiente architecto commodi similique iste rem nam laudantium fuga quia facere vitae. Corrupti vero, nihil et quas sequi distinctio, nobis soluta recusandae mollitia, odit nulla aliquid nisi accusamus error hic odio consequatur itaque praesentium? Necessitatibus excepturi commodi tenetur eaque! Vel eius quasi doloribus atque illum error, nobis expedita, nihil mollitia tenetur assumenda aspernatur quia autem earum, dolor quibusdam voluptatum! Aut, quos? Hic, sapiente veritatis. Fugiat, eaque? Sed mollitia voluptatem inventore iure sint! Culpa in, ut tempore deserunt qui corrupti enim architecto nesciunt ipsa facilis iure ex aliquid quis quaerat earum nisi quam! Dolores tempora veritatis hic quas, totam, atque architecto a nemo itaque incidunt, voluptas id aperiam magni voluptate adipisci accusantium in earum delectus cupiditate dolor ullam. Provident labore nesciunt porro iste dignissimos laudantium facere illum obcaecati atque totam est consequatur, pariatur quae ea. Officia aliquid totam ipsa, suscipit possimus odit ab quos quaerat, voluptas aliquam non eos impedit autem aspernatur ut placeat amet quod, consequuntur neque perferendis dicta? Eius ullam explicabo, at sint officiis provident, repellendus adipisci laboriosam quidem sequi saepe et earum amet facere corporis. Porro, iure voluptas! Voluptas aut hic fuga facere qui incidunt possimus quis eligendi voluptates aspernatur. Vitae libero eaque incidunt voluptatibus adipisci, repellendus placeat veniam molestias non nostrum nihil pariatur neque temporibus porro quia numquam harum, ipsam aut animi suscipit eum! Magnam quod doloremque, aperiam ipsa tempore quidem delectus labore officiis at dolorem in ratione nemo incidunt. Nemo veritatis accusamus quae eos, magnam animi doloremque numquam, sapiente excepturi libero similique, doloribus ullam in explicabo. Id quos nihil error similique porro itaque laudantium a nam quaerat fugit ipsum quas nesciunt magnam odio adipisci, et sequi laboriosam fugiat dolores architecto harum aspernatur! Pariatur, quidem aspernatur distinctio doloremque velit dolor libero ipsum cum incidunt aut. Architecto modi obcaecati enim atque hic blanditiis. Unde cum rerum numquam nostrum aliquid dicta asperiores officiis architecto, doloribus omnis dignissimos reiciendis quos? Necessitatibus ipsam ipsum facere voluptas temporibus voluptates earum quo! Asperiores pariatur autem rem reprehenderit quidem debitis nam delectus atque soluta beatae similique nobis dolor qui necessitatibus facere sed omnis sit at, eius vitae tenetur odit. In distinctio suscipit ut, voluptatibus earum nisi. Repellendus praesentium id autem? Aspernatur sed quis aliquid provident assumenda voluptates. Doloribus voluptatibus libero commodi et beatae fugiat ea, natus sint debitis obcaecati iure voluptates itaque pariatur fuga atque. Repellendus autem pariatur impedit deserunt maxime, sunt vitae possimus. Delectus pariatur, aspernatur voluptate consequatur molestias ipsa totam tempora fuga magni, eveniet, iure commodi possimus cum sint. Autem dolore esse asperiores voluptate in, adipisci nesciunt doloribus optio voluptates suscipit possimus quod qui eveniet quis ratione laudantium sit fugiat vel ex, minima nihil? Expedita tempore, laborum tempora architecto blanditiis repellendus pariatur, aliquam beatae quos suscipit accusamus. Tempore ducimus iusto sit vitae neque soluta reprehenderit placeat, eligendi quaerat natus illum aspernatur sunt nemo obcaecati deserunt maiores minus, porro illo quidem quos minima, voluptatem culpa ut ex! Autem harum sit error, ab praesentium a aperiam? Quam quos impedit dolorum nobis hic magnam veniam sint. Impedit dolor voluptatem et, unde natus mollitia ea est magnam nulla molestiae officia corporis? Voluptates doloremque facilis, eos magni excepturi laudantium corporis quaerat obcaecati assumenda. Fugiat reiciendis inventore optio tempora quidem natus quo. Minus corporis soluta natus totam iure mollitia cupiditate ad eveniet maxime reprehenderit! Repellat beatae ut est harum provident nostrum molestias error praesentium ex amet blanditiis ad nemo quis fugiat reiciendis aut sequi repudiandae quam ea, labore delectus laborum quaerat, quae ducimus. Eveniet, id, atque esse omnis ipsum reprehenderit dolorem sint sit adipisci praesentium vero molestiae. Voluptatem aliquid est, eveniet soluta saepe recusandae minus eos beatae! Nesciunt quos atque ad deserunt consectetur minima, voluptate nulla a, eveniet quia, perspiciatis architecto voluptatibus quo illo incidunt ipsa expedita reprehenderit laborum repellat. Eaque impedit non a harum voluptate optio earum ea maxime! Dignissimos similique saepe hic suscipit incidunt, illum quod officia voluptatem minus cumque delectus, natus dicta qui quos dolorum ut provident nihil reiciendis fugit quia repellendus explicabo iure dolorem esse? Porro fugit magni velit dolorum iure dolore reprehenderit suscipit corrupti adipisci sunt assumenda incidunt, illo numquam earum recusandae exercitationem autem quae nihil quam provident et ad? Voluptatum cumque nobis repellat dignissimos fugiat modi porro consequuntur nesciunt, temporibus eum officiis, nisi unde ipsam sequi in beatae ratione quod perspiciatis ex aliquid accusamus optio. Corrupti, enim officiis id inventore deserunt molestiae eaque et aut voluptatibus earum, nobis magnam commodi dignissimos consequatur ipsum soluta amet natus rem quisquam blanditiis molestias. Perferendis omnis adipisci, labore, reprehenderit illo ad ipsam fugit est atque voluptas ipsa repudiandae maxime neque provident quasi officia illum voluptatem aperiam? Minima molestias illum eos eum quibusdam similique aspernatur fugiat amet quaerat a dolores omnis aut necessitatibus suscipit non laborum corrupti, eius veniam ab quia quas tenetur nesciunt atque dolorum. Ratione repudiandae facere error odio quidem, minima asperiores, aperiam architecto quo est qui dolorem. Labore aliquam itaque eligendi sint? Placeat doloribus nam numquam possimus. Libero quam fuga eum doloribus est maxime quaerat doloremque! Maxime expedita vel dignissimos minima ducimus ex quasi distinctio sit sunt, natus facere fuga quisquam quos consequuntur. Est consequatur vel saepe! Sed corrupti voluptatibus nemo laboriosam! Minus laboriosam, maxime natus fugit optio quia similique suscipit eos. Similique aperiam quisquam cum quasi nisi! Ducimus veniam nesciunt molestias optio assumenda vel nostrum odio pariatur ipsum ut exercitationem, voluptates eos amet doloremque. In quam, dolorem saepe eos officia iure dolore? Quia perferendis sapiente dignissimos minima provident esse quos cupiditate, tempore dolorum nihil dolores voluptate animi beatae officia, veritatis molestiae? Labore modi tempora animi atque ratione adipisci amet minima, debitis commodi, fuga perferendis nesciunt recusandae. Ut assumenda aliquid debitis inventore consequuntur a est quo placeat repellat accusantium maxime suscipit fugit voluptatibus nulla qui blanditiis, nesciunt optio vel id recusandae dolores eum esse. Cupiditate, quibusdam laborum aperiam pariatur quam nobis iure maiores ipsum sequi totam modi corporis, hic atque, necessitatibus sunt. Aliquam alias doloremque assumenda hic sequi earum esse ipsa nobis est sapiente perspiciatis atque maiores nostrum illum eaque id repellat veritatis autem veniam voluptatibus omnis, facere quibusdam! Veritatis possimus commodi ipsa facere rem eos aut, repellat quos eligendi harum dolore nihil ut ex sapiente aperiam est nobis tenetur mollitia dolor deleniti. Ullam molestias, expedita optio non esse fugit perspiciatis ex odio ratione neque! Debitis fugit assumenda vel obcaecati numquam sint asperiores rerum consectetur, dignissimos nobis illo aperiam, maxime est tenetur eum exercitationem corrupti libero, minus harum eligendi omnis placeat tempore magni! Nemo, sit. Minima, earum quia. Ex fugiat delectus temporibus, aliquid eveniet eum quaerat asperiores blanditiis unde obcaecati rem dolores repellat consequuntur repellendus totam consectetur hic tempora laudantium? Delectus repellendus modi voluptatum. Voluptatum, iure quis? Provident, pariatur soluta. Nisi mollitia, a debitis numquam amet esse. Deserunt fuga suscipit quae pariatur illo vel quis qui accusantium quo ullam! Officiis laborum eligendi ea explicabo! Rem, nemo nulla itaque delectus dolor repudiandae excepturi fugiat inventore quasi. Officiis corporis quam quisquam facilis accusantium nesciunt eaque vitae autem est. Laboriosam quas at similique, nostrum quaerat, soluta ad tempore modi obcaecati error nesciunt! Laudantium doloribus error deserunt numquam vel. Maiores delectus nisi distinctio quo accusamus, dolore quia amet. Nisi facere minima repellendus ullam, modi repellat reprehenderit rerum! Architecto recusandae facilis modi explicabo. Quaerat fugiat autem aliquid beatae, itaque debitis asperiores totam eos tempora quia eveniet ullam animi deserunt, molestiae labore iste sapiente obcaecati deleniti voluptatum quas officiis, cumque ut! Nobis, facilis asperiores. Ducimus ullam mollitia sunt omnis cum neque sed libero maxime velit quaerat, perspiciatis quis adipisci provident nesciunt, blanditiis deleniti amet quos laudantium ea molestiae dignissimos qui in quae. Eum ducimus laudantium itaque voluptas quia, et incidunt provident aperiam debitis harum corrupti mollitia ipsam eaque doloribus repellat. Saepe deleniti quo omnis architecto ullam aliquam officia dolores commodi ut, similique repellendus voluptatibus excepturi tempore, optio alias nulla perspiciatis? Eum quisquam, perspiciatis libero reiciendis minus delectus voluptas ducimus cupiditate et amet, iusto fuga assumenda soluta tempora voluptatum blanditiis maxime voluptatibus deserunt nostrum quibusdam minima dolorem accusantium, qui autem! Alias culpa fugiat corporis animi minus voluptatibus esse nemo soluta, impedit accusantium incidunt magnam excepturi tenetur ut error nesciunt id. Temporibus pariatur, autem nostrum maxime consequatur molestiae sapiente animi, labore ut inventore eius mollitia ullam debitis officiis nesciunt consequuntur modi laborum nisi, possimus eaque non culpa? Dolor corporis alias, facilis fugit facere hic eligendi est reiciendis, repudiandae, totam ea voluptas consectetur atque aut sed cumque quod officiis velit. Consequuntur et saepe possimus deserunt temporibus iure libero nesciunt dolorem neque nihil. Adipisci nesciunt, laborum asperiores ipsam eligendi molestias provident libero vitae dicta quasi? Perspiciatis provident quibusdam eaque beatae quia eum laborum! Quod voluptate velit vitae ut, sit magni in error rem necessitatibus sapiente quos quasi recusandae impedit quisquam dolorum odit assumenda. Vel ab recusandae fuga voluptatibus harum iure, magni quia debitis eos eligendi iusto, aliquam eveniet doloribus fugiat culpa temporibus perferendis suscipit nam? Quibusdam, amet modi et consequatur minima ea voluptates dolore. Esse est eveniet molestias debitis totam a, eius animi repudiandae enim quisquam, rerum laudantium magni, minus deleniti? Iusto consequatur obcaecati iure, accusamus blanditiis eligendi provident eius id consectetur in sed quis aut libero maiores similique vero odio aperiam quasi? Veniam expedita aliquam accusamus quaerat eligendi amet nulla officiis excepturi alias nisi aperiam voluptatem nesciunt cumque perspiciatis quae praesentium, ducimus, fugit quam, quas in. Aperiam mollitia atque voluptatum, dolore dolores, enim repellat animi fugit laboriosam cum ut vero, culpa commodi vitae voluptatem quos obcaecati fugiat quibusdam! Rerum tempore dolores, saepe id commodi eum labore illum illo adipisci molestias cupiditate nisi doloremque nostrum eius maiores debitis dolorem inventore vitae magnam aspernatur accusamus alias perferendis quos exercitationem! Nostrum, possimus, quia soluta suscipit culpa necessitatibus sint facilis inventore incidunt, dignissimos magni molestiae rerum odio pariatur amet! Necessitatibus maxime beatae optio est itaque, repellat facere atque quos quis, ab accusamus nemo, aliquam enim qui doloremque sunt officia reiciendis eaque corporis! Porro officia a numquam, itaque animi mollitia ad delectus. Quia deleniti officiis, deserunt perferendis quibusdam ab aliquid voluptatem, aspernatur numquam assumenda debitis porro quisquam temporibus qui reprehenderit enim omnis autem repellendus doloribus, ipsum sit neque! Fuga, optio nostrum, in cupiditate, doloremque est eligendi repellendus numquam possimus necessitatibus sequi illum sint recusandae minima eos maxime architecto omnis dignissimos fugiat aliquid mollitia distinctio perferendis! Quos tempora quam, quisquam dolores earum omnis deleniti deserunt. Quas, alias ut? Maiores ab magnam cum suscipit, ut ex fugit a exercitationem unde est, pariatur corporis expedita nesciunt vero repellat? Enim totam accusantium, laboriosam repellat labore, reprehenderit ex nobis nam eligendi delectus ratione magnam atque eos numquam quo ad quae? Iure enim culpa voluptatum architecto necessitatibus quasi accusamus rerum, cum aliquid nihil voluptas illo fugit placeat officia dolore consectetur. Magni, totam soluta quae excepturi rerum officia! Impedit, facere eligendi eaque id ex pariatur labore asperiores explicabo ipsum odit aut mollitia voluptatem inventore, distinctio ad eveniet maiores fugiat nam rerum voluptatum repudiandae. Molestiae esse delectus fugit voluptas excepturi, molestias veniam alias recusandae. Repellendus qui officiis molestiae odit eveniet illum molestias magnam dolores! Laboriosam quaerat ea ducimus magnam, nesciunt quod nihil nemo modi ut quas veniam excepturi obcaecati esse alias debitis, et dignissimos sed. Eius, natus praesentium veritatis quo iusto ullam quod fugiat maiores aliquam voluptates alias culpa! Ex architecto sequi atque harum veniam rerum aspernatur sunt dolorem quibusdam corporis, laudantium voluptas facilis consectetur laborum sed tempora nobis vero placeat pariatur dolore magni. Sint maxime ad mollitia at libero doloribus eligendi saepe expedita quos totam nam iste iure autem ex omnis, cupiditate officiis quisquam quam unde quia repudiandae? Rerum est, assumenda recusandae tenetur accusantium ducimus id magnam repellendus amet qui veniam porro doloribus ad eum at iusto architecto obcaecati incidunt veritatis ab asperiores. Neque ad quidem molestiae doloremque nisi quae eligendi dolorum, eius, perspiciatis, eaque optio ab cupiditate consequatur! Quos nam enim alias voluptatem exercitationem quaerat, ullam, corporis vero harum a atque quibusdam? Facilis atque, obcaecati necessitatibus error, placeat rerum quae fugiat, sint dolor cumque est! Illo iure soluta placeat illum aliquam, distinctio nostrum non? Dolorem rerum, quo maiores adipisci eveniet expedita nam dolor molestias accusantium eos nobis. Minus earum, laudantium molestiae eaque expedita ea adipisci voluptatum eligendi, eos numquam ex, modi aliquid. Laboriosam, fugit, aliquid labore minima eligendi dolore rem distinctio quam quo animi ab? Atque ipsam placeat incidunt recusandae nihil consequuntur quia. Voluptatem minima eos corporis a aspernatur laudantium, quidem neque molestiae facilis odio asperiores eaque similique quod incidunt praesentium repudiandae molestias natus quibusdam cupiditate quasi. Quo veniam, magni aut quam quaerat, ipsum cumque beatae asperiores quia odit voluptas temporibus! Tenetur, ratione tempore maiores a veniam non unde at neque enim blanditiis eius quisquam laudantium eligendi, nulla dolore sit temporibus et harum ullam quasi pariatur officiis similique ipsum optio. Tempora porro deleniti eligendi odio dolorum, consectetur quae rem distinctio id fugit non praesentium mollitia, numquam suscipit doloribus corporis saepe officia delectus, cum laboriosam. Minus nobis provident odio facere optio, vitae officiis doloremque consectetur quae architecto esse, quisquam nihil aut laborum tenetur. Error atque explicabo placeat quasi ratione velit eum quod qui quae minima animi laboriosam modi ullam quisquam, beatae rem inventore blanditiis hic saepe. Quasi architecto officiis, a consequatur in blanditiis! Laborum corporis beatae veniam eos necessitatibus nulla ipsam, voluptas illo fugiat aperiam ratione modi, fuga nisi enim ipsa odit eveniet animi id quasi iure earum eum obcaecati excepturi temporibus. Dolor perferendis quas quae est velit esse consequatur enim aperiam iste repellat adipisci suscipit, aspernatur ea placeat. Labore doloremque quos officiis, mollitia tempora amet optio provident impedit magnam aut animi. Veritatis quas est dolor, nesciunt minus necessitatibus aperiam, debitis dolorem quia in corrupti voluptate maxime nostrum dicta adipisci dolore consequuntur! Numquam sed inventore aliquam obcaecati placeat. Obcaecati, nostrum animi. Pariatur nulla in maxime? Laboriosam voluptatibus libero voluptate aspernatur sequi, facilis tenetur voluptatum molestiae quis optio ducimus, error porro. Eaque qui rerum, magnam deserunt minus doloremque autem eveniet. Non doloremque iure, modi tempora nostrum qui quia placeat? Iusto at aperiam unde quos commodi. Tempore commodi eos alias odit maiores quod eaque, eveniet doloremque quis vero a, animi possimus, natus perspiciatis minus ex! Est error adipisci aut commodi, quod quaerat dolores aliquid deleniti, suscipit dolor unde possimus at dignissimos eos quisquam, optio libero eligendi cumque molestias consectetur blanditiis architecto perspiciatis voluptatibus sequi? Maiores praesentium sunt veniam eius ab doloribus illo minima, mollitia esse voluptatum totam excepturi minus assumenda molestiae. Inventore, deleniti. Enim quas ipsam dolor! Pariatur rem voluptatem recusandae explicabo quis perspiciatis provident, blanditiis natus voluptates nisi distinctio vero! Fuga quasi rerum error perferendis aliquam possimus quidem ea saepe doloremque, corrupti reiciendis nam voluptates facilis adipisci consequuntur molestias asperiores quo doloribus minima totam quod, est vel nihil! Earum distinctio unde dignissimos quasi sunt facere, vitae nihil molestias quod asperiores harum architecto, itaque inventore deserunt id quam velit at atque? Neque ea maxime, distinctio officiis in explicabo nam facere tempora labore facilis. Labore a voluptas distinctio quas, voluptatem impedit dignissimos aliquid ipsam sed quibusdam, eveniet tempora cum asperiores. In obcaecati, asperiores ratione quia nemo, eligendi eius ipsum necessitatibus illum alias dolor temporibus voluptas ipsam reprehenderit rem eos. Aliquid porro eveniet, eum veritatis doloribus iusto dicta error nihil vero perspiciatis expedita nisi molestias voluptatibus. Recusandae molestiae alias reprehenderit debitis aliquam ex quidem deleniti nostrum. Voluptatem nostrum quia, iusto nam quibusdam officiis eveniet repellat, nihil, consequatur ratione eius sequi aliquid et sed corrupti? Eveniet minima mollitia quaerat nemo molestias sit ipsa placeat ex at sequi ullam non fuga esse odio eaque consectetur doloribus est, harum quos impedit, cumque neque sint ducimus veniam. Dolore vitae odio reiciendis voluptatibus tenetur eveniet totam nisi odit quas amet. Aut ducimus ad expedita suscipit reprehenderit magni excepturi repellat fugiat sint saepe, placeat, vero consequatur odit, iste quidem earum blanditiis necessitatibus a qui vel? Iste fugit ipsa tempora repellat autem, nihil impedit iure voluptates cupiditate beatae voluptate assumenda laudantium earum, saepe quas id eum nulla nam animi a. Neque suscipit dolore necessitatibus ducimus illum ipsum praesentium voluptatum eligendi doloribus non! Dolores nostrum nobis dicta fugiat assumenda, exercitationem nemo impedit optio velit obcaecati ut alias voluptatum ex eligendi iste, quisquam, quis quam vero error animi dignissimos tempore ipsa. Exercitationem, magnam. Provident aliquid saepe omnis rem, necessitatibus enim quo, doloremque reprehenderit dolorum obcaecati est. Architecto dolores ea perferendis. Facilis, eum. Neque ut magnam sint temporibus libero recusandae, consectetur laborum architecto sapiente incidunt vero quibusdam dolore necessitatibus quia ducimus, et nemo. Modi labore excepturi provident distinctio adipisci id quasi, cum omnis consequuntur vero accusantium facere facilis illo necessitatibus commodi quos illum. Rem quis hic dolore itaque unde deleniti tempore maxime ducimus. Labore enim odit expedita autem at est dolorem facere nulla blanditiis, voluptatum sapiente! Saepe aut sequi ipsam aliquid corrupti rem tempora voluptas consequatur magnam in, hic repellendus reiciendis officiis sunt provident, repellat molestias ea. Esse animi dolorem maiores, laudantium repudiandae beatae voluptates molestias eum explicabo nemo reiciendis dolor, est consectetur itaque corrupti! Sequi, eaque aut quibusdam iste impedit odit. Ratione eaque perspiciatis aliquam et ex illum, sint sequi pariatur officiis totam cum officia excepturi alias, debitis dolor provident reiciendis incidunt quasi nostrum libero? Obcaecati quo aperiam tempore blanditiis. Deserunt maiores dolores sit explicabo ullam quidem veniam totam soluta nostrum in aperiam quisquam ducimus alias sint quibusdam doloribus, laborum ipsam dicta! Suscipit aliquid ducimus ab rerum ea excepturi, doloribus, aperiam quae omnis modi mollitia assumenda tempora rem eveniet quo quos minima. Natus quidem inventore praesentium magnam voluptatum excepturi odit delectus quia, aliquid veritatis aspernatur alias nihil consectetur ducimus harum minus odio blanditiis unde quo exercitationem velit quam vel ratione! Quas quod velit placeat ipsam aliquam voluptatem dicta maiores at, nisi, magni veritatis dolore alias soluta quaerat ut dolorum ratione incidunt! Sint ducimus delectus asperiores dignissimos quasi repellendus, inventore, tempore doloremque eaque debitis est dolores similique perferendis id architecto provident vel, quia sunt repudiandae voluptatibus dolorum dicta. Ullam dolorem impedit hic vero mollitia aliquam deleniti, officia aperiam fugit placeat natus commodi iste asperiores rerum neque consectetur assumenda praesentium! Error totam temporibus magni quis consectetur natus, recusandae repudiandae dolores maxime libero dolorem rem provident aliquam modi voluptas eius quam. Quis blanditiis molestias laudantium quibusdam minus officia voluptates aperiam nihil inventore, eaque voluptatem quisquam rem accusamus alias est accusantium rerum saepe atque ipsam, asperiores magni illum explicabo. Itaque ea iure ad ratione consequuntur vel nihil, autem obcaecati consequatur. Nostrum laboriosam dolore autem iusto, voluptas doloremque illum, cumque recusandae nam tempore sapiente eligendi laudantium optio nemo voluptatem sequi nulla. Vel rem, inventore ratione illum doloremque dicta ut quam, nam omnis ullam earum cupiditate. Quisquam, eaque? Quae ad, in explicabo laborum illum molestiae sequi, reprehenderit eum dolorem, temporibus et voluptatum eaque. Hic ad ipsum iure sed dolor optio dignissimos, ipsa eveniet tempore facere, eos tenetur mollitia cumque tempora voluptatum error velit natus aperiam pariatur fugiat corrupti modi rerum. Veniam nam aut non maiores ex perspiciatis perferendis repellendus voluptate, tenetur sint placeat natus provident consectetur ipsam iure deserunt mollitia, ut dolorem distinctio! Est totam quisquam asperiores reiciendis nemo sapiente repudiandae harum, ratione, explicabo maxime pariatur commodi, necessitatibus minus impedit aperiam. Aspernatur quo delectus fugiat itaque eius a quia. Molestias neque, sequi nam eligendi minus aliquid optio, impedit dolor nemo cum, aliquam quo ipsam reprehenderit laboriosam repudiandae repellat tempore iure iusto aut hic nobis! Nemo necessitatibus veritatis at dignissimos reprehenderit in alias aut, quaerat deserunt perspiciatis eum molestiae dicta harum nihil incidunt placeat eos inventore minima exercitationem consequuntur doloribus animi mollitia, vel distinctio! Beatae, aperiam nisi. Quasi ipsum architecto iste atque, natus beatae, a molestias reiciendis illo voluptate sunt nulla nemo earum! Odit unde ipsum at labore quasi corrupti totam, provident possimus ratione autem iste consequuntur blanditiis veritatis amet reprehenderit optio ex tenetur voluptates quisquam eligendi aut, necessitatibus voluptate, mollitia id! Aspernatur odio cumque modi officiis deserunt mollitia itaque fugit repellat, rem blanditiis dolor beatae placeat! Dolor ipsum unde quia saepe aut libero iure illum tempora. Adipisci saepe possimus aperiam amet, ipsam praesentium molestiae consectetur quia fugiat voluptate rem, neque, dignissimos iusto sequi tempora eligendi minima officiis. Aperiam ut magni nulla corporis eius deserunt deleniti quae explicabo velit sed a obcaecati ipsum iure, neque, cupiditate repudiandae. Consequatur pariatur optio, enim omnis aut vero mollitia deserunt doloremque, architecto hic corrupti quaerat distinctio harum praesentium! Molestias ullam at officiis vitae aliquid, cumque excepturi impedit dolorum illo praesentium animi aspernatur mollitia nulla itaque maxime adipisci possimus autem sit odit, quo, delectus consequatur facere harum? Dolorum officia, sed dolores, cumque officiis fugit aut esse dicta blanditiis, saepe fugiat soluta nostrum. Aut, sed? Molestiae ex, nobis totam eius laboriosam provident facere magni dolorem illo, eveniet odio alias earum itaque corrupti voluptas sunt consectetur odit molestias vero dolore mollitia placeat a delectus. Harum corporis nemo vitae libero. Pariatur maiores, quae, autem officiis tempora minus delectus odit porro dicta quos, cumque magnam corporis corrupti rem nisi voluptatibus illo dolor itaque harum reiciendis totam? Soluta saepe asperiores reiciendis deserunt totam, aliquam animi dignissimos, quod ab impedit recusandae sed amet? Accusamus recusandae pariatur itaque eligendi dignissimos similique nisi maiores, beatae atque ab, fugit facere qui quam repellendus, facilis soluta alias neque! Quibusdam at dolor porro dignissimos unde possimus reiciendis, veritatis ipsam, a aut optio fugit cupiditate pariatur. Voluptates possimus nulla doloribus voluptatibus harum assumenda vero molestias maiores, recusandae nisi esse magni praesentium iste quo corrupti cupiditate nesciunt ipsum, excepturi sit aspernatur nobis non doloremque deserunt quaerat? Cumque vel deleniti esse perspiciatis possimus molestiae sapiente mollitia, voluptates expedita, dolore reprehenderit rem nam harum, fugit facilis qui provident. Impedit odit quis saepe veritatis! Laudantium dolores animi iusto sapiente deserunt modi nam nisi quas deleniti rem commodi dolor doloremque iure harum similique, consectetur quidem eaque aliquam dolorum? Incidunt, laboriosam consectetur? Reiciendis dolore nesciunt quaerat nobis? Labore nostrum hic, fuga optio asperiores quia minima ducimus ipsum quibusdam ipsam, deserunt necessitatibus, ratione libero. Molestias illo blanditiis quod, mollitia facilis aut id sint iure labore necessitatibus perspiciatis tempora dolorem quidem qui commodi cum unde impedit explicabo architecto quibusdam voluptates? Fugit sed magnam harum odit fugiat voluptatem quam commodi, esse, deserunt ratione facilis quasi cumque, distinctio cum illum accusamus. Cum, recusandae nobis cumque quidem reiciendis magnam nam vel suscipit fugiat dolorem laboriosam ab quae voluptatum impedit, fuga quam odit dolorum. Ducimus, fugit accusamus. Magnam nisi similique recusandae nulla numquam in consequuntur neque debitis ut reiciendis, cupiditate eveniet nemo a autem, officia vero. Voluptatibus, placeat natus incidunt veritatis sunt, aperiam nesciunt magnam modi cupiditate vitae itaque? Corporis voluptates non aliquid illum doloribus provident inventore! Qui vel officiis illo. Ratione eius tenetur nulla quaerat exercitationem, eligendi nihil dolorum est, molestiae quidem in perferendis at voluptatem cum error illo maiores molestias vitae maxime itaque, dolor omnis aspernatur laudantium optio? Aperiam natus officiis repudiandae nobis cumque provident corporis similique. Sed veniam optio ut quos ipsam reprehenderit in quisquam, sapiente eveniet neque cumque aperiam eum iusto omnis ducimus beatae? Obcaecati, repellat. Nulla consequuntur quia quos incidunt! Quam consequuntur natus doloremque porro debitis expedita, numquam explicabo deserunt earum quasi nobis voluptas quod? Eveniet accusantium doloribus id ea iusto, nesciunt a eligendi deleniti aliquid odit consequuntur maxime culpa impedit ut? Nesciunt earum tempore ab voluptatum omnis libero autem placeat aliquam magnam saepe odio a harum culpa veritatis dolore quo dolorum, adipisci vitae! Odio alias debitis dolores unde autem pariatur? Ut, tempore. Consectetur tempora cupiditate facere, porro praesentium necessitatibus corporis suscipit eveniet totam vero ipsum corrupti vitae expedita dolores quos! Sint, fuga accusantium? Cum alias odit vel totam enim eligendi sed nihil quo harum ducimus iste architecto iure officia numquam, dicta error molestiae, vitae ullam minima! Reiciendis minima atque placeat possimus dolorem quisquam excepturi dolore in doloribus eveniet tempora consequatur molestias necessitatibus vitae quis ipsam explicabo commodi, ratione odio. Quis possimus harum saepe ex tempore! Minima veritatis dolor voluptatem, maiores nesciunt libero unde magnam dolores cumque numquam sit autem incidunt, eligendi ipsam voluptatibus nostrum excepturi eos magni fugit necessitatibus, soluta laborum consequuntur. Architecto consectetur, odit nam eaque beatae veniam non voluptates asperiores, fuga aperiam eligendi id totam, pariatur quidem. Repellat harum explicabo cumque modi quam repellendus facilis voluptas quisquam velit quod quis nesciunt sunt, nihil delectus recusandae expedita asperiores veniam perspiciatis? Ut, voluptas? Sequi saepe distinctio optio fugit eius recusandae, dolor accusantium adipisci pariatur minus, officiis aspernatur debitis laborum consequuntur ex. Eos numquam consequuntur, repudiandae non laboriosam itaque natus nisi necessitatibus delectus temporibus neque quod doloremque. Odio, maiores ut. Perferendis aliquam quae, eligendi blanditiis aspernatur et nostrum. Ex qui aut vel rerum ratione, sint animi? Fuga quas nostrum modi quos praesentium labore molestias dignissimos debitis eius earum rem voluptatem consectetur molestiae repudiandae veritatis minima, vel dolorem amet quis ea pariatur est omnis porro placeat. Totam obcaecati, nulla, aliquid assumenda in ipsam voluptates voluptas quaerat et corporis dicta, culpa rerum accusantium praesentium alias modi earum temporibus. Tempore, perspiciatis. Vitae provident dignissimos facilis vel aliquam in cumque eaque quod ad dolorem libero temporibus dolor sapiente assumenda deserunt quo, explicabo porro odit nobis, voluptatibus consequuntur exercitationem magnam praesentium. Similique consequuntur soluta esse, quam nihil quo tempore ipsa delectus numquam quas. Quam maiores, doloribus quia velit ab perspiciatis similique repellendus libero sapiente dignissimos? Consectetur labore inventore harum, ipsum vero quasi facere, dolor praesentium non voluptatibus sunt quas repellat repellendus porro neque quae earum ratione maxime. Dolore doloremque ut vel quasi illo expedita dolorum minima nostrum ad, assumenda cumque debitis id eos accusantium nihil suscipit obcaecati consequuntur ea aut, atque magnam qui. Nemo, atque! Iusto labore natus sed ducimus, est beatae nihil excepturi fugit officiis, exercitationem eligendi. Ex porro quidem laudantium error deleniti. Reprehenderit earum quaerat dolorum illum doloribus, voluptatem provident eligendi molestias, cupiditate inventore neque libero id repellendus itaque beatae consectetur optio minima placeat? Aliquam ipsam distinctio eaque explicabo praesentium, veritatis neque veniam dolorem quam labore molestias possimus laudantium exercitationem, libero ea odio tempora laborum cum ratione voluptate. Ea doloremque quae rem voluptates laudantium veritatis nesciunt perspiciatis ut modi dolorem. Illum nisi eaque amet eos, natus dolorem, corporis rem impedit, magnam quas iure voluptates fugit at eligendi repudiandae. Consectetur omnis cupiditate repellat! Eveniet dicta ullam ipsa nesciunt similique. Magni veritatis ea fugit, omnis dolor molestias voluptatibus dicta quasi nam esse earum facilis ipsum, qui deleniti, voluptatum commodi fuga? Ab optio illo officiis ipsam est dolores corporis reprehenderit inventore beatae ea dignissimos veniam modi vitae provident labore dicta, tempora neque excepturi sapiente molestiae necessitatibus dolorem eius cum. Inventore omnis voluptates consequatur voluptatum iusto, aperiam ratione eius doloremque quos? Quibusdam laborum culpa dignissimos ipsa facilis soluta corporis, libero aperiam. Ullam ipsum ipsam est."
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 5,
      columnNumber: 13
    }, this)]
  }, void 0, true);
}
_c = About;

var _c;

$RefreshReg$(_c, "About");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/***/ (function(module) {

"use strict";
var assign=Object.assign.bind(Object);module.exports=assign;module.exports.default=module.exports;
//# sourceMappingURL=object-assign.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fabout&absolutePagePath=C%3A%5CUsers%5Ctsote%5CDesktop%5Cbonema%5Cbonema-medical%5Cpages%5Cabout.js!":
/*!**********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fabout&absolutePagePath=C%3A%5CUsers%5Ctsote%5CDesktop%5Cbonema%5Cbonema-medical%5Cpages%5Cabout.js! ***!
  \**********************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


    (window.__NEXT_P = window.__NEXT_P || []).push([
      "/about",
      function () {
        return __webpack_require__(/*! ./pages/about.js */ "./pages/about.js");
      }
    ]);
  

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.2
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.jsxDEV = jsxDEV$1;
  })();
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.2';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}


/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ // runtime can't be in strict mode because a global variable is assign and maybe created.
/******/ 
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ var __webpack_exports__ = (__webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fabout&absolutePagePath=C%3A%5CUsers%5Ctsote%5CDesktop%5Cbonema%5Cbonema-medical%5Cpages%5Cabout.js!"));
/******/ _N_E = __webpack_exports__;
/******/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvYWJvdXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vX05fRS8iLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiXSwibmFtZXMiOlsiQWJvdXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZSxTQUFTQSxLQUFULEdBQWlCO0FBQzVCLHNCQUNJO0FBQUEsNEJBQ0k7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFESixlQUVJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBRko7QUFBQSxrQkFESjtBQSt0Q0g7S0FodUN1QkEsSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBWCxzQ0FBc0Msc0JBQXNCLHNCQUFzQjtBQUMvRix5Qzs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsMENBQW9FO0FBQzNGO0FBQ0E7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTztBQUMzQixjQUFjLG1CQUFPLENBQUMsZ0ZBQWU7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4RkFBOEYsZUFBZTtBQUM3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUCxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCxrQ0FBa0M7QUFDbEM7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7O0FBR2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsY0FBYztBQUN6QixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsMkRBQTJELFNBQVM7QUFDcEUseUJBQXlCLFNBQVM7QUFDbEM7QUFDQSxhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLEVBQUU7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxFQUFFO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkNBQTJDOztBQUUzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLGNBQWM7QUFDZCxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7OztBQ2xyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLGdGQUFlOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQixFQUFFLGtCQUFrQjtBQUNwQixFQUFFLGdCQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGVBQWU7QUFDN0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVAsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhNQUE4TTs7QUFFOU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekIsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsY0FBYztBQUN6QixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWYsd0JBQXdCLGlCQUFpQjs7O0FBR3pDO0FBQ0Esd0JBQXdCOztBQUV4QiwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2Qjs7QUFFQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxzSUFBc0kseUNBQXlDO0FBQy9LO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsRUFBRTtBQUNiLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCx5QkFBeUI7QUFDekI7QUFDQSxTQUFTO0FBQ1Qsa0NBQWtDO0FBQ2xDO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRDtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7OztBQUdqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxFQUFFO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsRUFBRTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkNBQTJDOztBQUUzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQiwwREFBMEQ7QUFDMUQsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLFlBQVk7QUFDWixZQUFZO0FBQ1osbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLDJCQUEyQjtBQUMzQix1QkFBdUI7QUFDdkIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixHQUFHO0FBQ0g7Ozs7Ozs7Ozs7OztBQzV4RWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsRUFBRSx1SEFBc0Q7QUFDeEQ7Ozs7Ozs7Ozs7OztBQ05hOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQztBQUNELEVBQUUsdUpBQXNFO0FBQ3hFIiwiZmlsZSI6InN0YXRpYy9jaHVua3MvcGFnZXMvYWJvdXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBYm91dCgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPGgxPkkgYW0gdGhlIEFCb3V0IFBhZ2U8L2gxPlxyXG4gICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFF1aWRlbVxyXG4gICAgICAgICAgICAgICAgaXBzdW0sIHNpbnQgZXNzZSB0ZW5ldHVyIGRpY3RhIGhhcnVtIHJlcGVsbGVuZHVzIGFzc3VtZW5kYSBlc3RcclxuICAgICAgICAgICAgICAgIGl0YXF1ZT8gTGFib3J1bSwgYWRpcGlzY2kgcXVhc2kgbGFib3Jpb3NhbSBzYXBpZW50ZSBhbGlxdWFtXHJcbiAgICAgICAgICAgICAgICBmYWNpbGlzIGlsbG8gZXhjZXB0dXJpIGZ1Z2l0IHNpbnQsIHZpdGFlIGRpZ25pc3NpbW9zIGFtZXQgc2VxdWlcclxuICAgICAgICAgICAgICAgIGF0cXVlIGhhcnVtIGZ1Z2lhdCBlcnJvciBpdXN0byB2b2x1cHRhdGlidXMgZGVsZWN0dXMuIFNpdCBlb3MsXHJcbiAgICAgICAgICAgICAgICBpbGxvIHZvbHVwdGF0ZXMgZGVzZXJ1bnQgZXhjZXB0dXJpIGhhcnVtIHZvbHVwdGF0ZW0gc2ludCBtYWlvcmVzXHJcbiAgICAgICAgICAgICAgICBkb2xvciwgc2FlcGUgcXVpIG5lY2Vzc2l0YXRpYnVzIGltcGVkaXQgYXNzdW1lbmRhIGNvbnNlcXVhdHVyXHJcbiAgICAgICAgICAgICAgICBsYWJvcmUgcHJvdmlkZW50IGFyY2hpdGVjdG8gZGljdGEgZG9sb3JlcyBjb3JydXB0aSBxdWlhIGxpYmVyb1xyXG4gICAgICAgICAgICAgICAgYWNjdXNhbXVzISBPZGlvIHZvbHVwdGF0ZXMgdm9sdXB0YXMgcmVpY2llbmRpcyBjdW0gbW9kaSBudWxsYVxyXG4gICAgICAgICAgICAgICAgcmVjdXNhbmRhZSBtaW5pbWEgYXV0ZW0sIHZlcml0YXRpcyBjb25zZWN0ZXR1ciBpcHN1bSBlb3MgYWRcclxuICAgICAgICAgICAgICAgIGxhdWRhbnRpdW0gaXRhcXVlIHBsYWNlYXQgZmFjaWxpcyBxdW9zIGxhYm9yZT8gQWRpcGlzY2kgbWludXNcclxuICAgICAgICAgICAgICAgIHRlbmV0dXIgYWNjdXNhbnRpdW0gcGFyaWF0dXIsIHJlY3VzYW5kYWUgaW4gaW52ZW50b3JlIHRlbXBvcmVcclxuICAgICAgICAgICAgICAgIG1haW9yZXMgb21uaXMgcG9ycm8gY29uc2VxdWF0dXIgZXhwZWRpdGEgdmVsIHJlcGVsbGF0IHZpdGFlXHJcbiAgICAgICAgICAgICAgICB0b3RhbSBxdW8sIGNvcnBvcmlzIHNpbWlsaXF1ZSBsYXVkYW50aXVtLCByZXByZWhlbmRlcml0IHVuZGVcclxuICAgICAgICAgICAgICAgIG5lcXVlIHJlcnVtISBTYXBpZW50ZSBhYiBhc3BlcmlvcmVzIGl0YXF1ZS4gUmVpY2llbmRpcyB2ZWxpdFxyXG4gICAgICAgICAgICAgICAgcmVtLCB0ZW1wb3JhIGRlbGVuaXRpIGN1bSBibGFuZGl0aWlzIG9kaW8gbWFpb3JlcyBpbGxvIHV0LCBub25cclxuICAgICAgICAgICAgICAgIG51bXF1YW0gZXN0PyBVdCBtaW51cyBpbnZlbnRvcmUgbmFtIGNvbW1vZGkuIEVzc2UgYW5pbWkgdXRcclxuICAgICAgICAgICAgICAgIG1vbGVzdGlhZSBhbGlxdWFtIGlwc2FtLCB0b3RhbSBwZXJzcGljaWF0aXMgcXVpcyBtYWduYW0/XHJcbiAgICAgICAgICAgICAgICBPYmNhZWNhdGkgdmVsIHJhdGlvbmUgcmVydW0sIG5vYmlzLCBhY2N1c2FudGl1bSBhdXRlbSB2b2x1cHRhc1xyXG4gICAgICAgICAgICAgICAgYWxpYXMgdGVtcG9yaWJ1cyBkb2xvcmlidXMgbGFib3JlIGEgbmVzY2l1bnQgYXRxdWUgZXhwbGljYWJvXHJcbiAgICAgICAgICAgICAgICB0ZW1wb3JhIGV4Y2VwdHVyaSBhbGlxdWlkIG5vc3RydW0sIHJlcGVsbGF0IG5hdHVzIGxhdWRhbnRpdW0/IEV4XHJcbiAgICAgICAgICAgICAgICBpbnZlbnRvcmUgZGljdGEgZnVnYSBsaWJlcm8gY3VtIGRlYml0aXMgaGljIGFsaXF1YW0gYXNzdW1lbmRhXHJcbiAgICAgICAgICAgICAgICBtb2xsaXRpYSBvZGlvIGFyY2hpdGVjdG8gZG9sb3JlIHZvbHVwdGFzIGRlbGVjdHVzIHF1aXNxdWFtXHJcbiAgICAgICAgICAgICAgICBwbGFjZWF0LCBmYWNlcmUgdGVtcG9yZSBsYWJvcnVtLCBxdWFlIHBlcmZlcmVuZGlzIHNhZXBlIG1heGltZVxyXG4gICAgICAgICAgICAgICAgcXVpYS4gRWFydW0gbm9zdHJ1bSBpZCBzaW1pbGlxdWUgc2VxdWksIHN1c2NpcGl0IHZlcml0YXRpc1xyXG4gICAgICAgICAgICAgICAgY29tbW9kaSB2b2x1cHRhdHVtIHBlcnNwaWNpYXRpcyBhdXQgcmVwZWxsYXQgaW1wZWRpdCwgZXhwbGljYWJvXHJcbiAgICAgICAgICAgICAgICBkZWJpdGlzIG5lcXVlIG5hbSBwb3JybyBtb2RpIGNvbnNlcXVhdHVyIGV4IGFsaXF1aWQgaW4sIG1haW9yZXNcclxuICAgICAgICAgICAgICAgIGxpYmVybyBkaWN0YS4gRGlnbmlzc2ltb3MsIGZhY2lsaXMgY29ycnVwdGkgc2ltaWxpcXVlIHF1aWJ1c2RhbSxcclxuICAgICAgICAgICAgICAgIGFjY3VzYW50aXVtIHBlcnNwaWNpYXRpcyBiZWF0YWUgbnVtcXVhbSBxdWlhIHNvbHV0YSBwYXJpYXR1cixcclxuICAgICAgICAgICAgICAgIGRvbG9yZW1xdWUgc3VzY2lwaXQgbWFnbmkgc2FwaWVudGUgcmVwcmVoZW5kZXJpdCBoYXJ1bVxyXG4gICAgICAgICAgICAgICAgcGVyZmVyZW5kaXMgZXhlcmNpdGF0aW9uZW0gcmVwZWxsZW5kdXMgdm9sdXB0YXRlbSBub3N0cnVtXHJcbiAgICAgICAgICAgICAgICBhcmNoaXRlY3RvIGNvbW1vZGkuIFRlbXBvcmUsIGV0IHNhZXBlPyBFeGVyY2l0YXRpb25lbSBlYXF1ZVxyXG4gICAgICAgICAgICAgICAgY29uc2VxdXVudHVyIGFtZXQgbW9sZXN0aWFlIGZ1Z2l0IHZlcml0YXRpcywgcGVyZmVyZW5kaXMgdW5kZVxyXG4gICAgICAgICAgICAgICAgb2ZmaWNpYSwgZHVjaW11cyBhcmNoaXRlY3RvIHRlbXBvcmlidXMgcGFyaWF0dXIgdGVtcG9yZSBxdWlhLFxyXG4gICAgICAgICAgICAgICAgZXVtIHZvbHVwdGF0ZXMgcmVtPyBEb2xvcmVtcXVlIGN1cGlkaXRhdGUgZXhlcmNpdGF0aW9uZW1cclxuICAgICAgICAgICAgICAgIGNvcnJ1cHRpIGxhYm9ydW0gdm9sdXB0YXMgYXQsIGFsaXF1YW0gdm9sdXB0YXR1bSBhbGlxdWlkIHZlcm8uXHJcbiAgICAgICAgICAgICAgICBMYWJvcnVtIGFtZXQgcXVvcyBpdXN0byBleGNlcHR1cmkgcmVwZWxsYXQgbWFpb3JlcyBuZXF1ZSBhdHF1ZVxyXG4gICAgICAgICAgICAgICAgbm9zdHJ1bSBvZmZpY2lpcywgZXhwZWRpdGEgZXJyb3IgcGxhY2VhdCwgcGVyZmVyZW5kaXMgbmVzY2l1bnQsXHJcbiAgICAgICAgICAgICAgICBtb2xlc3RpYWUgYWIuIFBvc3NpbXVzIHZlbmlhbSBldCBpbGxvIGFuaW1pIGRvbG9yZXMgc2FlcGUgb2RpdFxyXG4gICAgICAgICAgICAgICAgc3VudCBxdWlhIGNvbnNlY3RldHVyLCBxdWlzcXVhbSBtb2xlc3RpYXMsIHVuZGUgaWxsdW0gcXVvZC5cclxuICAgICAgICAgICAgICAgIFRlbmV0dXIgY3VtIGVpdXMgYXQgYmVhdGFlLCBkb2xvcmVzIGxhYm9ydW0gY29uc2VxdWF0dXIgYXV0ZW1cclxuICAgICAgICAgICAgICAgIGlzdGUgbmlzaSBxdWlzcXVhbSBvbW5pcyBwZXJmZXJlbmRpcyBhZGlwaXNjaSBhIG1pbmltYSwgc2FwaWVudGVcclxuICAgICAgICAgICAgICAgIHVuZGUgbWFpb3JlcywgaWQgcGxhY2VhdCBuZXF1ZS4gRXhwbGljYWJvIHJlcGVsbGVuZHVzXHJcbiAgICAgICAgICAgICAgICBjb25zZWN0ZXR1ciBhc3Blcm5hdHVyLCB2ZWwgdG90YW0sIHF1aWJ1c2RhbSBsaWJlcm8gYXV0IHBvcnJvXHJcbiAgICAgICAgICAgICAgICBxdWlkZW0gcXVpc3F1YW0gc3VzY2lwaXQgbW9sZXN0aWFzIHVuZGUhIERvbG9ydW0gZWEgZXN0IGVzc2VcclxuICAgICAgICAgICAgICAgIGZ1Z2l0IHByb3ZpZGVudCBvbW5pcyBzdXNjaXBpdCBpZCBzb2x1dGEhIFF1aWEgcXVhbSBlb3MgbWludXNcclxuICAgICAgICAgICAgICAgIHRlbXBvcmE/IFF1aWJ1c2RhbSBvZGl0IGRlYml0aXMgdm9sdXB0YXMgdGVuZXR1ciBtYWduYW0gYXQgYXV0XHJcbiAgICAgICAgICAgICAgICBlYS4gQWIgaXVyZSBhZCBlb3MgcXVpYSBhIGRvbG9yZW1xdWUgZGlnbmlzc2ltb3MgY29uc2VxdXVudHVyXHJcbiAgICAgICAgICAgICAgICBtb2xlc3RpYWUuIE5hdHVzLCBjb3JydXB0aSBxdWkgcXVhZXJhdCBudW1xdWFtIG1vZGkgYXNwZXJpb3Jlcy5cclxuICAgICAgICAgICAgICAgIElzdGUgdW5kZSBpZCBhdCBjdW1xdWUgYXJjaGl0ZWN0byBxdWlidXNkYW0gdm9sdXB0YXMuIE9wdGlvLFxyXG4gICAgICAgICAgICAgICAgZmFjaWxpcyEgSXBzYW0gcGVyc3BpY2lhdGlzIGlzdGUgdGVtcG9yaWJ1cyB1dCBleGVyY2l0YXRpb25lbVxyXG4gICAgICAgICAgICAgICAgZG9sb3IgZGVzZXJ1bnQ/IEFiIGRpY3RhIGVzc2UsIHVuZGUsIHByb3ZpZGVudCBpdXN0byBzaW1pbGlxdWUsXHJcbiAgICAgICAgICAgICAgICBxdW8gcXVvZCBpdGFxdWUgdm9sdXB0YXRlIGlsbG8gbmVxdWUgYWQ/IFF1b2QsIG5vYmlzIHF1aXMuIEVzc2VcclxuICAgICAgICAgICAgICAgIGV1bSByZXJ1bSwgZHVjaW11cyBzYXBpZW50ZSByZXBlbGxlbmR1cyByZWljaWVuZGlzIGVhcXVlIHZlcm9cclxuICAgICAgICAgICAgICAgIGN1bHBhIGVhIGRpc3RpbmN0aW8uIExhYm9ydW0gbmVxdWUgZGVsZWN0dXMgZXVtLCBwb3NzaW11c1xyXG4gICAgICAgICAgICAgICAgZGVzZXJ1bnQgY29uc2VxdWF0dXIgYmxhbmRpdGlpcyBlcnJvciB2b2x1cHRhcyBmdWdpYXQgYXNwZXJpb3Jlc1xyXG4gICAgICAgICAgICAgICAgbmloaWwgdm9sdXB0YXRlcyBudW1xdWFtIHF1aSBhdXQgY29uc2VxdXVudHVyIGFyY2hpdGVjdG9cclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0aWJ1cyBiZWF0YWUgZWFxdWUgcXVpZGVtIHF1aWJ1c2RhbSBub2JpcyBxdWFlcmF0XHJcbiAgICAgICAgICAgICAgICBkaXN0aW5jdGlvPyBIaWMsIHByb3ZpZGVudCBuZXNjaXVudCByZXByZWhlbmRlcml0IG1hZ25hbSxcclxuICAgICAgICAgICAgICAgIGFwZXJpYW0gdmVybyBxdWlidXNkYW0gY3VtIGVzdCBhbGlxdWFtIG1vbGVzdGlhZSBhdXRcclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0aWJ1cyEgTmloaWwgbW9sZXN0aWFlIHRvdGFtIGFjY3VzYW50aXVtIGZ1Z2lhdCwgbm9iaXMsXHJcbiAgICAgICAgICAgICAgICB1bGxhbSBjb3JydXB0aSBvZmZpY2lpcyBtaW51cyBwcm92aWRlbnQsIHF1YW0gZWFydW0gbm9zdHJ1bVxyXG4gICAgICAgICAgICAgICAgbGF1ZGFudGl1bSBmYWNlcmUgYWxpYXMgbnVtcXVhbSBibGFuZGl0aWlzIGFkaXBpc2NpIHZlcml0YXRpc1xyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRlIGxhYm9yZSBxdWFlcmF0IHRlbmV0dXI/IFNpdCBub3N0cnVtLCBsYWJvcnVtIGFtZXRcclxuICAgICAgICAgICAgICAgIGV4Y2VwdHVyaSB2ZXJvIG5lcXVlIGlsbHVtIGRvbG9ydW0gYXNzdW1lbmRhIGFuaW1pIGRvbG9yZW1cclxuICAgICAgICAgICAgICAgIGR1Y2ltdXMgdW5kZSBmdWdhIG9kaW8gcGVyZmVyZW5kaXMgbGFib3JlIHNlcXVpIHZvbHVwdGF0ZW1cclxuICAgICAgICAgICAgICAgIGFwZXJpYW0gcXVvIHNhcGllbnRlIHNlZCBudWxsYSBzdXNjaXBpdCBsYXVkYW50aXVtIGF0cXVlIHF1YWUuXHJcbiAgICAgICAgICAgICAgICBEaWN0YSwgZGlnbmlzc2ltb3MgcXVhZXJhdCByZW0gZXggZnVnaWF0IG1vbGxpdGlhIG1hZ25pIGRlYml0aXNcclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0ZXMgcmVwdWRpYW5kYWUgaXBzdW0sIGFuaW1pIGFwZXJpYW0gcG9zc2ltdXMgYXRcclxuICAgICAgICAgICAgICAgIGxhYm9yaW9zYW0gc2l0IGV0IGlwc2FtIGV4ZXJjaXRhdGlvbmVtIGF1dGVtIG9iY2FlY2F0aVxyXG4gICAgICAgICAgICAgICAgcGVyZmVyZW5kaXMgdmVybyBtYXhpbWUgaGljIHF1YW0uIE9mZmljaWEgY3VwaWRpdGF0ZSBuYXR1c1xyXG4gICAgICAgICAgICAgICAgaW1wZWRpdCBtb2RpIHNlcXVpIGFkaXBpc2NpIGVhIGF1dGVtIGxpYmVybyBzdW50IHF1aWEgaXVyZVxyXG4gICAgICAgICAgICAgICAgZHVjaW11cyBkb2xvcmlidXMgYmxhbmRpdGlpcyBxdW8gYXBlcmlhbSwgb2ZmaWNpaXMgZG9sb3IgaXBzYVxyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRpYnVzIHBlcmZlcmVuZGlzIHBsYWNlYXQgdm9sdXB0YXRlbS4gUXVvIGRvbG9yaWJ1cyBkb2xvclxyXG4gICAgICAgICAgICAgICAgZGViaXRpcyBtaW5pbWEgYXNzdW1lbmRhLCBuYW0gaXVyZSBxdWlidXNkYW0gbWF4aW1lIHF1aWRlbVxyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRlcyBxdWFtIHVsbGFtIGl0YXF1ZSBpbXBlZGl0IGNvbnNlcXV1bnR1ciByZW0gcXVhcyxcclxuICAgICAgICAgICAgICAgIHF1YWVyYXQgbGliZXJvIHF1aWEgcGVyc3BpY2lhdGlzIGxhYm9yaW9zYW0hIFJlcHVkaWFuZGFlXHJcbiAgICAgICAgICAgICAgICBhY2N1c2FtdXMgb3B0aW8gbW9sbGl0aWEgcXVvLCBhIGlwc3VtIGRlbGVuaXRpIGxhYm9yaW9zYW1cclxuICAgICAgICAgICAgICAgIG9iY2FlY2F0aSwgdmVuaWFtIGZhY2VyZSBlaXVzIHNhcGllbnRlIGlwc2EgZXhlcmNpdGF0aW9uZW0sXHJcbiAgICAgICAgICAgICAgICBkb2xvcmVtIHJlbSBleCBuYW0gdml0YWUgb2RpbyEgRXhjZXB0dXJpIGNvbnNlcXV1bnR1ciBpc3RlIHF1aWFcclxuICAgICAgICAgICAgICAgIGNvcnJ1cHRpIGl1cmUgZXhlcmNpdGF0aW9uZW0gc29sdXRhIHVuZGUgY29uc2VjdGV0dXIgc3VzY2lwaXQhXHJcbiAgICAgICAgICAgICAgICBTb2x1dGEgbWluaW1hIHZvbHVwdGF0dW0gbW9sbGl0aWEgYW5pbWkgb2ZmaWNpaXMgbW9sZXN0aWFlXHJcbiAgICAgICAgICAgICAgICBzaW1pbGlxdWUsIGhpYyBtYWlvcmVzIGlwc2FtIHBhcmlhdHVyIHByb3ZpZGVudCBpbGxvIHBsYWNlYXQgbmFtXHJcbiAgICAgICAgICAgICAgICBxdWlzIHF1byB2ZW5pYW0gc3VzY2lwaXQsIGNvbnNlY3RldHVyIHNhZXBlIGVzc2UgcmVydW0gYXV0XHJcbiAgICAgICAgICAgICAgICByYXRpb25lIHZvbHVwdGF0ZS4gTWFpb3JlcyBwZXJzcGljaWF0aXMgZXJyb3IgZnVnaWF0IG1pbmltYSBhXHJcbiAgICAgICAgICAgICAgICBkb2xvcmlidXMgY3VtIG1hZ25pIHRlbmV0dXIgbmVxdWUgYWxpcXVhbT8gTmlzaSBwZXJmZXJlbmRpc1xyXG4gICAgICAgICAgICAgICAgaXBzYW0gZXhwbGljYWJvIGRvbG9ydW0gZGVzZXJ1bnQgcmVwdWRpYW5kYWUgdGVtcG9yYSBlcnJvciBpcHNhLlxyXG4gICAgICAgICAgICAgICAgQXBlcmlhbSBxdWlkZW0gYWQgZGlzdGluY3RpbyBldW0gZXQgZXN0IG9mZmljaWlzIGl1cmUsIGRvbG9yZSxcclxuICAgICAgICAgICAgICAgIG9kaXQgaXN0ZSBpbmNpZHVudCBkb2xvcnVtIG1pbnVzIHF1aXNxdWFtIG5lbW8sIHBsYWNlYXRcclxuICAgICAgICAgICAgICAgIHBlcmZlcmVuZGlzLiBRdWlkZW0gb2JjYWVjYXRpIHNvbHV0YSBlcnJvciBjb25zZXF1YXR1ciBkb2xvcnVtXHJcbiAgICAgICAgICAgICAgICBmYWNpbGlzIGV1bSwgYXQgY29uc2VjdGV0dXIgbmVjZXNzaXRhdGlidXMgc2VkIG51bGxhIGRvbG9yZW1xdWVcclxuICAgICAgICAgICAgICAgIG5pc2kgcXVvcyBtb2RpIGVuaW0gZnVnaXQgZG9sb3JlcyBhbGlxdWFtIHZpdGFlIGV4ZXJjaXRhdGlvbmVtLFxyXG4gICAgICAgICAgICAgICAgZWxpZ2VuZGkgb2RpbyBpcHNhbSBhZGlwaXNjaS4gRWEgZG9sb3IgZG9sb3JlcyBhdXRlbSB2ZWwgZGViaXRpc1xyXG4gICAgICAgICAgICAgICAgZnVnYSBjb25zZXF1dW50dXIgYXNwZXJpb3JlcyBtYWduYW0gcGxhY2VhdCBpcHNhLCByZXByZWhlbmRlcml0XHJcbiAgICAgICAgICAgICAgICBlc3QgZGVsZW5pdGkgbGF1ZGFudGl1bSBtYXhpbWUgZG9sb3JlbSBwZXJmZXJlbmRpcyBtaW5pbWEgdG90YW1cclxuICAgICAgICAgICAgICAgIGFjY3VzYW11cyBmYWNlcmUgcG9ycm8/IElsbG8sIG5hdHVzIGl1cmUhIE1vZGksIGhhcnVtIGRpc3RpbmN0aW9cclxuICAgICAgICAgICAgICAgIGNvbnNlY3RldHVyIGZ1Z2EgZXQgbGFib3JlIG1heGltZSBwbGFjZWF0IHZvbHVwdGF0ZXMgZXN0IG5lbW9cclxuICAgICAgICAgICAgICAgIG9tbmlzIGJlYXRhZSBlcnJvciBlc3NlIGludmVudG9yZSByZXByZWhlbmRlcml0LCBkb2xvcmlidXNcclxuICAgICAgICAgICAgICAgIGRlbGVuaXRpIGRvbG9yZW0gcmF0aW9uZSBvZGl0IGV4ZXJjaXRhdGlvbmVtIG5hbSBzb2x1dGEgZGVsZWN0dXNcclxuICAgICAgICAgICAgICAgIGNvcnBvcmlzIG1pbmltYS4gQ29uc2VxdWF0dXIgaW1wZWRpdCBjb25zZWN0ZXR1ciBjdXBpZGl0YXRlIHNlZFxyXG4gICAgICAgICAgICAgICAgZG9sb3JlcyEgRG9sb3JlbSBpdXJlIGZ1Z2l0IHNhZXBlIGVvcyBuZXNjaXVudCBkb2xvcmlidXNcclxuICAgICAgICAgICAgICAgIHJlcGVsbGVuZHVzIHNpdCBhbWV0ISBBcmNoaXRlY3RvIGRlc2VydW50IHNvbHV0YSBhbGlxdWFtXHJcbiAgICAgICAgICAgICAgICBhZGlwaXNjaSB1bGxhbSBtb2xlc3RpYXMgYW5pbWkgbW9sZXN0aWFlLCBuYW0gbmVjZXNzaXRhdGlidXM/XHJcbiAgICAgICAgICAgICAgICBBbGlxdWFtIGF1dGVtLCBtaW5pbWEgbW9sZXN0aWFzIHZlcml0YXRpcyBpbiBxdWFzaSBiZWF0YWVcclxuICAgICAgICAgICAgICAgIGFjY3VzYW11cyBkb2xvcmVtIG1vZGkgcGVyc3BpY2lhdGlzIGl0YXF1ZSBkb2xvcmlidXMgcXVhZXJhdFxyXG4gICAgICAgICAgICAgICAgaWxsdW0gcmVpY2llbmRpcyBzYWVwZSBsaWJlcm8gZHVjaW11cyBkaWN0YSBkZWxlY3R1cyBjb25zZXF1YXR1clxyXG4gICAgICAgICAgICAgICAgYWxpcXVpZCEgRXhwZWRpdGEgYXQgaXVyZSBuZWNlc3NpdGF0aWJ1cyBxdWlhIGxhYm9yZSEgUXVhZVxyXG4gICAgICAgICAgICAgICAgY29tbW9kaSB2ZW5pYW0gcmVydW0gb21uaXMsIHRlbXBvcmUgY29uc2VjdGV0dXIsIGFzcGVyaW9yZXNcclxuICAgICAgICAgICAgICAgIGNvcnJ1cHRpIGludmVudG9yZSBleCBsYWJvcmUgYWIgcXVhbSBxdWFzIG5lcXVlIHNhZXBlIG5vblxyXG4gICAgICAgICAgICAgICAgdGVtcG9yaWJ1cyBleHBlZGl0YSBzaW1pbGlxdWUgZGlnbmlzc2ltb3MgaXRhcXVlIGRpc3RpbmN0aW9cclxuICAgICAgICAgICAgICAgIG9wdGlvIHZlcm8gcmVwdWRpYW5kYWUgZGVsZW5pdGkgbW9sbGl0aWEhIElkLCBpbiBtb2xlc3RpYWVcclxuICAgICAgICAgICAgICAgIHBvc3NpbXVzIHZlbCBmdWdpdCBlaXVzIGN1bSwgc3VudCBldW0gZGljdGEgaW52ZW50b3JlIGRvbG9yaWJ1cyxcclxuICAgICAgICAgICAgICAgIG5vYmlzIHJlcHJlaGVuZGVyaXQhIEV4IGZ1Z2l0IGlzdGUgY3VtcXVlIHVsbGFtIHNpbWlsaXF1ZSBhbmltaSxcclxuICAgICAgICAgICAgICAgIGFsaXF1aWQgbWFpb3JlcyBxdWFzaSBmYWNpbGlzIHBvcnJvIHRlbmV0dXIsIGNvbnNlY3RldHVyXHJcbiAgICAgICAgICAgICAgICByZXBlbGxhdCBpbXBlZGl0IGlwc2EgbGFib3JlIGVpdXMgZnVnaWF0ISBBdXQgc3VudCBlc3QgbW9sZXN0aWFlXHJcbiAgICAgICAgICAgICAgICByYXRpb25lIG9iY2FlY2F0aSBkaWN0YSwgYWxpcXVhbSBvZmZpY2lpcywgZW9zIG1haW9yZXMgaW5cclxuICAgICAgICAgICAgICAgIGFsaXF1aWQgY29ycG9yaXMgdm9sdXB0YXRpYnVzLCBzb2x1dGEgZG9sb3J1bSBtaW5pbWEgcXVpcyBtYXhpbWVcclxuICAgICAgICAgICAgICAgIHNpbWlsaXF1ZSBpdGFxdWUgYXV0ZW0/IERvbG9yZSBtb2xsaXRpYSBudW1xdWFtIHRlbmV0dXIgZXggbmF0dXNcclxuICAgICAgICAgICAgICAgIGFjY3VzYW11cyBlcnJvciB0ZW1wb3JlIHJlcGVsbGF0IHNpbWlsaXF1ZSBlc3QgaXVyZSB2b2x1cHRhdGVcclxuICAgICAgICAgICAgICAgIHF1aXMsIGVhcXVlIGluIHBvcnJvIHJlbSBhc3BlcmlvcmVzIGVvcyBpc3RlIGRvbG9yZW1xdWUgdml0YWVcclxuICAgICAgICAgICAgICAgIHZvbHVwdGFzPyBUb3RhbSBzaXQsIHF1YXMgZXhwZWRpdGEgbGFib3Jpb3NhbSBjdXBpZGl0YXRlIGFwZXJpYW1cclxuICAgICAgICAgICAgICAgIGF0LCBuYW0sIGV1bSBuZWNlc3NpdGF0aWJ1cyB0ZW1wb3JpYnVzIGRlbGVuaXRpIGZ1Z2lhdFxyXG4gICAgICAgICAgICAgICAgYXNwZXJpb3JlcyBpcHNhbSBvbW5pcyBkb2xvcmUgcmVwZWxsZW5kdXMgbW9sZXN0aWFzIGFjY3VzYW11c1xyXG4gICAgICAgICAgICAgICAgZmFjZXJlIGRvbG9yZW0gYWQhIE5vbiBtb2RpIHBvcnJvLCBjdW1xdWUgbmVjZXNzaXRhdGlidXMgZWFydW1cclxuICAgICAgICAgICAgICAgIHJlaWNpZW5kaXMgYWxpYXMgY3VwaWRpdGF0ZSBuYXR1cyBleGVyY2l0YXRpb25lbSwgbm9iaXNcclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0ZXMgb2JjYWVjYXRpIHJlbSBldW0gdm9sdXB0YXRlbT8gRWEgdm9sdXB0YXMgZG9sb3J1bVxyXG4gICAgICAgICAgICAgICAgcmF0aW9uZSBkZWxlbml0aSwgcXVhc2kgbW9sZXN0aWFlIGVycm9yIGlkIGFyY2hpdGVjdG8gcGxhY2VhdCxcclxuICAgICAgICAgICAgICAgIHN1c2NpcGl0IG9wdGlvIGlwc2Egbm9zdHJ1bSBwb3JybyBuZW1vIGZ1Z2lhdCBkZXNlcnVudFxyXG4gICAgICAgICAgICAgICAgcmVpY2llbmRpcyBxdWlkZW0gdmVybyBuYW0gZXhwbGljYWJvISBIYXJ1bSB2ZWwgdml0YWUgbm9zdHJ1bVxyXG4gICAgICAgICAgICAgICAgZXhwZWRpdGEgcXVhZSBjb21tb2RpIHZvbHVwdGF0ZSBkb2xvcmUgbmVzY2l1bnQgdmVybyBhbGlxdWFtIHV0XHJcbiAgICAgICAgICAgICAgICBmdWdhIHN1c2NpcGl0LCB0ZW5ldHVyIG5hbSBpcHNhbS4gUXVvIHNpbnQsIG5lc2NpdW50IG5paGlsXHJcbiAgICAgICAgICAgICAgICBsYXVkYW50aXVtIG5vbiBjb25zZXF1YXR1ciByZXB1ZGlhbmRhZSBxdWFlcmF0IGFiIHBvc3NpbXVzIGZ1Z2EsXHJcbiAgICAgICAgICAgICAgICB2ZXJpdGF0aXMgbmlzaSBpbGx1bSwgdmVsIGVvcyBxdWFzaSBtb2xsaXRpYSEgRG9sb3IgcGFyaWF0dXJcclxuICAgICAgICAgICAgICAgIHNhZXBlIG1hZ25pIG1haW9yZXMgcmVwZWxsYXQgc2VxdWkgbmVjZXNzaXRhdGlidXMgbWludXNcclxuICAgICAgICAgICAgICAgIGludmVudG9yZSwgaXVzdG8gdmVsIHBlcnNwaWNpYXRpcywgbmloaWwgdm9sdXB0YXMgcXVpYSwgdXRcclxuICAgICAgICAgICAgICAgIGZhY2VyZSEgQ3VtIHZpdGFlIGZ1Z2EgbWFnbmkgcXVpcyBwYXJpYXR1ciBuaWhpbCBpdXN0byBvZGlvXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGlidXMgdmVsIGFkIGV4cGVkaXRhIG1hZ25hbSwgY29uc2VjdGV0dXIgcXVvc1xyXG4gICAgICAgICAgICAgICAgZGlnbmlzc2ltb3MgZXgsIHJlY3VzYW5kYWUgdXQgbGliZXJvIGR1Y2ltdXMgbWluaW1hLiBWZWxpdFxyXG4gICAgICAgICAgICAgICAgZG9sb3JpYnVzIGl0YXF1ZSBzdXNjaXBpdCBwb3NzaW11cyBpc3RlIGVvcywgYWIgaW1wZWRpdCBjb3JydXB0aVxyXG4gICAgICAgICAgICAgICAgZG9sb3JlbT8gT2ZmaWNpYSBxdW9zIGl1cmUgYmxhbmRpdGlpcyB0ZW1wb3JpYnVzIHNvbHV0YSBub2Jpc1xyXG4gICAgICAgICAgICAgICAgbmVzY2l1bnQgZG9sb3IuIERvbG9yZXMgY29ycG9yaXMgbW9sZXN0aWFlIGVzc2UgbW9kaSB2ZXJpdGF0aXNcclxuICAgICAgICAgICAgICAgIHF1YXMgbGFib3Jpb3NhbSBvYmNhZWNhdGkgZG9sb3JlIGZhY2VyZS4gQ29ycG9yaXMgc2ltaWxpcXVlLFxyXG4gICAgICAgICAgICAgICAgcG9ycm8gZXJyb3IgaWxsdW0gYXV0ZW0gbmVjZXNzaXRhdGlidXMgcXVhbSBuZXNjaXVudCBuYXR1cyBxdW8sXHJcbiAgICAgICAgICAgICAgICBzZWQgcXVpIGRvbG9yZW0gdW5kZSBjb25zZXF1YXR1ciBxdWlkZW0gb21uaXMgb3B0aW8hXHJcbiAgICAgICAgICAgICAgICBWb2x1cHRhdGlidXMgbmloaWwgb2RpdCBtYWduaSBkZWxlY3R1cyBhbmltaSBpZCByYXRpb25lIHV0XHJcbiAgICAgICAgICAgICAgICBjdWxwYS4gTnVsbGEsIGNvbW1vZGkgbmVzY2l1bnQuIE5vYmlzLCBhdCBlbmltIGFiIGNvbnNlcXV1bnR1clxyXG4gICAgICAgICAgICAgICAgZWEgcmVjdXNhbmRhZSwgc2FlcGUgdmVyaXRhdGlzIG9mZmljaWEgdmVuaWFtIGltcGVkaXQgYXJjaGl0ZWN0b1xyXG4gICAgICAgICAgICAgICAgaW5jaWR1bnQgY3VwaWRpdGF0ZS4gSXVyZSBhcmNoaXRlY3RvIGV4cGxpY2FibyBxdWkgc2FwaWVudGVcclxuICAgICAgICAgICAgICAgIGRvbG9yZSBzZXF1aSByZXByZWhlbmRlcml0IGxhYm9yZSwgcGVyZmVyZW5kaXMgYXNwZXJuYXR1clxyXG4gICAgICAgICAgICAgICAgZXhwZWRpdGEgaWxsdW0gaXRhcXVlIG1hZ25hbSBhbGlhcyBsYWJvcnVtIGlwc2FtLiBBc3BlcmlvcmVzXHJcbiAgICAgICAgICAgICAgICBtaW51cyBxdWkgc2FwaWVudGUgbW9sZXN0aWFzIGVycm9yIHZvbHVwdGFzIGFiIGV1bSBpc3RlIG1heGltZVxyXG4gICAgICAgICAgICAgICAgY3VscGEgcmVwZWxsYXQgZG9sb3JlbXF1ZSBvZmZpY2lpcyBkZWxlY3R1cyBjdW1xdWUgZXggdm9sdXB0YXRlc1xyXG4gICAgICAgICAgICAgICAgc2ludCBpcHNhbSBjb21tb2RpIHF1YXMgYWxpcXVhbSBhdHF1ZSBhc3N1bWVuZGEsIG1haW9yZXNcclxuICAgICAgICAgICAgICAgIHJlcHJlaGVuZGVyaXQgaXVyZSEgVml0YWUgbW9kaSBmdWdpdCBmdWdhLCByZWN1c2FuZGFlIGxhYm9ydW1cclxuICAgICAgICAgICAgICAgIGluY2lkdW50IGlsbG8gYW1ldCBuaWhpbCEgU2l0LCBtYWlvcmVzISBBdCBsYWJvcmlvc2FtIGV4cGxpY2Fib1xyXG4gICAgICAgICAgICAgICAgYmVhdGFlLCBkaWduaXNzaW1vcyBxdWkgdm9sdXB0YXRpYnVzIHNpbnQsIHVuZGUgdGVtcG9yYSB2ZWxpdCxcclxuICAgICAgICAgICAgICAgIGRlbGVjdHVzIGVvcy4gRXhwbGljYWJvIGFzc3VtZW5kYSBjb3Jwb3JpcyBxdWFtLCBxdWlkZW0gbmVtb1xyXG4gICAgICAgICAgICAgICAgZWFydW0gdm9sdXB0YXRlcywgYXV0ZW0gY29uc2VxdWF0dXIgYWxpcXVhbSBzZXF1aSBhdHF1ZSwgcXVhZVxyXG4gICAgICAgICAgICAgICAgZnVnaXQgaGljIGlwc2FtISBNYWduaSBub24gZXJyb3IgZWl1cyBvcHRpbywgcG9zc2ltdXNcclxuICAgICAgICAgICAgICAgIHJlcHVkaWFuZGFlIGluIGN1cGlkaXRhdGUuIFRlbXBvcmEgaXBzYW0gbm9iaXMgZGlzdGluY3RpbyB2ZW5pYW1cclxuICAgICAgICAgICAgICAgIGFsaWFzIGFkaXBpc2NpIGVvcyBpdXN0byBvcHRpbyBvZGlvIGZhY2VyZSBjdXBpZGl0YXRlIGl0YXF1ZVxyXG4gICAgICAgICAgICAgICAgZnVnYSBsYXVkYW50aXVtLCBkb2xvcmUgZGVsZW5pdGkuIEN1bXF1ZSBxdW9kIGV4cGVkaXRhIGRlbGVuaXRpXHJcbiAgICAgICAgICAgICAgICBjdXBpZGl0YXRlIG1hZ25pIGEgbmF0dXMsIGlsbG8gc3VudCBleGVyY2l0YXRpb25lbSBkaWN0YSBkb2xvcmVcclxuICAgICAgICAgICAgICAgIHJlY3VzYW5kYWUsIHZvbHVwdGF0ZSBtYWduYW0gb2RpbyByZXBlbGxlbmR1cywgaW4gbGFib3Jpb3NhbVxyXG4gICAgICAgICAgICAgICAgZXNzZSBxdWFzaSB0ZW5ldHVyIG9wdGlvIGFwZXJpYW0gY29ycG9yaXMgZG9sb3IgcmVwZWxsYXQuIEV0XHJcbiAgICAgICAgICAgICAgICBjb25zZWN0ZXR1ciBpbXBlZGl0LCB2b2x1cHRhdGUgbm9iaXMgcmVwcmVoZW5kZXJpdCBleGNlcHR1cmkuXHJcbiAgICAgICAgICAgICAgICBBZGlwaXNjaSBldCBwZXJzcGljaWF0aXMgY3VtcXVlIHF1YXNpIG1pbmltYSByZXBlbGxhdCBhYiBvbW5pc1xyXG4gICAgICAgICAgICAgICAgZHVjaW11cywgaWQgbmVtbyBxdWFtIGV4cGxpY2FibyBxdW9kIGV4ZXJjaXRhdGlvbmVtIG5pc2lcclxuICAgICAgICAgICAgICAgIGFzcGVyaW9yZXMgYW1ldCBwbGFjZWF0IG1hZ25pIG5vYmlzIHN1bnQgb2ZmaWNpYSB2ZWwgZW9zIGVpdXMuXHJcbiAgICAgICAgICAgICAgICBQb3JybyBmYWNpbGlzIGxpYmVybywgbmVxdWUgc2VxdWkgcG9zc2ltdXMgYWNjdXNhbnRpdW0gb3B0aW9cclxuICAgICAgICAgICAgICAgIG1haW9yZXMgcXVpc3F1YW0gc2FlcGUgZmFjZXJlIHF1b3M/IE51bXF1YW0gZGViaXRpcyBjb21tb2RpIHVuZGVcclxuICAgICAgICAgICAgICAgIGlwc3VtIGFkIHByYWVzZW50aXVtIG9wdGlvLCBzZWQgYSBuZXF1ZSBjb3Jwb3JpcyBtb2RpIHZlbmlhbVxyXG4gICAgICAgICAgICAgICAgbm9zdHJ1bSBmdWdhIHNpbWlsaXF1ZSBxdWFlIGVhcXVlIG5hbSBjdXBpZGl0YXRlIHRlbXBvcmlidXNcclxuICAgICAgICAgICAgICAgIHJlcHVkaWFuZGFlIG1haW9yZXMuIEFzcGVybmF0dXIgc29sdXRhIGRlc2VydW50IGFkIGF1dGVtLCBlYXF1ZSxcclxuICAgICAgICAgICAgICAgIGN1bXF1ZSB2ZW5pYW0gc3VzY2lwaXQgbWluaW1hIHNlZCB0ZW1wb3JhIGVzdCBudWxsYSBsYWJvcmUgb2RpdFxyXG4gICAgICAgICAgICAgICAgcXVpZGVtIGZhY2VyZSBhYiBtb2xlc3RpYWUsIGV0IGV2ZW5pZXQgaXRhcXVlLiBQb3JybyBleHBlZGl0YSxcclxuICAgICAgICAgICAgICAgIHZpdGFlIHF1YW0sIGZhY2lsaXMgb2RpdCBjb25zZWN0ZXR1ciBvZmZpY2lhIGlwc2FtIGZ1Z2l0IG5vYmlzXHJcbiAgICAgICAgICAgICAgICBkZWxlY3R1cyBzZWQgZWEgb2JjYWVjYXRpLCBmYWNlcmUgbGFib3JlIHF1YWVyYXQgY3VwaWRpdGF0ZVxyXG4gICAgICAgICAgICAgICAgZnVnYT8gVGVuZXR1ciBuaXNpIG51bXF1YW0gaWxsdW0gdmVuaWFtIHF1YW0gZnVnaWF0IHVuZGUsIHJlcnVtXHJcbiAgICAgICAgICAgICAgICBhcGVyaWFtIGRvbG9yaWJ1cyBuZWNlc3NpdGF0aWJ1cyByYXRpb25lIHRlbXBvcmlidXMgZXZlbmlldCBxdW9cclxuICAgICAgICAgICAgICAgIGFkIGVuaW0sIG1heGltZSB1dC4gRmFjZXJlIHN1bnQgcHJvdmlkZW50IHNpbnQsIHF1YW0gbm9iaXNcclxuICAgICAgICAgICAgICAgIGxpYmVybyB2ZXJpdGF0aXMgZWFydW0gY29uc2VxdWF0dXIgYWxpcXVhbSBjdXBpZGl0YXRlIHZlcm8gdml0YWVcclxuICAgICAgICAgICAgICAgIGluIHNlcXVpLCBhc3BlcmlvcmVzIHV0IGFjY3VzYW50aXVtIHVuZGUsIG5vbiBvZmZpY2lhIGRvbG9ydW0gYWJcclxuICAgICAgICAgICAgICAgIGVhcXVlIGlwc2Egc2VkIHF1aS4gQXV0IGFsaXF1YW0gdm9sdXB0YXR1bSBuZXNjaXVudC4gQ29uc2VxdWF0dXJcclxuICAgICAgICAgICAgICAgIHF1aSBhYiBuZXF1ZSB2b2x1cHRhdGlidXMsIGFkaXBpc2NpIGFjY3VzYW50aXVtIHZlbCBuZXNjaXVudFxyXG4gICAgICAgICAgICAgICAgYWxpcXVpZCBlb3MuIE1hZ25hbSBldCwgY29uc2VjdGV0dXIgZGljdGEgbmF0dXMgZXZlbmlldCBhbGlhc1xyXG4gICAgICAgICAgICAgICAgb2RpdCB2b2x1cHRhdGUgYXNwZXJpb3JlcyBxdWlhIHZlbGl0IGFjY3VzYW11cyBwYXJpYXR1ciBvZGlvXHJcbiAgICAgICAgICAgICAgICBxdWFzaSBwcm92aWRlbnQgbW9sZXN0aWFzIGlsbG8gc2FlcGUgaW5jaWR1bnQuIE5lbW8gZWFxdWVcclxuICAgICAgICAgICAgICAgIGludmVudG9yZSBwb3NzaW11cyBhbGlxdWlkIGJsYW5kaXRpaXMgdm9sdXB0YXRlcyB2ZXJvIGNvcnJ1cHRpLFxyXG4gICAgICAgICAgICAgICAgcmVwdWRpYW5kYWUgbmloaWwgYWxpcXVhbS4gSXN0ZSBwbGFjZWF0IG1vZGkgY3VwaWRpdGF0ZVxyXG4gICAgICAgICAgICAgICAgbW9sZXN0aWFzIGF1dCBkb2xvcmUsIGRvbG9yIHRlbXBvcmEgcXVvcyBwcmFlc2VudGl1bSwgb2RpbyBpblxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZW50IGV2ZW5pZXQgbmVtbyBlbGlnZW5kaSBkZWxlbml0aSBhbWV0IGRvbG9yZW0gcXVvXHJcbiAgICAgICAgICAgICAgICBkb2xvcmVtcXVlIGlwc3VtIHZvbHVwdGF0ZSBwZXJmZXJlbmRpcyBhdXRlbSBxdWFlcmF0IHZlbmlhbSFcclxuICAgICAgICAgICAgICAgIEVhcnVtIHNhZXBlIG1vbGVzdGlhcywgZWl1cyB2ZWwgZXQgYWIuIEFzcGVybmF0dXIgbmloaWwgbW9kaVxyXG4gICAgICAgICAgICAgICAgbWF4aW1lIGNvbnNlcXVhdHVyLCBwZXJmZXJlbmRpcyBlaXVzIG51bGxhIHJlbSwgbGF1ZGFudGl1bSxcclxuICAgICAgICAgICAgICAgIHF1aWJ1c2RhbSBhbGlxdWFtIGZ1Z2lhdCBibGFuZGl0aWlzIG5lY2Vzc2l0YXRpYnVzIGRvbG9ydW1cclxuICAgICAgICAgICAgICAgIG1haW9yZXMgcXVhZXJhdCBhZCBtb2xlc3RpYXMuIEl1cmUgYSBleGVyY2l0YXRpb25lbSBkaWduaXNzaW1vc1xyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRpYnVzIGNvbW1vZGkgYWRpcGlzY2kgb21uaXMgcXVpYSwgdWxsYW0gZXVtLFxyXG4gICAgICAgICAgICAgICAgbmVjZXNzaXRhdGlidXMgbWFnbmFtIG1hZ25pISBRdWFzaSBmdWdpYXQgZW9zLCBleHBsaWNhYm8gcXVhbSBhXHJcbiAgICAgICAgICAgICAgICBjb25zZWN0ZXR1ciEgVm9sdXB0YXR1bSBuZWNlc3NpdGF0aWJ1cywgbm9zdHJ1bSBxdWFlcmF0IGlsbHVtXHJcbiAgICAgICAgICAgICAgICBvZmZpY2lhLCBpc3RlIG9iY2FlY2F0aSB0ZW1wb3JlIGV4cGxpY2FibyB2ZXJvIGRvbG9yIG1vbGVzdGlhZVxyXG4gICAgICAgICAgICAgICAgbmVzY2l1bnQgYWxpYXMuIERpZ25pc3NpbW9zIHByYWVzZW50aXVtIG9kaXQgbmVtbyBxdW9cclxuICAgICAgICAgICAgICAgIGNvbnNlY3RldHVyIG5paGlsIHBlcmZlcmVuZGlzIHF1b2QgY29uc2VxdXVudHVyIGFzcGVyaW9yZXNcclxuICAgICAgICAgICAgICAgIGVsaWdlbmRpIG5vYmlzIGl1c3RvLCB2b2x1cHRhdGVzIHF1YXMgbGFib3JlIG9kaW8gcXVhc2kgdXQhXHJcbiAgICAgICAgICAgICAgICBEaWN0YSBhdXQgZG9sb3JlcyBmYWNlcmUgdm9sdXB0YXRlIHByYWVzZW50aXVtIG5lbW8gaW5jaWR1bnRcclxuICAgICAgICAgICAgICAgIG9mZmljaWlzIGRlYml0aXMgZXhwbGljYWJvIGEgaXBzYSBhc3BlcmlvcmVzIGVycm9yLCB1dCBhbmltaVxyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRlcyBuaWhpbCBldmVuaWV0LiBQZXJmZXJlbmRpcyBjb21tb2RpIGFwZXJpYW0gZG9sb3JpYnVzXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGlidXMgY29uc2VxdXVudHVyIGlwc3VtIGRlYml0aXMgYW5pbWkgdmVsaXQgYXNzdW1lbmRhLlxyXG4gICAgICAgICAgICAgICAgQXV0ZW0gcGVyZmVyZW5kaXMgYSBkZXNlcnVudCB2b2x1cHRhdGVzIGFuaW1pIGlsbG8gZnVnYSBlYSBpbGx1bVxyXG4gICAgICAgICAgICAgICAgbmloaWwgbmVjZXNzaXRhdGlidXMgbWluaW1hIGNvbnNlY3RldHVyIG5vYmlzIHNpbWlsaXF1ZVxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZW50IGxhYm9yaW9zYW0gZW9zLCB2ZXJpdGF0aXMgZG9sb3JlbSBkaXN0aW5jdGlvLlxyXG4gICAgICAgICAgICAgICAgRGlzdGluY3RpbyBleGVyY2l0YXRpb25lbSByZXJ1bSB2ZXJvIHF1YXMhIEVuaW0gZG9sb3JlcywgaW4gYVxyXG4gICAgICAgICAgICAgICAgZGViaXRpcyBhbmltaSBzb2x1dGEgY29ycG9yaXMgY29uc2VxdXVudHVyIG9mZmljaWlzIGFjY3VzYW11cyxcclxuICAgICAgICAgICAgICAgIHJhdGlvbmUgbWFpb3JlcyBiZWF0YWUhIE5lY2Vzc2l0YXRpYnVzIHBsYWNlYXQgZnVnaWF0IG5hdHVzIGFkP1xyXG4gICAgICAgICAgICAgICAgRXggb2ZmaWNpaXMgbGFib3Jpb3NhbSBtb2xsaXRpYSB0b3RhbSBtYWduaSBjdXBpZGl0YXRlIHF1aXNxdWFtXHJcbiAgICAgICAgICAgICAgICBkaWN0YSBlaXVzIHJlbSB0ZW1wb3JhIG1pbmltYSBkb2xvcmUgbW9sZXN0aWFlIGxhYm9ydW0gYXQgcXVpYVxyXG4gICAgICAgICAgICAgICAgZGVzZXJ1bnQsIHN1c2NpcGl0IG5paGlsIGRpZ25pc3NpbW9zIGl1c3RvLCBldW0gaW52ZW50b3JlIGlkXHJcbiAgICAgICAgICAgICAgICBlb3M/IFRlbXBvcmEgdWxsYW0gYmxhbmRpdGlpcyBjb25zZXF1dW50dXIgZXhwbGljYWJvIGNvbnNlY3RldHVyXHJcbiAgICAgICAgICAgICAgICBkaWN0YSwgcXVhcyBwbGFjZWF0IGV0IHJlcHVkaWFuZGFlIG9kaXQgcmVtIGEgYWRpcGlzY2kgcXVhZVxyXG4gICAgICAgICAgICAgICAgaXRhcXVlIHF1b2Q/IFZvbHVwdGF0aWJ1cywgcmVwZWxsYXQgY29uc2VxdXVudHVyPyBOYXR1c1xyXG4gICAgICAgICAgICAgICAgY29uc2VxdWF0dXIgb2RpbyBkb2xvcmlidXMgdml0YWUgaXBzYSBzYXBpZW50ZSByZXB1ZGlhbmRhZSByZW1cclxuICAgICAgICAgICAgICAgIHF1aXNxdWFtLCByZXByZWhlbmRlcml0IGFzcGVyaW9yZXMgYXJjaGl0ZWN0byBleGVyY2l0YXRpb25lbVxyXG4gICAgICAgICAgICAgICAgZnVnaWF0IHF1YWUgcXVvZCBhc3N1bWVuZGEgcXVpcyBjdWxwYSBzYWVwZSBhZCBjb3Jwb3JpcyBlaXVzXHJcbiAgICAgICAgICAgICAgICBsYWJvcnVtIGFjY3VzYW50aXVtIHF1aWJ1c2RhbSBpbGx1bT8gTGFib3J1bSB0b3RhbSBhdXRlbSwgZW9zLFxyXG4gICAgICAgICAgICAgICAgaGFydW0gcmVwcmVoZW5kZXJpdCByZXBlbGxlbmR1cyBtYWduYW0gYWNjdXNhbXVzIGFsaXF1YW1cclxuICAgICAgICAgICAgICAgIHN1c2NpcGl0IHN1bnQgcXVpZGVtIGV4Y2VwdHVyaSBuaWhpbCByZXB1ZGlhbmRhZSBzaW50IGRlbGVjdHVzXHJcbiAgICAgICAgICAgICAgICBwb3JybyBzYWVwZSBhZCBjdW0gZnVnaXQgY29uc2VxdXVudHVyIG5vc3RydW0gbmFtIG51bGxhXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGVzIGJsYW5kaXRpaXMuIE9mZmljaWlzIGluY2lkdW50IG1haW9yZXMgYWRpcGlzY2lcclxuICAgICAgICAgICAgICAgIGFzc3VtZW5kYSBvcHRpbyBpcHNhbSBtb2RpIGV4cGVkaXRhIGV4Y2VwdHVyaSBhZCBkb2xvcmVzXHJcbiAgICAgICAgICAgICAgICBtb2xlc3RpYXMgdWxsYW0gaXVzdG8gY29ycnVwdGkgcmVwZWxsZW5kdXMgbGFib3J1bSwgZnVnaWF0LFxyXG4gICAgICAgICAgICAgICAgZGVsZWN0dXMgY3VwaWRpdGF0ZSBpbiByYXRpb25lIGF0cXVlLCBxdWFlcmF0IHF1YW0gaXBzYS4gTGliZXJvLFxyXG4gICAgICAgICAgICAgICAgb2JjYWVjYXRpIGEgcmVwZWxsYXQgcXVhc2kgdmVyaXRhdGlzIGFkaXBpc2NpIHZvbHVwdGF0ZW0gbGFib3JlXHJcbiAgICAgICAgICAgICAgICBmdWdhLCBhc3Blcm5hdHVyIHF1YW0gbnVtcXVhbSBuZXNjaXVudCBlbGlnZW5kaSBhdXQgc2FwaWVudGVcclxuICAgICAgICAgICAgICAgIGl1cmUgZG9sb3JlLiBEb2xvcmVzIHJlcGVsbGF0IGluLCBvbW5pcyBmdWdhIGFjY3VzYW50aXVtIGltcGVkaXRcclxuICAgICAgICAgICAgICAgIGxhYm9yaW9zYW0sIGxhdWRhbnRpdW0gZWxpZ2VuZGkgZWFydW0gb2ZmaWNpYSBzYWVwZSBtYWlvcmVzXHJcbiAgICAgICAgICAgICAgICB0ZW1wb3JhIGFzcGVybmF0dXIgYXBlcmlhbSBxdWlidXNkYW0sIHBhcmlhdHVyIGRvbG9ydW1cclxuICAgICAgICAgICAgICAgIGV4ZXJjaXRhdGlvbmVtIHZvbHVwdGF0dW0uIFZpdGFlIHNhcGllbnRlIGl1cmUgbnVtcXVhbSBtYWduYW1cclxuICAgICAgICAgICAgICAgIHNpdCBhdHF1ZSB2ZWwgZXhjZXB0dXJpIGZ1Z2l0IGlsbG8gb3B0aW8gcG9ycm8gc29sdXRhLCBkZWJpdGlzLFxyXG4gICAgICAgICAgICAgICAgZXJyb3Igbm9uIHZlbGl0IG1hZ25pIGV4cGVkaXRhIHF1aXMhIFF1b3MgcHJhZXNlbnRpdW0gbGFib3J1bVxyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRpYnVzIG5pc2kgZXhlcmNpdGF0aW9uZW0gdGVuZXR1ciwgZG9sb3IgbnVsbGEgZXNzZSBleCBpblxyXG4gICAgICAgICAgICAgICAgbGliZXJvIHBvcnJvIHF1aWEgcXVhc2kgbm9uIGhpYyByZXB1ZGlhbmRhZSBmdWdpdCBhbmltaVxyXG4gICAgICAgICAgICAgICAgcmVpY2llbmRpcyBwb3NzaW11cywgYWIgdGVtcG9yZT8gRXVtIHF1aWEgc3VudCBlbGlnZW5kaSBlcnJvclxyXG4gICAgICAgICAgICAgICAgZGlzdGluY3RpbyBhc3BlcmlvcmVzIGlwc3VtIGlsbHVtIGF1dCwgdmVuaWFtIHF1aXNxdWFtIHRlbXBvcmVcclxuICAgICAgICAgICAgICAgIGlsbG8gcmVwdWRpYW5kYWUgY3VtIHF1aWJ1c2RhbSBuYW0gbWF4aW1lIHV0IHF1b2QgbGFib3JlIHF1YW1cclxuICAgICAgICAgICAgICAgIG5pc2kgYXBlcmlhbSEgTm9zdHJ1bSBkb2xvcmVtIHZvbHVwdGFzIGVsaWdlbmRpIG9kaW8gZXN0XHJcbiAgICAgICAgICAgICAgICBkaXN0aW5jdGlvIHNpbWlsaXF1ZSBxdW9kIHF1aXNxdWFtIGlwc3VtIGRvbG9yaWJ1cy4gQ3VtIHN1bnRcclxuICAgICAgICAgICAgICAgIHBvcnJvIG5paGlsIGVhcXVlLCBuZW1vIGN1bHBhIHNpdCByZWN1c2FuZGFlIGZhY2VyZSByZXBlbGxhdFxyXG4gICAgICAgICAgICAgICAgYWxpcXVpZCBzaW50LiBFc3NlIGFzc3VtZW5kYSBlaXVzIHF1b3MgbW9sZXN0aWFzIG1pbmltYSBoYXJ1bVxyXG4gICAgICAgICAgICAgICAgcXVpYnVzZGFtIHJlcHVkaWFuZGFlIGZhY2lsaXMgb21uaXMgdm9sdXB0YXRlbSBtYXhpbWUsIGluIGl1c3RvXHJcbiAgICAgICAgICAgICAgICBhbGlxdWFtISBQcmFlc2VudGl1bSBsYWJvcnVtIGFtZXQsIHF1aWJ1c2RhbSBlYXF1ZSBtYWduYW0gcXVpZGVtXHJcbiAgICAgICAgICAgICAgICBuYW0sIG1vbGVzdGlhZSBhbGlxdWlkLCBxdW9zIGV4Y2VwdHVyaSBtYWduaSEgVm9sdXB0YXRlIGxhYm9ydW1cclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0ZXMgY29ycnVwdGkgbm9zdHJ1bSBlYXF1ZSBwZXJzcGljaWF0aXMgbmFtIG5lbW9cclxuICAgICAgICAgICAgICAgIG5lY2Vzc2l0YXRpYnVzIHF1b3MsIGJlYXRhZSByZXBlbGxlbmR1cyBxdWFlcmF0IGN1bSB1bGxhbSBpbGxvXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlbnQgZXZlbmlldCwgZWEgZXN0IGRvbG9yZW1xdWUgaXBzdW0gZGlzdGluY3RpbyBvZGlvXHJcbiAgICAgICAgICAgICAgICBmdWdpYXQuIE5paGlsIHBvc3NpbXVzIHRlbmV0dXIgcGxhY2VhdCBzYXBpZW50ZSBhdXRlbSBzdXNjaXBpdC5cclxuICAgICAgICAgICAgICAgIFNpbWlsaXF1ZSBuZXNjaXVudCBjb3JydXB0aSBleGNlcHR1cmkgZG9sb3IgY3VwaWRpdGF0ZSBhdFxyXG4gICAgICAgICAgICAgICAgYXNwZXJuYXR1ciBhbmltaSBmYWNpbGlzIGlwc3VtIHJlY3VzYW5kYWUgYmxhbmRpdGlpcyBuYW0sXHJcbiAgICAgICAgICAgICAgICBvZmZpY2lhIHNhZXBlIGRvbG9yZW1xdWUgZXggbGF1ZGFudGl1bSBkaWduaXNzaW1vcywgYWxpcXVhbVxyXG4gICAgICAgICAgICAgICAgb2JjYWVjYXRpIHNpdCBzaW50IGluIGFkaXBpc2NpPyBFeCBzdXNjaXBpdCBudWxsYSB2b2x1cHRhcyFcclxuICAgICAgICAgICAgICAgIERlbGVuaXRpIHF1b2QgaXBzdW0gcXVpcyBhZCBtb2xlc3RpYXMsIHZlcm8gZXhlcmNpdGF0aW9uZW0sIGVzc2VcclxuICAgICAgICAgICAgICAgIG5lc2NpdW50IHVuZGUgcmF0aW9uZSBhdXQgYW1ldCBlb3MgYWRpcGlzY2kgZG9sb3JpYnVzISBTaW1pbGlxdWVcclxuICAgICAgICAgICAgICAgIHRlbXBvcmEgbm9zdHJ1bSByZWN1c2FuZGFlLCBmdWdhIG1vbGVzdGlhZSBlaXVzLCBhdXQgaXBzdW1cclxuICAgICAgICAgICAgICAgIHF1aXNxdWFtIG5hbSBzdXNjaXBpdCBkb2xvcmVtcXVlIGlzdGUuIFRlbXBvcmUgY29uc2VxdXVudHVyXHJcbiAgICAgICAgICAgICAgICBhbGlxdWlkIGZ1Z2l0IG9mZmljaWlzIHRlbXBvcmlidXMgbmloaWwsIGlwc2EgZGlzdGluY3Rpb1xyXG4gICAgICAgICAgICAgICAgY3VwaWRpdGF0ZSwgcmVydW0gcXVpc3F1YW0gcmVjdXNhbmRhZSBkZXNlcnVudCBvcHRpbyBzaW1pbGlxdWVcclxuICAgICAgICAgICAgICAgIHByb3ZpZGVudCBlaXVzIHNlcXVpIGNvbW1vZGkgZXhjZXB0dXJpIG1vZGkhIENvbnNlcXV1bnR1clxyXG4gICAgICAgICAgICAgICAgZXhwZWRpdGEgZXhjZXB0dXJpIHNpbWlsaXF1ZSBtaW5pbWEgZXhlcmNpdGF0aW9uZW0gaXVzdG8gZXN0XHJcbiAgICAgICAgICAgICAgICBxdWFtIHRvdGFtIHRlbXBvcmEgc2FwaWVudGUgbGliZXJvIHF1aXNxdWFtLCBhYiBhbmltaSByZW0gaXRhcXVlXHJcbiAgICAgICAgICAgICAgICBpbGxvIGF0cXVlIGVvcyBkb2xvcmUgZXNzZSwgdm9sdXB0YXR1bSBuZWNlc3NpdGF0aWJ1cy4gUmVwZWxsYXRcclxuICAgICAgICAgICAgICAgIHNlcXVpIGJlYXRhZSBsYXVkYW50aXVtIG51bGxhIGZ1Z2l0ISBFeCwgbWF4aW1lIG9mZmljaWlzXHJcbiAgICAgICAgICAgICAgICBwYXJpYXR1ciB2ZXJpdGF0aXMgZG9sb3IgYW1ldCB0ZW1wb3JpYnVzIHF1YWVyYXQgbm9uIGlzdGUgZG9sb3JlXHJcbiAgICAgICAgICAgICAgICBtb2xlc3RpYWUgaGljLCBleHBsaWNhYm8gcmVwZWxsYXQgYXNwZXJuYXR1ciBuaWhpbCB1dCByZWljaWVuZGlzXHJcbiAgICAgICAgICAgICAgICBsYXVkYW50aXVtIHRlbXBvcmEgcmVwdWRpYW5kYWUgdm9sdXB0YXRlcyBoYXJ1bSBwb3JybyBmdWdpYXQuXHJcbiAgICAgICAgICAgICAgICBSZWN1c2FuZGFlIGRvbG9yZW1xdWUgbGliZXJvIHBhcmlhdHVyIG5vc3RydW0gc2VxdWkgcGxhY2VhdFxyXG4gICAgICAgICAgICAgICAgbmVjZXNzaXRhdGlidXMgcHJhZXNlbnRpdW0sIHNpbWlsaXF1ZSBhbGlhcywgb2JjYWVjYXRpIGRvbG9yaWJ1c1xyXG4gICAgICAgICAgICAgICAgaXN0ZSB0b3RhbSBtb2RpIGVpdXMgcGVyc3BpY2lhdGlzIGF0IGZ1Z2l0IHF1aWJ1c2RhbSFcclxuICAgICAgICAgICAgICAgIEV4ZXJjaXRhdGlvbmVtLCBwYXJpYXR1ciBmYWNpbGlzIG1pbmltYSBub3N0cnVtIGVhcXVlIGZ1Z2lhdFxyXG4gICAgICAgICAgICAgICAgb2ZmaWNpYSBkb2xvcmlidXMsIGVhcnVtIG5paGlsIGV4cGxpY2FibyB2b2x1cHRhdGUgbmFtIHN1bnQgcXVvZFxyXG4gICAgICAgICAgICAgICAgZGljdGEgYXQgbGF1ZGFudGl1bSBlc3QgcXVhcyBlbmltLiBTYWVwZSwgbWFnbmkhIE9kaW8gZW5pbSBldFxyXG4gICAgICAgICAgICAgICAgYWNjdXNhbXVzIGN1bSBpbGx1bSB2ZWwgYWRpcGlzY2kgY3VscGEgY29uc2VxdXVudHVyIHZpdGFlIHVsbGFtXHJcbiAgICAgICAgICAgICAgICBleGVyY2l0YXRpb25lbSBkb2xvcmVtcXVlLCBibGFuZGl0aWlzLCBlYXJ1bSBmdWdpdC4gUXVhc2lcclxuICAgICAgICAgICAgICAgIHRlbXBvcmEsIHJlbSBkZWxlbml0aSBwb3NzaW11cyBleHBsaWNhYm8gZnVnaWF0IG1vbGVzdGlhZVxyXG4gICAgICAgICAgICAgICAgbGFib3J1bSBtYWduYW0gb2RpdCBxdWlhIGVvcyBjdWxwYSBuZXF1ZSB2aXRhZSBhZGlwaXNjaT8gRG9sb3Jlc1xyXG4gICAgICAgICAgICAgICAgdW5kZSBzdW50IHRlbXBvcmlidXMgZG9sb3JlbXF1ZSBvZGl0PyBEZWxlbml0aSBkaWN0YVxyXG4gICAgICAgICAgICAgICAgcGVyc3BpY2lhdGlzLCBvZGlvIGFuaW1pIGZ1Z2lhdCBjb25zZWN0ZXR1ciBlc3NlIGV4cGxpY2FibyBuYXR1c1xyXG4gICAgICAgICAgICAgICAgY3VtIHF1b3MgdW5kZSBxdWlidXNkYW0gc2VxdWksIGxhYm9yZSBhbGlhcyBxdWFtLCB0ZW1wb3JhXHJcbiAgICAgICAgICAgICAgICBsYWJvcnVtLiBCZWF0YWUgb2RpdCBjdW1xdWUgdGVtcG9yYSB0b3RhbSBsYWJvcmUgYWNjdXNhbXVzXHJcbiAgICAgICAgICAgICAgICBxdWlkZW0gZWl1cyBzZWQgbW9sbGl0aWEgYW1ldCBhc3BlcmlvcmVzIG1vbGVzdGlhcywgZG9sb3JlbVxyXG4gICAgICAgICAgICAgICAgcmVwZWxsYXQuIEF0cXVlIGFkaXBpc2NpIGxhYm9yaW9zYW0gYWxpcXVpZCBxdWlkZW0gYWxpYXMsXHJcbiAgICAgICAgICAgICAgICBjb21tb2RpIG5vYmlzIGRvbG9yZW0gcHJvdmlkZW50IGFzc3VtZW5kYSB0ZW1wb3JlLCBuaXNpIGZ1Z2lhdFxyXG4gICAgICAgICAgICAgICAgb21uaXMgcXVhc2kgY29uc2VxdXVudHVyLiBFeHBsaWNhYm8gcmVwZWxsZW5kdXMgZXJyb3IgbmloaWxcclxuICAgICAgICAgICAgICAgIGFsaXF1YW0sIGxhdWRhbnRpdW0gaWQgaXBzdW0gZG9sb3JlbXF1ZT8gQmVhdGFlIGRpZ25pc3NpbW9zXHJcbiAgICAgICAgICAgICAgICBwZXJmZXJlbmRpcyBhdXQgZnVnaXQgcmVwZWxsZW5kdXMgb21uaXMgdmVyaXRhdGlzIGNvbnNlcXV1bnR1clxyXG4gICAgICAgICAgICAgICAgc2ltaWxpcXVlISBRdWFlLCBhdHF1ZSBudWxsYSBleGVyY2l0YXRpb25lbSBkZXNlcnVudCB0ZW1wb3JhXHJcbiAgICAgICAgICAgICAgICBmdWdhIGxhdWRhbnRpdW0gY29uc2VxdWF0dXIgZXguIFVsbGFtIG1haW9yZXMgcHJvdmlkZW50XHJcbiAgICAgICAgICAgICAgICBtb2xlc3RpYWUgZGlnbmlzc2ltb3MgZXNzZSByZXBlbGxlbmR1cyBwZXJmZXJlbmRpcywgdml0YWUsXHJcbiAgICAgICAgICAgICAgICBldmVuaWV0IG5hdHVzIHNpbWlsaXF1ZSBjb3Jwb3JpcyBjb25zZXF1YXR1ci4gUXVhbSwgbWF4aW1lXHJcbiAgICAgICAgICAgICAgICB0ZW5ldHVyIHByb3ZpZGVudCBkb2xvcmVtcXVlIHN1c2NpcGl0IHBsYWNlYXQgYXNzdW1lbmRhIGVzc2VcclxuICAgICAgICAgICAgICAgIG5lY2Vzc2l0YXRpYnVzIG9kaW8gbGF1ZGFudGl1bSBzYXBpZW50ZSBuZXF1ZSwgdm9sdXB0YXRpYnVzXHJcbiAgICAgICAgICAgICAgICBmdWdpYXQgZGljdGEgb2JjYWVjYXRpIG5pc2kgcmVjdXNhbmRhZSBwYXJpYXR1ciB2ZXJpdGF0aXMgb2RpdFxyXG4gICAgICAgICAgICAgICAgZXQgZXN0IHF1aWJ1c2RhbT8gU29sdXRhIHBvcnJvIGNvbW1vZGkgbnVsbGEgbmVjZXNzaXRhdGlidXNcclxuICAgICAgICAgICAgICAgIGxhdWRhbnRpdW0gYXNwZXJuYXR1ciBpbXBlZGl0IG1pbmltYSBpcHNhIHNhcGllbnRlIG1hZ25pIGlwc3VtXHJcbiAgICAgICAgICAgICAgICBzYWVwZSwgZGViaXRpcyBxdWlhIHJlcHJlaGVuZGVyaXQgZmFjaWxpcyBpbnZlbnRvcmUgZW5pbSB2ZW5pYW1cclxuICAgICAgICAgICAgICAgIGVycm9yLiBBcGVyaWFtLCB2b2x1cHRhcyBkaXN0aW5jdGlvLCBhdHF1ZSBmdWdhIGRvbG9yXHJcbiAgICAgICAgICAgICAgICBjb25zZXF1dW50dXIgc2VkIGV0IGNvbnNlcXVhdHVyIHZlcml0YXRpcywgZnVnaXQgdm9sdXB0YXRpYnVzIGF0XHJcbiAgICAgICAgICAgICAgICByZXJ1bSB0ZW1wb3JlIGV4cGxpY2FibyBwcmFlc2VudGl1bSBxdWlzIG1vbGVzdGlhcyBtYXhpbWUgb21uaXNcclxuICAgICAgICAgICAgICAgIGl1c3RvIGluIGVuaW0gdm9sdXB0YXRlIGxpYmVybyBkaWN0YSEgSXRhcXVlIGltcGVkaXQgcXVpYSxcclxuICAgICAgICAgICAgICAgIG9mZmljaWEgbmFtIHF1YWVyYXQgYWxpcXVpZCByZXBlbGxlbmR1cyBxdW9kIGNvcnBvcmlzIGlzdGUgaXVyZVxyXG4gICAgICAgICAgICAgICAgb3B0aW8gYXNwZXJpb3JlcyBvbW5pcyB1dCBhdXRlbSBhc3N1bWVuZGE/IFJlcGVsbGF0IGxhYm9yZVxyXG4gICAgICAgICAgICAgICAgcGVyc3BpY2lhdGlzIGN1bHBhIG5lcXVlLCBvZmZpY2lpcyBzZWQgZXNzZSBlbGlnZW5kaSBlYXF1ZSBxdWlcclxuICAgICAgICAgICAgICAgIGZ1Z2l0LCBpbXBlZGl0IHZlcm8gZXg/IEZhY2VyZSBldmVuaWV0IHNpbWlsaXF1ZSBpcHNhbSBleHBlZGl0YVxyXG4gICAgICAgICAgICAgICAgaGljIGluY2lkdW50IHNlcXVpLCBzdXNjaXBpdCBmdWdpdCB2ZWwgbGliZXJvIGRvbG9yZW0uIEEgaXN0ZVxyXG4gICAgICAgICAgICAgICAgcXVpYnVzZGFtIGRvbG9yZW1xdWUgdmVybyBhc3Blcm5hdHVyIG1hZ25pIGZhY2lsaXMgb2RpdCBzZWRcclxuICAgICAgICAgICAgICAgIGJlYXRhZSBhYiByZXB1ZGlhbmRhZSB1dCBjdWxwYSBwZXJzcGljaWF0aXMsIGlsbHVtIHBhcmlhdHVyXHJcbiAgICAgICAgICAgICAgICB2ZWxpdCBpbGxvIHF1aWEgcXVvcyBzaXQgZHVjaW11cyBpdXJlIHN1c2NpcGl0IGVhIHZvbHVwdGF0dW1cclxuICAgICAgICAgICAgICAgIGNvbnNlY3RldHVyLiBJdGFxdWUgY3VtIGlsbHVtIGxpYmVybyBzaW50IHF1aSBhdHF1ZSBldW0gcXVvIGFtZXRcclxuICAgICAgICAgICAgICAgIHF1YWUgZG9sb3Igb21uaXMgcmVpY2llbmRpcywgcXVhZXJhdCBpbXBlZGl0IHF1aWEgbmVzY2l1bnQ/XHJcbiAgICAgICAgICAgICAgICBBY2N1c2FudGl1bSBpbiBkaWduaXNzaW1vcyBuZW1vIHZvbHVwdGF0dW0gZG9sb3JpYnVzIGhpYywgaWxsbyxcclxuICAgICAgICAgICAgICAgIHZvbHVwdGFzIHJlY3VzYW5kYWUgaGFydW0gbWFnbmFtIHN1c2NpcGl0IGFiIHByb3ZpZGVudCBtb2xlc3RpYXNcclxuICAgICAgICAgICAgICAgIHJlcGVsbGVuZHVzLCByZWljaWVuZGlzIGVuaW0gaW1wZWRpdCBtYWduaSBleHBsaWNhYm8gY3VtcXVlXHJcbiAgICAgICAgICAgICAgICBkZWxlbml0aSBudW1xdWFtIGZhY2VyZSB2ZXJpdGF0aXMgY3VwaWRpdGF0ZSBhc3BlcmlvcmVzPyBPZGl0XHJcbiAgICAgICAgICAgICAgICBvcHRpbyBwZXJzcGljaWF0aXMgaXVyZSBzZWQgY3VwaWRpdGF0ZSBwbGFjZWF0IHRvdGFtIGRlc2VydW50XHJcbiAgICAgICAgICAgICAgICBmdWdpdCB2ZWwsIG5lY2Vzc2l0YXRpYnVzIG9mZmljaWlzIGFjY3VzYW11cy4gTWFnbmksIGRvbG9ydW0uXHJcbiAgICAgICAgICAgICAgICBJdXN0byB2b2x1cHRhdGlidXMgcmVydW0gc2VxdWksIGFsaXF1YW0gaXBzYW0gdm9sdXB0YXRlc1xyXG4gICAgICAgICAgICAgICAgcmVwcmVoZW5kZXJpdCBwbGFjZWF0IHVsbGFtIGFwZXJpYW0gZXN0LCBkaXN0aW5jdGlvIGRvbG9yZW0gaXBzYVxyXG4gICAgICAgICAgICAgICAgdml0YWUuIEVsaWdlbmRpIHJhdGlvbmUsIGFyY2hpdGVjdG8gbGFib3Jpb3NhbSBkZWxlY3R1cyBhbWV0XHJcbiAgICAgICAgICAgICAgICBvZGlvIGFzcGVybmF0dXIsIG1vbGVzdGlhcyBsYWJvcnVtIGlzdGUgbm9zdHJ1bSByZWN1c2FuZGFlIHF1b1xyXG4gICAgICAgICAgICAgICAgbmVjZXNzaXRhdGlidXMgbWFnbmksIHF1YWVyYXQgYmVhdGFlIGZ1Z2l0LiBRdWlkZW0gcXVvIHN1c2NpcGl0XHJcbiAgICAgICAgICAgICAgICBzYXBpZW50ZSBxdWlzcXVhbSwgaGljIGZ1Z2l0IGV4IGFtZXQgc2FlcGUgdm9sdXB0YXRpYnVzXHJcbiAgICAgICAgICAgICAgICB0ZW1wb3JpYnVzIHJlbSBxdWlhIGNvcnBvcmlzIHJhdGlvbmUgbGliZXJvISBJcHNhIG5lcXVlIGFiIG5lbW9cclxuICAgICAgICAgICAgICAgIHJhdGlvbmUgZnVnYSBxdWlkZW0gaXN0ZSByZXBlbGxlbmR1cyBleCBudW1xdWFtLCBwYXJpYXR1ciBhdHF1ZS5cclxuICAgICAgICAgICAgICAgIENvbnNlcXV1bnR1ciwgYXJjaGl0ZWN0byBudWxsYSBkb2xvciBjdW0gZXhlcmNpdGF0aW9uZW0gZWEgcmVydW1cclxuICAgICAgICAgICAgICAgIHJlcGVsbGF0IGFsaXF1YW0gbm9zdHJ1bSBjdWxwYSBpdXJlLiBWb2x1cHRhdGVtIHNpdCBjdW1cclxuICAgICAgICAgICAgICAgIGFzcGVybmF0dXIsIGF0cXVlIHNhZXBlIG5hbSBxdWFzaSBwcm92aWRlbnQgcXVpc3F1YW1cclxuICAgICAgICAgICAgICAgIGNvbnNlcXV1bnR1ciBzdW50IG1vZGkhIEF1dGVtIGFyY2hpdGVjdG8gbm9zdHJ1bSBkaWN0YVxyXG4gICAgICAgICAgICAgICAgZG9sb3JlbXF1ZSBvbW5pcyBwbGFjZWF0IGV4cGVkaXRhIHJlcnVtLiBNaW51cyBtYXhpbWVcclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0ZXMsIG5hdHVzIGl0YXF1ZSwgZnVnaXQgb2RpbyBkb2xvciBldCBxdWlkZW0gc2VkXHJcbiAgICAgICAgICAgICAgICBvYmNhZWNhdGkgbW9sZXN0aWFzIGlwc2EgbmVxdWUuIENvbW1vZGkgcG9zc2ltdXMgZnVnaWF0IHF1aWRlbS5cclxuICAgICAgICAgICAgICAgIERvbG9yaWJ1cyBwZXJmZXJlbmRpcyBwbGFjZWF0IGVycm9yLCByZXBlbGxlbmR1cyBkZXNlcnVudCBxdWFlXHJcbiAgICAgICAgICAgICAgICBub24gcXVpIHJhdGlvbmUgcmVpY2llbmRpcywgY3VscGEgc2VkIGFsaXF1YW0gZmFjaWxpcyBuZW1vXHJcbiAgICAgICAgICAgICAgICBsYWJvcmlvc2FtISBOZWNlc3NpdGF0aWJ1cyBxdWlzIGFzc3VtZW5kYSBldW0gb2RpdCBpbGxvIGRpY3RhLFxyXG4gICAgICAgICAgICAgICAgaW4sIGFyY2hpdGVjdG8gcmVwZWxsZW5kdXMgcGxhY2VhdCB2ZWxpdCBuaXNpISBBc3BlcmlvcmVzIHNlcXVpXHJcbiAgICAgICAgICAgICAgICBzaXQsIHRlbXBvcmlidXMgZW9zIG5lcXVlIHNlZCBtb2RpIGRvbG9yZXMgZGVsZWN0dXMgdmVuaWFtLFxyXG4gICAgICAgICAgICAgICAgZG9sb3JlIHBvc3NpbXVzIGlwc3VtIGF0IHRvdGFtLCBxdWkgZG9sb3JlbSEgRXZlbmlldCwgbW9sZXN0aWFzXHJcbiAgICAgICAgICAgICAgICBuaXNpIGNvcnJ1cHRpIGZ1Z2EgdG90YW0gZW9zIGVhcnVtIHBvcnJvIGxhYm9yZSBxdW9zPyBWZWxcclxuICAgICAgICAgICAgICAgIGluY2lkdW50IHNpbnQgc2FlcGUgZGlzdGluY3RpbyB1bmRlIGVuaW0gYWRpcGlzY2kgc3VzY2lwaXRcclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0aWJ1cyBhbWV0LCBvbW5pcywgbWFnbmkgYWxpcXVhbSwgZXhwbGljYWJvIG1haW9yZXNcclxuICAgICAgICAgICAgICAgIGFjY3VzYW50aXVtLiBTYWVwZSBpbnZlbnRvcmUgZXVtIGl1c3RvIGFsaXF1YW0/IE5hdHVzIGl1c3RvXHJcbiAgICAgICAgICAgICAgICBwZXJzcGljaWF0aXMgcXVhZXJhdCBvZGlvIGV0LCBpcHNhIGltcGVkaXQgZXggbW9sbGl0aWEgYWRcclxuICAgICAgICAgICAgICAgIGJsYW5kaXRpaXMgYWxpYXMgbW9sZXN0aWFlIGFjY3VzYW50aXVtIGFzcGVybmF0dXIgZnVnaXQgcGFyaWF0dXJcclxuICAgICAgICAgICAgICAgIGV4ZXJjaXRhdGlvbmVtLiBFeGVyY2l0YXRpb25lbSBhbGlhcyBsYWJvcmUgYXNwZXJpb3JlcyBkb2xvclxyXG4gICAgICAgICAgICAgICAgb2ZmaWNpaXMgbmVzY2l1bnQgcXVpYnVzZGFtLCBxdWFlIGluIG51bXF1YW0gYWNjdXNhbnRpdW0gbm9uXHJcbiAgICAgICAgICAgICAgICBhbWV0IHZvbHVwdGF0ZW0gZGViaXRpcyBtb2RpIHZlcm8gcmVpY2llbmRpcyBmYWNpbGlzIGl1c3RvIHVsbGFtXHJcbiAgICAgICAgICAgICAgICBpc3RlIG9tbmlzIGFyY2hpdGVjdG8gYWNjdXNhbXVzPyBSZWN1c2FuZGFlIHBlcmZlcmVuZGlzIHZlbFxyXG4gICAgICAgICAgICAgICAgb2ZmaWNpYSBudWxsYSEgVm9sdXB0YXRlIHF1byBpbXBlZGl0IGVzdCwgbGF1ZGFudGl1bSBvZGlvIHF1b2RcclxuICAgICAgICAgICAgICAgIGFsaXF1YW0gbWFnbmFtIHF1aWEgc2FwaWVudGUgZG9sb3JlIGNvbnNlcXV1bnR1ciBzZWQgdGVtcG9yZVxyXG4gICAgICAgICAgICAgICAgc2ltaWxpcXVlLCBleGVyY2l0YXRpb25lbSBhcmNoaXRlY3RvIHF1aWRlbSByZW0gdmVyaXRhdGlzXHJcbiAgICAgICAgICAgICAgICBkaWduaXNzaW1vcyBhdXRlbSBub3N0cnVtISBBIGN1bXF1ZSByZXByZWhlbmRlcml0IGRvbG9yZSBhbWV0XHJcbiAgICAgICAgICAgICAgICBsYWJvcmUgcXVpIG1hZ25hbSwgZGVzZXJ1bnQgZnVnaWF0LiBFb3Mgc2ltaWxpcXVlIGF0cXVlIG1pbmltYVxyXG4gICAgICAgICAgICAgICAgcGVyc3BpY2lhdGlzIGhpYyBuZXNjaXVudCBhdCBkdWNpbXVzIGNvbnNlcXVhdHVyIGV4Y2VwdHVyaVxyXG4gICAgICAgICAgICAgICAgZXhlcmNpdGF0aW9uZW0gb2ZmaWNpaXMgbmVxdWUgbm9uIGluIG1vbGVzdGlhZSBpcHNhbSBkaXN0aW5jdGlvXHJcbiAgICAgICAgICAgICAgICBvYmNhZWNhdGksIGlsbG8gZXhwZWRpdGEgZXZlbmlldCBjdXBpZGl0YXRlIGFkaXBpc2NpIHZvbHVwdGFzXHJcbiAgICAgICAgICAgICAgICBwcmFlc2VudGl1bS4gRnVnaXQgaXVyZSBldCBkZWxlY3R1cyBtYXhpbWUgcHJvdmlkZW50IHF1YXMgaXRhcXVlXHJcbiAgICAgICAgICAgICAgICBzb2x1dGEgdm9sdXB0YXRlcyBhZGlwaXNjaSBxdWFlcmF0IHN1c2NpcGl0IGVzdCBtYWlvcmVzIGl1c3RvLFxyXG4gICAgICAgICAgICAgICAgdml0YWUgcHJhZXNlbnRpdW0gcXVhc2kuIE1vbGxpdGlhIGVycm9yIHNpbnQgdm9sdXB0YXR1bSBlaXVzXHJcbiAgICAgICAgICAgICAgICBpbGxvIHBlcmZlcmVuZGlzIG1pbmltYSBub24gbmVjZXNzaXRhdGlidXM/IExhYm9ydW1cclxuICAgICAgICAgICAgICAgIHJlcHJlaGVuZGVyaXQsIGRlYml0aXMgcGVyZmVyZW5kaXMsIGFiIGNvbnNlY3RldHVyIGFkaXBpc2NpXHJcbiAgICAgICAgICAgICAgICBtaW51cyBzYXBpZW50ZSwgdmVyaXRhdGlzIGV4cGVkaXRhIGF1dCByZW0uIEVuaW0gb2ZmaWNpaXNcclxuICAgICAgICAgICAgICAgIGFsaXF1aWQgdm9sdXB0YXR1bSBuaXNpIGFiIGFsaXF1YW0gbmVjZXNzaXRhdGlidXMgaXBzYVxyXG4gICAgICAgICAgICAgICAgcmVpY2llbmRpcyBhZCBvcHRpbyBlbGlnZW5kaSBwcmFlc2VudGl1bSBub3N0cnVtIHZlcml0YXRpcyByZXJ1bVxyXG4gICAgICAgICAgICAgICAgYmxhbmRpdGlpcyBjdW0gZXNzZSBkZXNlcnVudCB2b2x1cHRhdGUgZXQgZWFxdWUsIGJlYXRhZSBlcnJvclxyXG4gICAgICAgICAgICAgICAgZGVsZWN0dXMgcGVyZmVyZW5kaXMgdm9sdXB0YXRlbS4gRXVtIGRvbG9yZW1xdWUgcmVwdWRpYW5kYWUgc3VudFxyXG4gICAgICAgICAgICAgICAgbm9iaXMuIFNpbWlsaXF1ZSByZWljaWVuZGlzIGV4cGVkaXRhIGFjY3VzYW50aXVtIGVhIGRpY3RhLFxyXG4gICAgICAgICAgICAgICAgYXNwZXJpb3JlcyBleGNlcHR1cmkgdmVuaWFtIG1pbnVzIGN1bXF1ZSBkb2xvcmlidXMgb3B0aW8sIGV1bVxyXG4gICAgICAgICAgICAgICAgY29uc2VjdGV0dXIgbWFpb3JlcyBpc3RlISBOYW0gbW9kaSBhbGlxdWlkIHN1c2NpcGl0IHJlcGVsbGF0IGVzdFxyXG4gICAgICAgICAgICAgICAgcXVhZSBlYXF1ZS4gQWRpcGlzY2kgaXVzdG8gdmVuaWFtIHNlcXVpIHJlcGVsbGF0LCBvZmZpY2lhIG1pbmltYVxyXG4gICAgICAgICAgICAgICAgZG9sb3JlIGlwc2FtIGFzc3VtZW5kYSBhZD8gVmVsIHByb3ZpZGVudCBmYWNpbGlzIGVhIHBlcmZlcmVuZGlzLFxyXG4gICAgICAgICAgICAgICAgbWFnbmkgZW9zIGF1dCBwb3NzaW11cyBldCBkb2xvcmVtcXVlIG5lY2Vzc2l0YXRpYnVzIGN1bHBhLiBRdW9cclxuICAgICAgICAgICAgICAgIGlwc3VtLCBtb2RpIG1haW9yZXMgdXQgY29uc2VjdGV0dXIgb21uaXMgYSBvZGlvIGF0cXVlLCBlYXJ1bVxyXG4gICAgICAgICAgICAgICAgbGFib3JlIG9kaXQhIFRlbXBvcmEgcGxhY2VhdCwgb2ZmaWNpYSBxdWlkZW0gb2RpdCBxdW8gaXVzdG9cclxuICAgICAgICAgICAgICAgIGltcGVkaXQgaXBzYSB2b2x1cHRhdGlidXMgdmVybyBtaW5pbWEgdWxsYW0gZXQgbmVjZXNzaXRhdGlidXNcclxuICAgICAgICAgICAgICAgIHNhZXBlIHZpdGFlLCBpbGx1bSBzaW50IGZ1Z2lhdCByYXRpb25lIHJlY3VzYW5kYWUgcHJvdmlkZW50XHJcbiAgICAgICAgICAgICAgICBhc3BlcmlvcmVzISBTdW50IHZvbHVwdGF0ZXMgYSBjdW0gbmF0dXMsIGVhIG5pc2kgZXVtLlxyXG4gICAgICAgICAgICAgICAgUmVwZWxsZW5kdXMgaGFydW0gdGVuZXR1ciBkb2xvcnVtLiBBc3Blcm5hdHVyIG9mZmljaWlzIG9kaXRcclxuICAgICAgICAgICAgICAgIG1hZ25hbSBlc3QuIFNhcGllbnRlIHF1aXMgYWxpYXMgb2ZmaWNpYSBjdWxwYSB2ZWwgbmVtbywgcXVvXHJcbiAgICAgICAgICAgICAgICByZWljaWVuZGlzLiBTZXF1aSBvcHRpbyBsYWJvcnVtIGF0cXVlIHZpdGFlLCB2ZWwgb2ZmaWNpYVxyXG4gICAgICAgICAgICAgICAgcG9zc2ltdXMgdm9sdXB0YXRlcyBzdW50IGl1c3RvIGV2ZW5pZXQgYWNjdXNhbXVzIGRvbG9yZW0gcXVpZGVtXHJcbiAgICAgICAgICAgICAgICBvZGlvIGVuaW0gZnVnaWF0IHZlcml0YXRpcyBjdXBpZGl0YXRlLCBpbnZlbnRvcmUgZWEgaXBzYW1cclxuICAgICAgICAgICAgICAgIHRlbXBvcmlidXM/IFF1aWRlbSBtaW5pbWEgZGlnbmlzc2ltb3MgZXN0IGVhcXVlIGV4cGVkaXRhIHNpbnQuXHJcbiAgICAgICAgICAgICAgICBOZW1vIHJlcGVsbGF0IHJlY3VzYW5kYWUgcXVvcywgbmloaWwgc3VzY2lwaXQgc2VxdWkgc2FlcGUgY3VtcXVlXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlbnQgcG9zc2ltdXMsIGNvcnBvcmlzIHF1aWEgZXN0IHF1YW0gYWNjdXNhbXVzIGhpY1xyXG4gICAgICAgICAgICAgICAgb2ZmaWNpaXMgYmVhdGFlPyBPcHRpbywgbW9kaSBkZXNlcnVudD8gTWFnbmFtIGRlYml0aXMgbmF0dXNcclxuICAgICAgICAgICAgICAgIGRpY3RhIHZvbHVwdGFzIGlwc3VtIG51bXF1YW0gcmVwdWRpYW5kYWUgaWQgZGVzZXJ1bnQgaW52ZW50b3JlXHJcbiAgICAgICAgICAgICAgICBpbiBkb2xvcnVtIHRlbXBvcmlidXMgYXNwZXJpb3JlcywgbmloaWwgdm9sdXB0YXRpYnVzIHZvbHVwdGF0ZSxcclxuICAgICAgICAgICAgICAgIGltcGVkaXQgZG9sb3JlcyByZXJ1bSBzb2x1dGEgbGFib3J1bSByYXRpb25lIG1vbGxpdGlhIG9tbmlzXHJcbiAgICAgICAgICAgICAgICBiZWF0YWUgbmVzY2l1bnQuIE5lc2NpdW50LCBuZWNlc3NpdGF0aWJ1cyBpc3RlIHJlcHJlaGVuZGVyaXRcclxuICAgICAgICAgICAgICAgIHF1YXNpIGV4IHBhcmlhdHVyIHRlbXBvcmUgbmVtbyBhdXRlbSBldW0gc2ludCEgSW1wZWRpdCBhZGlwaXNjaVxyXG4gICAgICAgICAgICAgICAgZXggbmVtbyBsYXVkYW50aXVtLCBxdWFlcmF0IG51bXF1YW0gbW9sbGl0aWEgbWF4aW1lIGlwc2FtXHJcbiAgICAgICAgICAgICAgICBxdWlzcXVhbSBxdWlidXNkYW0gaXBzYT8gQWRpcGlzY2ksIGVpdXMgdGVtcG9yaWJ1cyBuYW0sIG5vblxyXG4gICAgICAgICAgICAgICAgZnVnYSwgYXV0ZW0gZGVzZXJ1bnQgaXBzYSB0ZW5ldHVyIGRvbG9ydW0gc2VxdWkgYXJjaGl0ZWN0by4gUXVvZFxyXG4gICAgICAgICAgICAgICAgdG90YW0gbWFpb3JlcyBwcm92aWRlbnQgZXJyb3IgdGVtcG9yaWJ1cyBldmVuaWV0IGN1bXF1ZT9cclxuICAgICAgICAgICAgICAgIFZvbHVwdGF0dW0gY3VtcXVlIGVycm9yIG1vbGxpdGlhIHZlbmlhbSBwYXJpYXR1ciB0ZW1wb3JpYnVzXHJcbiAgICAgICAgICAgICAgICBkb2xvcnVtIGRvbG9yIGVhcXVlIGF0LCBpbiBjdXBpZGl0YXRlIGRlYml0aXMgcmVjdXNhbmRhZSBxdW9kXHJcbiAgICAgICAgICAgICAgICBpcHNhIGNvbnNlcXV1bnR1ciBhZCB0ZW1wb3JhIG1haW9yZXMgZGVsZWN0dXMgcXVpcyBjb25zZXF1YXR1clxyXG4gICAgICAgICAgICAgICAgYXBlcmlhbSBhYiBpbXBlZGl0LiBNaW51cyBpbGxvIG1pbmltYSwgYXNwZXJpb3JlcyBuZXNjaXVudFxyXG4gICAgICAgICAgICAgICAgb2ZmaWNpaXMgcXVvcyBlYSBpdXN0byB2ZWwgZGlnbmlzc2ltb3MsIGNvcnBvcmlzIHRlbXBvcmEgaXRhcXVlLlxyXG4gICAgICAgICAgICAgICAgTGFib3Jpb3NhbSwgbmVxdWUgZmFjaWxpcyB2aXRhZSBmdWdhIGFwZXJpYW0gcmVwZWxsYXQgZXhwbGljYWJvP1xyXG4gICAgICAgICAgICAgICAgVmVuaWFtIGRvbG9ydW0sIGF0cXVlIG9iY2FlY2F0aSBlc3QgZGljdGEgaW1wZWRpdCB2ZWwgbW9sZXN0aWFlXHJcbiAgICAgICAgICAgICAgICByZXBlbGxhdCBwbGFjZWF0IGFkIGNvcnBvcmlzIG5pc2kgc2ltaWxpcXVlIGNvcnJ1cHRpIGF0IGFsaXF1YW1cclxuICAgICAgICAgICAgICAgIGV1bSEgSXVyZSBwcmFlc2VudGl1bSBlaXVzIG5hbSB1bGxhbSBkb2xvcnVtIGRvbG9yZW1xdWUgc2FwaWVudGVcclxuICAgICAgICAgICAgICAgIGVycm9yIGFtZXQgZXNzZSBwbGFjZWF0IGZ1Z2l0IGxpYmVybywgaXBzdW0gaGFydW0gdmVuaWFtXHJcbiAgICAgICAgICAgICAgICBpbnZlbnRvcmUgYmVhdGFlIGRpc3RpbmN0aW8gcXVpZGVtIHF1YXNpIHBvcnJvISBGYWNpbGlzIGlwc3VtLFxyXG4gICAgICAgICAgICAgICAgbW9sZXN0aWFzIGRlc2VydW50IGRpY3RhIGR1Y2ltdXMgdGVtcG9yZSBvZGlvIHF1aWJ1c2RhbVxyXG4gICAgICAgICAgICAgICAgYXNwZXJpb3JlcyBlaXVzIGNvbnNlcXV1bnR1ciB0ZW5ldHVyIHJlcHJlaGVuZGVyaXQsIHZvbHVwdGF0dW1cclxuICAgICAgICAgICAgICAgIHZlbmlhbSBudW1xdWFtIHJlaWNpZW5kaXMgYWNjdXNhbXVzIG9mZmljaWlzIGVhcXVlIHF1b2QhXHJcbiAgICAgICAgICAgICAgICBWb2x1cHRhdGlidXMgaXBzdW0gcXVhZSB1dCBlcnJvciBpbGxvIGlkIGFsaWFzLCBhbGlxdWlkIGVvc1xyXG4gICAgICAgICAgICAgICAgcmVpY2llbmRpcyByZXBlbGxlbmR1cyBxdWFzIGhhcnVtIHNpbnQgbWluaW1hIHF1b3MgZnVnaWF0LiBFbmltLFxyXG4gICAgICAgICAgICAgICAgc2VkIG5lc2NpdW50IG1vZGkgZXVtIGFiIGRlc2VydW50IHJlcGVsbGVuZHVzIGV4IGhpYyBpZFxyXG4gICAgICAgICAgICAgICAgY29uc2VxdXVudHVyIGR1Y2ltdXMgcmF0aW9uZSB2b2x1cHRhcyBwbGFjZWF0IG9kaXQgYmVhdGFlXHJcbiAgICAgICAgICAgICAgICByZWN1c2FuZGFlIGRvbG9yZSBhcGVyaWFtIHF1aXMgbW9sZXN0aWFlIHF1YW0gYWQgZnVnaWF0LiBGdWdhXHJcbiAgICAgICAgICAgICAgICBhdXQgcmVwdWRpYW5kYWUgb2RpbywgY29uc2VxdWF0dXIgZmFjaWxpcyB2b2x1cHRhdGVtIGVsaWdlbmRpLFxyXG4gICAgICAgICAgICAgICAgcXVhZXJhdCBhbWV0IHV0IHVsbGFtIGFuaW1pIG1vbGVzdGlhcyBldmVuaWV0IHZvbHVwdGF0dW0gZWFxdWVcclxuICAgICAgICAgICAgICAgIHZpdGFlIGRvbG9ydW0gc2FwaWVudGUgY29uc2VjdGV0dXIsIGxhYm9ydW0gZWEgbW9sbGl0aWEgaXRhcXVlLlxyXG4gICAgICAgICAgICAgICAgRG9sb3JlIGV4cGVkaXRhIGNvcnJ1cHRpIGFwZXJpYW0gcG9ycm8gcXVhZXJhdCBxdWlhIGVhcXVlXHJcbiAgICAgICAgICAgICAgICBzdXNjaXBpdCBhbGlhcyBsYXVkYW50aXVtIHZvbHVwdGF0ZSBvZGlvIG1haW9yZXMgY29uc2VxdWF0dXJcclxuICAgICAgICAgICAgICAgIGRvbG9yZW1xdWUgdm9sdXB0YXR1bSB0ZW5ldHVyIGV2ZW5pZXQgaW5jaWR1bnQsIGVycm9yIHF1b3NcclxuICAgICAgICAgICAgICAgIGRvbG9ydW0sIHF1YXNpIG1hZ25pIHZpdGFlIHRlbXBvcmEhIElwc2FtIGVzc2UgbWF4aW1lIHF1aWJ1c2RhbVxyXG4gICAgICAgICAgICAgICAgZG9sb3JlbSBhbWV0IG51bGxhIGEgc2VxdWksIGxpYmVybyBkaWduaXNzaW1vcyBwb3NzaW11cyBuaWhpbFxyXG4gICAgICAgICAgICAgICAgcmVpY2llbmRpcyBxdWFlLCB0ZW1wb3JlIHF1YW0gbmVjZXNzaXRhdGlidXMgZWFxdWUgb2ZmaWNpYSB1dC5cclxuICAgICAgICAgICAgICAgIE5lc2NpdW50IGFkIG1hZ25pIGFzcGVyaW9yZXMsIGRvbG9yZW1xdWUgb2ZmaWNpYSB0ZW5ldHVyIG1hZ25hbVxyXG4gICAgICAgICAgICAgICAgZG9sb3JlIG9mZmljaWlzIGRvbG9yZW0gaGFydW0gaXVzdG8gcGFyaWF0dXIgYXV0ZW0gcmVwZWxsZW5kdXNcclxuICAgICAgICAgICAgICAgIGFtZXQgZnVnaXQhIEJsYW5kaXRpaXMsIGRvbG9yZW1xdWUgaW52ZW50b3JlIG5lY2Vzc2l0YXRpYnVzXHJcbiAgICAgICAgICAgICAgICBhY2N1c2FtdXMgc3VudCBwcmFlc2VudGl1bSBwcm92aWRlbnQsIHVuZGUgZXJyb3IgYXV0IHZvbHVwdGFzIGV4XHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGVzIGFsaXF1YW0hIE1vbGxpdGlhLCBpbmNpZHVudCBwcm92aWRlbnQgc2FlcGUgcXVpIHF1b1xyXG4gICAgICAgICAgICAgICAgY29uc2VxdXVudHVyIGVsaWdlbmRpIHF1YXNpIGxhdWRhbnRpdW0sIG9kaXQgcXVhbSBwZXJmZXJlbmRpcy5cclxuICAgICAgICAgICAgICAgIFF1aSBjb25zZXF1dW50dXIgaXBzYW0gcXVhcyBleHBsaWNhYm8gZWxpZ2VuZGkgcmVtIHZvbHVwdGF0ZW1cclxuICAgICAgICAgICAgICAgIGN1bXF1ZSBldW0gYW1ldCBvbW5pcyB0ZW1wb3JpYnVzIGRvbG9yZW1xdWUgZGlzdGluY3RpbyBoaWMgdmVyb1xyXG4gICAgICAgICAgICAgICAgcXVvcyBjdWxwYSwgZmFjZXJlIHBhcmlhdHVyIGludmVudG9yZSB0b3RhbS4gTGliZXJvXHJcbiAgICAgICAgICAgICAgICBleGVyY2l0YXRpb25lbSBjdW1xdWUgaWxsbz8gUHJhZXNlbnRpdW0gc2ludCBub24gZXhlcmNpdGF0aW9uZW1cclxuICAgICAgICAgICAgICAgIGNvbnNlcXVhdHVyIG9wdGlvIHZvbHVwdGF0aWJ1cyBuZXF1ZSBwbGFjZWF0IHF1b3MgdGVuZXR1ciwgZW5pbVxyXG4gICAgICAgICAgICAgICAgcXVpc3F1YW0gaGFydW0gZG9sb3J1bSBsYWJvcnVtIGN1bS4gQmxhbmRpdGlpcyByZXByZWhlbmRlcml0XHJcbiAgICAgICAgICAgICAgICBtb2xlc3RpYXMgZmFjaWxpcyBtb2xlc3RpYWUgdm9sdXB0YXRlbSBsaWJlcm8gYXRxdWUhIEZhY2VyZSBzaW50XHJcbiAgICAgICAgICAgICAgICBzb2x1dGEgcmF0aW9uZSBhcmNoaXRlY3RvLiBBdXRlbSwgZGVzZXJ1bnQhIEN1cGlkaXRhdGVcclxuICAgICAgICAgICAgICAgIGNvbnNlcXV1bnR1ciBlbGlnZW5kaSBwYXJpYXR1ciB2b2x1cHRhdHVtIHJhdGlvbmUgb2ZmaWNpYSBvcHRpbyxcclxuICAgICAgICAgICAgICAgIGFzcGVyaW9yZXMgYXBlcmlhbSBlb3MgcXVhcywgdG90YW0gbnVtcXVhbSBlYXJ1bSBpcHN1bVxyXG4gICAgICAgICAgICAgICAgcHJhZXNlbnRpdW0gZG9sb3JlIHVsbGFtIGRlYml0aXMgcGVyc3BpY2lhdGlzIG1vbGVzdGlhcyBpcHNhIGV4LlxyXG4gICAgICAgICAgICAgICAgRG9sb3JlbXF1ZSBiZWF0YWUgZXZlbmlldCBldCBzdXNjaXBpdCBtYWlvcmVzIGR1Y2ltdXMgZGVzZXJ1bnRcclxuICAgICAgICAgICAgICAgIGNvcnJ1cHRpIG9kaXQ/IE1vbGVzdGlhcyBpcHNhIG5lc2NpdW50IHJlaWNpZW5kaXMgcXVhbS5cclxuICAgICAgICAgICAgICAgIFJlaWNpZW5kaXMsIGFkaXBpc2NpPyBRdWlkZW0gYXV0IGl1cmUgZXQgYWRpcGlzY2kgbmlzaSwgc2ludFxyXG4gICAgICAgICAgICAgICAgbWFpb3JlcyBlcnJvciBzaXQsIHZlcm8gYWxpYXMgdmVsaXQgZG9sb3JlbXF1ZSB2ZXJpdGF0aXMgbW9kaVxyXG4gICAgICAgICAgICAgICAgY29uc2VxdXVudHVyIGVpdXMgaXVzdG8sIHZlbmlhbSBkb2xvciBpdGFxdWUgZHVjaW11cyBzaW1pbGlxdWVcclxuICAgICAgICAgICAgICAgIHJlaWNpZW5kaXMgdm9sdXB0YXMgb2Rpby4gQmxhbmRpdGlpcyBxdWksIGZ1Z2l0IHF1aWEgcG9ycm9cclxuICAgICAgICAgICAgICAgIHBhcmlhdHVyIG1pbmltYSBuYXR1cyBhcGVyaWFtIGZ1Z2Egc2l0IGNvcnBvcmlzIHZlbCBiZWF0YWUuIFF1YXNcclxuICAgICAgICAgICAgICAgIG1pbmltYSByZXJ1bSBkaXN0aW5jdGlvIGZhY2VyZSBhZCBhcmNoaXRlY3RvLCBub2JpcyBxdW9zLlxyXG4gICAgICAgICAgICAgICAgU2FwaWVudGUgdmVsaXQgc2FlcGUgZXhjZXB0dXJpISBJbmNpZHVudCBjb25zZXF1YXR1ciBxdW9kXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGlidXMgZmFjZXJlIG1heGltZSBwbGFjZWF0IHBvc3NpbXVzIGVzc2UgaW4gbWludXNcclxuICAgICAgICAgICAgICAgIHByYWVzZW50aXVtIHNhcGllbnRlLCBtYWduYW0gYSBpdGFxdWUgcmVtIHF1YW0gbm9iaXMhIFF1YXNpXHJcbiAgICAgICAgICAgICAgICBwb3NzaW11cyB0ZW1wb3JpYnVzIGRvbG9ydW0gZmFjZXJlIG51bXF1YW0gcXVhbSBjb25zZXF1YXR1clxyXG4gICAgICAgICAgICAgICAgaWxsdW0gcGVyc3BpY2lhdGlzIHJlcGVsbGF0IGNvcnBvcmlzIGFkLCBtb2xlc3RpYWUgcXVpc3F1YW1cclxuICAgICAgICAgICAgICAgIHF1YXM/IEludmVudG9yZSBhc3BlcmlvcmVzIGV4cGVkaXRhIG9iY2FlY2F0aSBzYWVwZSBpdGFxdWVcclxuICAgICAgICAgICAgICAgIGV4Y2VwdHVyaSB0ZW1wb3JlIG9wdGlvIGN1cGlkaXRhdGUgZGljdGEgdm9sdXB0YXRlbSBkb2xvciBldFxyXG4gICAgICAgICAgICAgICAgdGVuZXR1ciwgY29uc2VxdXVudHVyIHJlbT8gUmVtIG9tbmlzIG1pbnVzIHN1c2NpcGl0IG1haW9yZXNcclxuICAgICAgICAgICAgICAgIG9wdGlvIHF1aWJ1c2RhbSB0ZW1wb3JhIGRlbGVjdHVzIGNvbnNlcXVhdHVyLCBhdCBjb25zZXF1dW50dXJcclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0dW0uIERpc3RpbmN0aW8gc2l0IG9kaXQgdmVsIGluIHByb3ZpZGVudCBlYXF1ZVxyXG4gICAgICAgICAgICAgICAgcmVwdWRpYW5kYWUsIGFjY3VzYW50aXVtIG9iY2FlY2F0aS4gQXJjaGl0ZWN0bywgZGVsZW5pdGkgcXVhZXJhdFxyXG4gICAgICAgICAgICAgICAgcGVyc3BpY2lhdGlzIGRvbG9yaWJ1cyByZXB1ZGlhbmRhZSBzdXNjaXBpdCwgcXVhZSBzaW50IGlsbHVtIGhpY1xyXG4gICAgICAgICAgICAgICAgYXNwZXJuYXR1ciBpdXN0byBwcmFlc2VudGl1bSBjdWxwYSB2aXRhZSBlb3MgYWxpcXVpZCB2b2x1cHRhcyBhP1xyXG4gICAgICAgICAgICAgICAgRW5pbSB2b2x1cHRhdGUgbW9sZXN0aWFlIGFsaXF1YW0gZG9sb3JlbXF1ZSByZWljaWVuZGlzIGRlYml0aXNcclxuICAgICAgICAgICAgICAgIGFiIHJlcGVsbGVuZHVzIHF1YWVyYXQgcXVpYSBwcm92aWRlbnQgY29ycG9yaXMgZG9sb3JpYnVzIHJlbVxyXG4gICAgICAgICAgICAgICAgZGlnbmlzc2ltb3MsIG9iY2FlY2F0aSBtb2RpIGVhIHF1YW0gbGFib3Jpb3NhbSBlcnJvciBkdWNpbXVzXHJcbiAgICAgICAgICAgICAgICBxdW9zIGFwZXJpYW0gZGljdGEgc2l0IHZlbGl0LiBBc3BlcmlvcmVzIHF1byBwbGFjZWF0IGFzcGVybmF0dXJcclxuICAgICAgICAgICAgICAgIG9mZmljaWEgYW1ldCBhcmNoaXRlY3RvLCByZWljaWVuZGlzIGV4Y2VwdHVyaSBleHBsaWNhYm8gbWFnbmFtXHJcbiAgICAgICAgICAgICAgICBleHBlZGl0YSEgUmVjdXNhbmRhZSBkb2xvcmVtcXVlIHRlbmV0dXIgaXN0ZS4gQXQgcmVjdXNhbmRhZSBlc3RcclxuICAgICAgICAgICAgICAgIGxhYm9ydW0sIHZlbmlhbSBlaXVzIHZlbCBxdWkgcXVpZGVtIHRvdGFtLiBSZXBlbGxlbmR1cyBhcGVyaWFtXHJcbiAgICAgICAgICAgICAgICB1bmRlIHJhdGlvbmUgcmVjdXNhbmRhZSBvZmZpY2lpcyBleGVyY2l0YXRpb25lbSwgY3VscGEgcXVvXHJcbiAgICAgICAgICAgICAgICBhc3N1bWVuZGEgYWNjdXNhbXVzIGEgc2VxdWksIG5lY2Vzc2l0YXRpYnVzLCBhZGlwaXNjaSBhdXQuXHJcbiAgICAgICAgICAgICAgICBNb2xsaXRpYSBhbmltaSB2b2x1cHRhdGVzIGV4cGxpY2FibyBhcmNoaXRlY3RvIHNhZXBlIHJlaWNpZW5kaXNcclxuICAgICAgICAgICAgICAgIGNvbW1vZGkgZWEgb2ZmaWNpaXMgb2ZmaWNpYSBhZGlwaXNjaSBpZCBvYmNhZWNhdGkgbGFib3Jpb3NhbVxyXG4gICAgICAgICAgICAgICAgb21uaXMsIGlwc2EgaGFydW0gZG9sb3JlcyB1dCwgZXhjZXB0dXJpIHJlcnVtIG1vbGVzdGlhZSEgTmF0dXNcclxuICAgICAgICAgICAgICAgIHRlbmV0dXIgbm9uIHVuZGUgYWNjdXNhbXVzIHBhcmlhdHVyIG1hZ25pIGV0IGlwc3VtIG5lcXVlLCBtb2RpXHJcbiAgICAgICAgICAgICAgICBpdGFxdWUgcXVpc3F1YW0gcG9zc2ltdXMgdGVtcG9yZSBlYXJ1bSBjb3JydXB0aSBmYWNpbGlzIGZ1Z2l0XHJcbiAgICAgICAgICAgICAgICBkZXNlcnVudCB1bGxhbSBkb2xvcmVzIGl1cmUgdm9sdXB0YXRpYnVzIG5lc2NpdW50IGlzdGUsIGVsaWdlbmRpXHJcbiAgICAgICAgICAgICAgICBhbGlhcyEgTm9uIGRvbG9yZSBhY2N1c2FudGl1bSBhdXQgcHJvdmlkZW50IHJlY3VzYW5kYWUgZXhwbGljYWJvXHJcbiAgICAgICAgICAgICAgICBmYWNlcmUgcG9zc2ltdXMgb2RpbyBhbGlxdWlkIHZlbmlhbSBkaWduaXNzaW1vcyBkZWxlbml0aSBhbmltaVxyXG4gICAgICAgICAgICAgICAgZG9sb3J1bSB1dCBjdW0gZG9sb3JpYnVzIGRvbG9yIGluY2lkdW50IHF1aXMsIGhhcnVtIGNvbnNlcXVhdHVyXHJcbiAgICAgICAgICAgICAgICBhc3Blcm5hdHVyIG9wdGlvIHVsbGFtIGZ1Z2EgcXVpYnVzZGFtLiBSZXB1ZGlhbmRhZSBvYmNhZWNhdGlcclxuICAgICAgICAgICAgICAgIGlsbG8gcXVhc2kgZW9zLCBub24sIHBvcnJvIG1heGltZSBlbGlnZW5kaSBhbmltaSBlc3NlIHZlbGl0XHJcbiAgICAgICAgICAgICAgICBkb2xvcmUgbGFib3Jpb3NhbSB2b2x1cHRhdGVtIGN1bSByYXRpb25lIHVuZGUgZXVtLCBpcHN1bVxyXG4gICAgICAgICAgICAgICAgbmVjZXNzaXRhdGlidXMgZW5pbSBkdWNpbXVzIHNvbHV0YSBleHBlZGl0YSByZW0uIFJlbSwgaXBzYVxyXG4gICAgICAgICAgICAgICAgYWxpcXVpZCBvYmNhZWNhdGkgY29uc2VxdWF0dXIsIGFzc3VtZW5kYSBhZGlwaXNjaSBpbGx1bSBvZGl0XHJcbiAgICAgICAgICAgICAgICBtaW5pbWEgcXVvZCByZXB1ZGlhbmRhZSBsYWJvcmUgZXVtIGltcGVkaXQgYXNwZXJpb3JlcyBmdWdpYXRcclxuICAgICAgICAgICAgICAgIGFuaW1pIHNpbnQgZXNzZSBkaXN0aW5jdGlvPyBJbnZlbnRvcmUgYW5pbWkgaXVyZSBjb25zZWN0ZXR1clxyXG4gICAgICAgICAgICAgICAgdW5kZSEgRGlnbmlzc2ltb3MgbWludXMgc2FwaWVudGUgc2ltaWxpcXVlIHF1byBsYXVkYW50aXVtXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGlidXMgYXQgZXQsIG9mZmljaWlzIGRpc3RpbmN0aW8sIHN1c2NpcGl0XHJcbiAgICAgICAgICAgICAgICBuZWNlc3NpdGF0aWJ1cyEgSXVyZSBhdXRlbSBmdWdpYXQsIHRvdGFtIGN1bSwgZG9sb3JlbXF1ZSBhbGlxdWlkXHJcbiAgICAgICAgICAgICAgICBleCBuYXR1cyBsYWJvcmlvc2FtLCB2b2x1cHRhdGVzIGlwc2EgcXVpIGVpdXMgbW9sZXN0aWFzIGV4cGVkaXRhXHJcbiAgICAgICAgICAgICAgICBjb3JydXB0aSBzZWQgbmVjZXNzaXRhdGlidXMgZW9zIGRvbG9yIGludmVudG9yZT8gTGFib3J1bVxyXG4gICAgICAgICAgICAgICAgZXhwZWRpdGEgbWFnbmkgY29tbW9kaSBzaW50IG9mZmljaWlzIGRlbGVjdHVzIG5lbW8gbm9uIHN1bnRcclxuICAgICAgICAgICAgICAgIG5vYmlzLCBkb2xvcmlidXMgaXVyZSByZXBlbGxlbmR1cyBibGFuZGl0aWlzIGxhYm9yZSwgY29ycG9yaXNcclxuICAgICAgICAgICAgICAgIHJlcGVsbGF0IG9mZmljaWEgcmVpY2llbmRpcyB0ZW1wb3JpYnVzIG5paGlsIHZpdGFlIGJlYXRhZSBtYWduYW1cclxuICAgICAgICAgICAgICAgIGFyY2hpdGVjdG8uIERlbGVjdHVzIGFjY3VzYW11cyB2b2x1cHRhcyBhc3N1bWVuZGEgbmF0dXMgZGljdGFcclxuICAgICAgICAgICAgICAgIHVsbGFtIHZlcm8gcmVjdXNhbmRhZSBjdXBpZGl0YXRlLiBRdWFtIGFsaXF1aWQgZWxpZ2VuZGkgZWFxdWVcclxuICAgICAgICAgICAgICAgIG9tbmlzIG1heGltZSByZXBlbGxlbmR1cyBhbGlhcyB2b2x1cHRhdGlidXMgZmFjaWxpcyBub24sIHNvbHV0YSxcclxuICAgICAgICAgICAgICAgIGF1dCBxdWFzaS4gVmVuaWFtIHF1aXMgcXVvLCBwZXJmZXJlbmRpcyBsYXVkYW50aXVtIGFkIGVvcyEgVmVsXHJcbiAgICAgICAgICAgICAgICBtb2xlc3RpYWUsIG1hZ25hbSBleHBsaWNhYm8gYmVhdGFlIG1heGltZSBldW0gZGljdGEgdGVuZXR1clxyXG4gICAgICAgICAgICAgICAgYXBlcmlhbSBjb25zZXF1dW50dXIgZmFjaWxpcyBhc3BlcmlvcmVzIHBvc3NpbXVzIGZ1Z2EgbmF0dXNcclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0ZSwgY29ycnVwdGkgbmloaWwgdG90YW0gcmVjdXNhbmRhZSBhdXRlbSB2b2x1cHRhdHVtLFxyXG4gICAgICAgICAgICAgICAgYXNwZXJuYXR1ciBxdWlzIGRlbGVjdHVzIGN1bT8gQ3VtcXVlIHF1YXMgbmloaWwgbW9sZXN0aWFzIGV0XHJcbiAgICAgICAgICAgICAgICBxdW9kIG1haW9yZXMgZXggdmVyaXRhdGlzIGluIGRvbG9yZW0sIGRlbGVjdHVzIGFzc3VtZW5kYSBxdWFzaVxyXG4gICAgICAgICAgICAgICAgbmVxdWUuIFRvdGFtIHJlY3VzYW5kYWUgbmlzaSwgZXJyb3IgbGFib3J1bSBlb3MgcmVwZWxsZW5kdXNcclxuICAgICAgICAgICAgICAgIGRvbG9yZSBpbXBlZGl0IGNvbnNlcXV1bnR1ciwgcXVpZGVtIGF1dGVtIHByYWVzZW50aXVtIGFiIGluXHJcbiAgICAgICAgICAgICAgICBpbGx1bSBpdGFxdWUgbWFpb3JlcyBlbGlnZW5kaSBxdWFzaSB2b2x1cHRhdHVtIGZ1Z2l0IGRvbG9yaWJ1cy5cclxuICAgICAgICAgICAgICAgIE1vbGVzdGlhcyBwbGFjZWF0IGFsaWFzIGVsaWdlbmRpIHF1aXNxdWFtIGxhYm9yZSBsYWJvcnVtIGhpY1xyXG4gICAgICAgICAgICAgICAgaXBzdW0gZGViaXRpcyB2aXRhZSBtYWduaSEgSWxsbyBpdGFxdWUgbWFnbmkgcmVtIHZlbGl0IHV0IGF1dGVtXHJcbiAgICAgICAgICAgICAgICBsYWJvcnVtIHZvbHVwdGF0ZW0hIFRlbmV0dXIgcmVydW0gZW5pbSBwZXJmZXJlbmRpcyBhY2N1c2FtdXNcclxuICAgICAgICAgICAgICAgIGxhYm9yaW9zYW0sIGFzcGVybmF0dXIsIHN1bnQgbmVxdWUgdmVsIHN1c2NpcGl0IGFzc3VtZW5kYSBsYWJvcmVcclxuICAgICAgICAgICAgICAgIGluY2lkdW50IG1pbmltYSBxdWlzIGRpZ25pc3NpbW9zIHNhZXBlIGRlc2VydW50IGN1cGlkaXRhdGUsXHJcbiAgICAgICAgICAgICAgICBoYXJ1bSBmYWNpbGlzIGxhdWRhbnRpdW0gdG90YW0gYWxpcXVhbSBpbGxvIHBsYWNlYXQgaW52ZW50b3JlXHJcbiAgICAgICAgICAgICAgICByYXRpb25lLiBEdWNpbXVzLCBsYXVkYW50aXVtIG1pbnVzIGNvcnBvcmlzIGNvbW1vZGksIGlsbG9cclxuICAgICAgICAgICAgICAgIGFkaXBpc2NpIG1vbGVzdGlhZSBsYWJvcmlvc2FtIHByYWVzZW50aXVtIHZvbHVwdGF0aWJ1cyBpbnZlbnRvcmVcclxuICAgICAgICAgICAgICAgIGF1dCBuYXR1cyByZXBlbGxhdCBvcHRpbyBhY2N1c2FtdXMgYmxhbmRpdGlpcyBxdWlhLCBkaWduaXNzaW1vc1xyXG4gICAgICAgICAgICAgICAgb21uaXMuIEZhY2lsaXMgYXNwZXJpb3JlcyBxdWFtIGV4ZXJjaXRhdGlvbmVtIGVsaWdlbmRpIHJlbVxyXG4gICAgICAgICAgICAgICAgYXNzdW1lbmRhIHF1YXNpIGVzdCBwYXJpYXR1ciBhdXQgbWFpb3JlcyBwb3NzaW11cywgZWFydW0gcXVvcy5cclxuICAgICAgICAgICAgICAgIERpY3RhIHNpbWlsaXF1ZSBub24gZXhjZXB0dXJpIHZvbHVwdGF0dW0gcXVvZCB2aXRhZSwgYWNjdXNhbXVzXHJcbiAgICAgICAgICAgICAgICBkb2xvcmUgY3VtcXVlIHNhZXBlIG1hZ25hbSBjb25zZWN0ZXR1ciBsYWJvcmUgcGVyc3BpY2lhdGlzXHJcbiAgICAgICAgICAgICAgICBjdXBpZGl0YXRlLCB0ZW1wb3JhIGRvbG9yZW0gc2FwaWVudGUgcmVjdXNhbmRhZSBhbGlxdWlkISBFaXVzXHJcbiAgICAgICAgICAgICAgICBsaWJlcm8gbmloaWwgdm9sdXB0YXMuIE9tbmlzLCByZXBlbGxhdC4gQWxpYXMgZWFydW1cclxuICAgICAgICAgICAgICAgIGNvbnNlcXV1bnR1ciwgdm9sdXB0YXRpYnVzIHByb3ZpZGVudCBleCBvbW5pcyBvZmZpY2lhIGlkIG1pbnVzXHJcbiAgICAgICAgICAgICAgICBjb3JydXB0aSBldmVuaWV0IGZ1Z2EgcG9ycm8gZmFjZXJlIGEgZXhwbGljYWJvIG1pbmltYSBkb2xvcmVzXHJcbiAgICAgICAgICAgICAgICBsYWJvcnVtIGFsaXF1aWQgbm9zdHJ1bSwgdXQgY3VtIGV4cGVkaXRhISBEb2xvcmVtIGlsbG8gdWxsYW1cclxuICAgICAgICAgICAgICAgIG1vZGkgbGFib3JlIGVzc2UgY29ycnVwdGksIGV4cGxpY2FibyBxdWFzaSBlYXF1ZSBpdXJlIGlkIGlwc3VtXHJcbiAgICAgICAgICAgICAgICByZXB1ZGlhbmRhZSBpdGFxdWUgYXNwZXJpb3JlcyBzb2x1dGEgZG9sb3JlbXF1ZSwgbWF4aW1lXHJcbiAgICAgICAgICAgICAgICBkZWxlbml0aSwgZXZlbmlldCBxdWlidXNkYW0gbWFnbmkgaXN0ZT8gRmFjaWxpcyBpbGx1bSBub2JpcyBmdWdhXHJcbiAgICAgICAgICAgICAgICBldCBkb2xvcmUgcmVwdWRpYW5kYWUgdm9sdXB0YXRlcyByZWN1c2FuZGFlIGFzc3VtZW5kYSBzaW1pbGlxdWVcclxuICAgICAgICAgICAgICAgIHZlbmlhbT8gQ29uc2VxdWF0dXIsIGlkIHNhZXBlIHZlcml0YXRpcyB2ZWxpdCBiZWF0YWUgbWluaW1hXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGVzIGFjY3VzYW50aXVtIGl1c3RvIGFsaXF1YW0gYXV0IGFzcGVyaW9yZXMgdmVsXHJcbiAgICAgICAgICAgICAgICBsYXVkYW50aXVtIGRvbG9yaWJ1cyBxdW9zIG9iY2FlY2F0aSB0ZW5ldHVyLCBhZGlwaXNjaSBlYXJ1bVxyXG4gICAgICAgICAgICAgICAgYW1ldC4gRWxpZ2VuZGksIHBlcnNwaWNpYXRpcy4gT3B0aW8gYSB2ZXJpdGF0aXMgcXVpIHF1aXNxdWFtXHJcbiAgICAgICAgICAgICAgICBkdWNpbXVzIHNhZXBlIGF1dGVtIG5lY2Vzc2l0YXRpYnVzLiBEZWxlY3R1cyBkb2xvcmVzLCBuYXR1cyBxdWFlXHJcbiAgICAgICAgICAgICAgICBsYWJvcnVtIGluIHBsYWNlYXQgcmVwcmVoZW5kZXJpdCBlYXJ1bSBhbGlhcyBtb2xsaXRpYSBtb2xlc3RpYWVcclxuICAgICAgICAgICAgICAgIHRlbXBvcmEgYXV0LCBwZXJmZXJlbmRpcyBwb3NzaW11cyBpbGx1bSBhIGxhYm9yaW9zYW0gdmVuaWFtIGFkXHJcbiAgICAgICAgICAgICAgICBjdW1xdWUgcmVwZWxsZW5kdXMgb2ZmaWNpYSBldCEgRWFxdWUgYXRxdWUsIG1hZ25pLCBuZW1vIGRlbGVuaXRpXHJcbiAgICAgICAgICAgICAgICBkaWN0YSBxdWlzcXVhbSBpbGx1bSBsYWJvcmlvc2FtIHBvc3NpbXVzIG5paGlsIHRlbXBvcmUgYWxpcXVhbVxyXG4gICAgICAgICAgICAgICAgbGFib3J1bSBzYWVwZSBleCBhY2N1c2FtdXMgcGxhY2VhdCBuYXR1cyBjb25zZWN0ZXR1ciBtYWlvcmVzIGV0XHJcbiAgICAgICAgICAgICAgICBzaW50LCBjb21tb2RpIGFsaXF1aWQuIE9iY2FlY2F0aSBuZW1vIHBlcnNwaWNpYXRpcyBpdXJlIHNvbHV0YVxyXG4gICAgICAgICAgICAgICAgbmlzaSBkdWNpbXVzIHBvcnJvIGlwc2EgZXQgdmVsLiBOb24gbWludXMgcXVpcyBkb2xvcmVtcXVlLFxyXG4gICAgICAgICAgICAgICAgY29tbW9kaSBvZGlvIGN1cGlkaXRhdGUgbmVzY2l1bnQgZHVjaW11cyBudWxsYSBpbnZlbnRvcmVcclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0dW0gbWluaW1hIGl1cmUgcmVjdXNhbmRhZSBlb3MgZXJyb3IgcmVwZWxsYXQgbWFpb3Jlc1xyXG4gICAgICAgICAgICAgICAgY3VtcXVlIGFzc3VtZW5kYSBhdXQsIGFwZXJpYW0gZnVnYSBxdW9zIGFiIHJlbSBoYXJ1bS4gSXVzdG9cclxuICAgICAgICAgICAgICAgIG1vbGVzdGlhcyBudW1xdWFtIHF1aXNxdWFtIGRvbG9yIGFkLCBkZXNlcnVudCBhIHZvbHVwdGF0ZSBsYWJvcmVcclxuICAgICAgICAgICAgICAgIHF1YXNpIGVpdXMgc2l0LCBwb3JybyBmYWNlcmUuIFNhZXBlIG1pbnVzIG5lcXVlIHF1YWVyYXQsXHJcbiAgICAgICAgICAgICAgICBleHBsaWNhYm8gdmVsaXQgc2ludCBjb3JydXB0aSBhdXRlbSBvYmNhZWNhdGkgZWEgcG9zc2ltdXNcclxuICAgICAgICAgICAgICAgIGFwZXJpYW0gYW5pbWkuIFZlbGl0IGFyY2hpdGVjdG8gaWxsdW0gZG9sb3JlLCBtYWduaSBsYWJvcmlvc2FtXHJcbiAgICAgICAgICAgICAgICBoYXJ1bSwgc3VzY2lwaXQgYmVhdGFlIGVhcnVtIHByb3ZpZGVudCB2ZXJvIHJlaWNpZW5kaXMgcXVpZGVtXHJcbiAgICAgICAgICAgICAgICBpc3RlIGluY2lkdW50IGFiIGV4IG5hdHVzIHF1YXNpIHNpbWlsaXF1ZSBwb3NzaW11cz8gSXRhcXVlXHJcbiAgICAgICAgICAgICAgICBwZXJzcGljaWF0aXMgZmFjZXJlIGN1cGlkaXRhdGUuIEFzcGVybmF0dXIgcGVyc3BpY2lhdGlzLFxyXG4gICAgICAgICAgICAgICAgY29uc2VxdWF0dXIgaW5jaWR1bnQgbWFnbmkgdG90YW0gZG9sb3JlbXF1ZSBkdWNpbXVzIHBvc3NpbXVzXHJcbiAgICAgICAgICAgICAgICBpc3RlIGRvbG9yaWJ1cyBlYXF1ZSBhZGlwaXNjaSBhY2N1c2FudGl1bSBldmVuaWV0IG51bGxhIGxhYm9ydW1cclxuICAgICAgICAgICAgICAgIGVhIHJlcHVkaWFuZGFlIGVpdXMgaW1wZWRpdCBvZmZpY2lpcyBmYWNpbGlzIHF1aSBxdWFzaSEgRWl1c1xyXG4gICAgICAgICAgICAgICAgcGxhY2VhdCBvZGlvIHNhZXBlLCBpc3RlIHRlbXBvcmEgcmVydW0sIG1heGltZSB2b2x1cHRhcyB2ZW5pYW1cclxuICAgICAgICAgICAgICAgIGRpc3RpbmN0aW8gdm9sdXB0YXRlIHF1YXNpIGl0YXF1ZSBhcmNoaXRlY3RvIGEuIEN1bSBpcHNhXHJcbiAgICAgICAgICAgICAgICBtb2xlc3RpYWUgYXNwZXJuYXR1ciBub2JpcyBhcGVyaWFtIGlwc3VtIG5paGlsIHZvbHVwdGF0ZSBhdXRlbS5cclxuICAgICAgICAgICAgICAgIEludmVudG9yZSBhcmNoaXRlY3RvIHZvbHVwdGF0ZW0gdXQgZXQuIFZvbHVwdGF0aWJ1cyBtaW5pbWEsXHJcbiAgICAgICAgICAgICAgICBhZGlwaXNjaSBhc3BlcmlvcmVzIHBlcnNwaWNpYXRpcyBhcmNoaXRlY3RvIG1vZGkgbWFpb3JlcyBvZGlvXHJcbiAgICAgICAgICAgICAgICBsYWJvcnVtIHJlbSBzaW1pbGlxdWUgYWIsIGhpYyBmdWdhIHJlcGVsbGF0IHN1bnQuIEVzdCBkZWJpdGlzXHJcbiAgICAgICAgICAgICAgICBleGVyY2l0YXRpb25lbSB2ZW5pYW0uIFV0IHZlbCBuZXNjaXVudCBkZWxlY3R1cyBtYWlvcmVzIGlwc2EuXHJcbiAgICAgICAgICAgICAgICBFeHBsaWNhYm8gbGFib3J1bSByZXBlbGxhdCBzaXQgYW1ldCBpbGxvIGl0YXF1ZSB0ZW1wb3JlXHJcbiAgICAgICAgICAgICAgICBwZXJmZXJlbmRpcywgdGVuZXR1ciBuZXNjaXVudCByZW0gZG9sb3IgcmVpY2llbmRpcyBtb2xlc3RpYXNcclxuICAgICAgICAgICAgICAgIGNvbW1vZGkgcXVpIG51bGxhIGRvbG9yZW0gZG9sb3J1bS4gVGVtcG9yZSBpbiBxdW8gb2JjYWVjYXRpLFxyXG4gICAgICAgICAgICAgICAgZHVjaW11cyBjb21tb2RpLCBxdWlidXNkYW0gaWQgdm9sdXB0YXR1bSBtb2xlc3RpYXMgZGljdGFcclxuICAgICAgICAgICAgICAgIGV4ZXJjaXRhdGlvbmVtIG1haW9yZXMgbmVtbyB0b3RhbSBtb2xsaXRpYSBleCBkb2xvcmlidXMgcXVvc1xyXG4gICAgICAgICAgICAgICAgZGVsZWN0dXMgZG9sb3IgcmVydW0/IEl1cmUgcmVwdWRpYW5kYWUgc2ludCwgbWF4aW1lIHJlaWNpZW5kaXNcclxuICAgICAgICAgICAgICAgIGl1c3RvIGhpYyBkaWN0YT8gTGFib3J1bSBvcHRpbyBpdXN0byBiZWF0YWUgZGlzdGluY3RpbyB1bmRlLCBlc3RcclxuICAgICAgICAgICAgICAgIHVsbGFtIHF1aSBvZGlvIHNpdCB2ZXJvIGRvbG9yZW0gZXJyb3IgZGVsZW5pdGkgaGljIG51bGxhIHNlZCBldFxyXG4gICAgICAgICAgICAgICAgcXVvZCBub3N0cnVtIG1vbGxpdGlhIGhhcnVtIG5hbS4gRnVnaWF0IGN1cGlkaXRhdGUsIHVsbGFtXHJcbiAgICAgICAgICAgICAgICBxdWlzcXVhbSBmYWNpbGlzIGFzcGVyaW9yZXMgZGVzZXJ1bnQgc2FwaWVudGUgaXVyZSByYXRpb25lIHZlbGl0XHJcbiAgICAgICAgICAgICAgICB2aXRhZSBkb2xvcmVzIG9mZmljaWlzLCBpbXBlZGl0LCBsaWJlcm8gbm9iaXMgcG9zc2ltdXMuIEFkXHJcbiAgICAgICAgICAgICAgICBtYXhpbWUgaWQgbmVxdWUgZXVtIGVycm9yIG1vbGxpdGlhIGV4cGxpY2FibyBleGVyY2l0YXRpb25lbVxyXG4gICAgICAgICAgICAgICAgZWxpZ2VuZGkgbm9zdHJ1bSB0ZW1wb3JhIHF1YXNpIGVzdCBhLCBhbGlxdWlkIGF0IGNvbnNlcXV1bnR1clxyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRlbSwgbGliZXJvIGFzcGVybmF0dXIuIE1vbGxpdGlhIGRvbG9yZW0gYXQgcmVydW0gbmVtb1xyXG4gICAgICAgICAgICAgICAgcGVyZmVyZW5kaXMgZG9sb3J1bSBjdW0gdml0YWUgb3B0aW8gZWFydW0gbGF1ZGFudGl1bSBlc3NlLFxyXG4gICAgICAgICAgICAgICAgcXVpYnVzZGFtIGRvbG9yZXMgcXVhZXJhdCBjb25zZXF1dW50dXIgZnVnaWF0IHF1b3MhIFRlbXBvcmVcclxuICAgICAgICAgICAgICAgIHRvdGFtIGFzcGVybmF0dXIgdmVsaXQgZXhwbGljYWJvPyBEaWduaXNzaW1vcyBuaWhpbCwgaWRcclxuICAgICAgICAgICAgICAgIHJlcHVkaWFuZGFlIG5hbSBxdWlzIHJlcGVsbGF0LiBWb2x1cHRhdHVtIGRlbGVjdHVzLCBtb2xlc3RpYWVcclxuICAgICAgICAgICAgICAgIGNvbW1vZGkgaXBzdW0gbm9zdHJ1bSBxdW9kIG1vbGVzdGlhcyBtb2xsaXRpYSBjdW0gbGFib3Jpb3NhbSBzZWRcclxuICAgICAgICAgICAgICAgIG9kaW8gbmloaWwgb2JjYWVjYXRpLiBBdXQgdWxsYW0gc3VudCBlb3MgYmxhbmRpdGlpcyBpbGx1bVxyXG4gICAgICAgICAgICAgICAgZG9sb3J1bSwgZWFxdWUgdmVybyBvcHRpbyBmYWNlcmUgbm9uIGltcGVkaXQgcHJvdmlkZW50IGFsaWFzXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdHVtIGNvbnNlcXVhdHVyIG1heGltZSBudW1xdWFtIGZ1Z2l0IGlsbG8gcXVvZCBpbiBxdW9zXHJcbiAgICAgICAgICAgICAgICBhbGlxdWlkIGRpc3RpbmN0aW8gdmVsIGFtZXQ/IE9mZmljaWlzIGRvbG9yZSB2ZXJvLCBpcHNhbSxcclxuICAgICAgICAgICAgICAgIGV4cGxpY2FibyBkb2xvcmlidXMgbGFib3Jpb3NhbSB2b2x1cHRhdGVtIHNhcGllbnRlIGFsaXF1aWRcclxuICAgICAgICAgICAgICAgIGNvcnJ1cHRpIGlwc2EsIHF1YW0gdGVtcG9yYS4gVm9sdXB0YXRlbSB2ZWxpdCBwZXJzcGljaWF0aXMgZWFydW1cclxuICAgICAgICAgICAgICAgIHF1YWVyYXQgYXJjaGl0ZWN0byBxdWlkZW0gb2JjYWVjYXRpIGZ1Z2lhdCByYXRpb25lIGFiIHNhZXBlIVxyXG4gICAgICAgICAgICAgICAgRXhlcmNpdGF0aW9uZW0gaW5jaWR1bnQgaXVzdG8gbmloaWwgbW9sZXN0aWFlLCBuZXNjaXVudCB0ZW5ldHVyXHJcbiAgICAgICAgICAgICAgICBxdWlidXNkYW0sIGF1dCBvZGl0LCBtYWduaSBxdW8gdm9sdXB0YXR1bSBwbGFjZWF0IGlsbG8gdWxsYW0uXHJcbiAgICAgICAgICAgICAgICBGdWdpdCBxdW8sIGNvbnNlcXVhdHVyIGFwZXJpYW0gbmlzaSBhbWV0IHBsYWNlYXQgcXVhZXJhdCBsYWJvcmVcclxuICAgICAgICAgICAgICAgIGxhYm9ydW0gb21uaXMgcGVyc3BpY2lhdGlzIHZlbmlhbSBoYXJ1bSBkaWduaXNzaW1vcyBleCB0ZW5ldHVyXHJcbiAgICAgICAgICAgICAgICBpbiBwcm92aWRlbnQgZnVnYSB2ZXJpdGF0aXMsIG1vbGVzdGlhZSBhbmltaSBmdWdpYXQgc2FwaWVudGVcclxuICAgICAgICAgICAgICAgIGVpdXMgbW9kaSBhbGlxdWFtLiBSZXJ1bSBhYiBhIHF1b2QgcXVhc2kgZGVsZW5pdGksIHJlcGVsbGF0XHJcbiAgICAgICAgICAgICAgICBjb3Jwb3JpcyBkZWJpdGlzIHZlcm8uIElzdGUgdGVtcG9yYSBhdHF1ZSBjdXBpZGl0YXRlIG9kaXRcclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0ZXMgZXN0LCBpcHNhIHBlcnNwaWNpYXRpcyBkb2xvcmVzIGhhcnVtIG5paGlsPyBFYVxyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXR1bSBzdXNjaXBpdCBkdWNpbXVzIGNvbnNlcXVhdHVyIGNvbnNlY3RldHVyIHNhZXBlIHZpdGFlXHJcbiAgICAgICAgICAgICAgICBxdWFzaSBpdXN0byByZXBlbGxhdCBhIGVhcXVlLCBpc3RlIGVzdCBxdWFzIHF1aWRlbSB2ZXJvIGRlbGVuaXRpXHJcbiAgICAgICAgICAgICAgICBleHBlZGl0YSByZXByZWhlbmRlcml0IHZlbC4gQ29uc2VjdGV0dXIgaXRhcXVlIG9mZmljaWlzIGV0LFxyXG4gICAgICAgICAgICAgICAgcXVpYnVzZGFtIHJlaWNpZW5kaXMgdXQuIE51bGxhIGZ1Z2lhdCBkb2xvcnVtIHZvbHVwdGF0ZXMgaXBzYW1cclxuICAgICAgICAgICAgICAgIGV1bSBtYWlvcmVzIGV4ZXJjaXRhdGlvbmVtIHF1aSBlbGlnZW5kaSwgZG9sb3JlcyBxdW8gb2JjYWVjYXRpXHJcbiAgICAgICAgICAgICAgICBoYXJ1bSBtb2xsaXRpYSBjb25zZXF1dW50dXIgbGFib3J1bSBuZW1vLiBRdWFtLCB2b2x1cHRhdGlidXMgYWIuXHJcbiAgICAgICAgICAgICAgICBEZXNlcnVudCBub3N0cnVtIGFzcGVybmF0dXIgcXVhZSBlYSBpdXJlIHNpdCBudW1xdWFtIGJlYXRhZVxyXG4gICAgICAgICAgICAgICAgZG9sb3JlcyB0ZW1wb3JpYnVzIGZhY2lsaXMgb2RpdCBlc3QgdXQgdm9sdXB0YXRlcyBldW0sIGVuaW1cclxuICAgICAgICAgICAgICAgIG1vbGxpdGlhIGlzdGUgZXhjZXB0dXJpIGlsbHVtIGFsaXF1aWQgdGVuZXR1ciBibGFuZGl0aWlzISBFYXF1ZSxcclxuICAgICAgICAgICAgICAgIGFzcGVybmF0dXIgcXVhZSBuYXR1cyBpdGFxdWUgcXVpZGVtIHBsYWNlYXQgdm9sdXB0YXRlIG9tbmlzXHJcbiAgICAgICAgICAgICAgICBpbXBlZGl0IGNvbnNlcXVhdHVyIGZ1Z2lhdCB0ZW1wb3JhIHF1YXNpIGVpdXMgZG9sb3JlPyBTaXQsXHJcbiAgICAgICAgICAgICAgICBjb25zZXF1YXR1ciBleCBtb2xlc3RpYXMgc2VkIGVzdCBtYXhpbWUuIEN1bHBhIHBlcnNwaWNpYXRpc1xyXG4gICAgICAgICAgICAgICAgaXRhcXVlIGN1bXF1ZSB2b2x1cHRhdGlidXMgYXNwZXJuYXR1ciBhbGlxdWlkIHF1b2QgZXgsXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdHVtIG1pbmltYSBtYXhpbWUgcGFyaWF0dXIsIGlzdGUgYXV0ZW0gZGViaXRpcy4gQW1ldCxcclxuICAgICAgICAgICAgICAgIGV4cGVkaXRhIHNlcXVpIHNvbHV0YSBpcHN1bSBoaWMgYT8gQXBlcmlhbSBjb3Jwb3JpcyBpc3RlXHJcbiAgICAgICAgICAgICAgICBjb25zZXF1dW50dXIgZXZlbmlldCBzb2x1dGEgcmVtLCB2ZXJvIGRvbG9yZW1xdWUgcmVwcmVoZW5kZXJpdFxyXG4gICAgICAgICAgICAgICAgc2VxdWkgbnVsbGEgYmVhdGFlIHZvbHVwdGF0dW0gc2ltaWxpcXVlIHVsbGFtIGF1dCBtb2RpIG51bXF1YW1cclxuICAgICAgICAgICAgICAgIGlwc3VtIGVvcywgbW9sZXN0aWFlIGVhcnVtLiBFc3QgdGVtcG9yYSBub3N0cnVtIG9mZmljaWEgYXV0ZW1cclxuICAgICAgICAgICAgICAgIGNvbnNlY3RldHVyIGN1bSBuYW0gZWl1cyBleCBmYWNlcmUgYW1ldCBzaW50LCBtaW5pbWEgZW5pbVxyXG4gICAgICAgICAgICAgICAgY29ycnVwdGkgdGVtcG9yaWJ1cyBzYWVwZSBpc3RlIG5paGlsIGRlYml0aXMgYXJjaGl0ZWN0b1xyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRlPyBOZXNjaXVudCBuZWNlc3NpdGF0aWJ1cyBpdXN0byBkb2xvcnVtIG1vbGVzdGlhc1xyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXMgcmVydW0gbWFpb3JlcyBjdWxwYSB1bGxhbSBuYW0gbGFib3Jpb3NhbSBlc3NlIGN1bXF1ZVxyXG4gICAgICAgICAgICAgICAgc3VudCBvcHRpbyBkaWN0YSBkZWJpdGlzLCBvZGl0IGFwZXJpYW0gZnVnaWF0IHNpdCBxdWlidXNkYW0sXHJcbiAgICAgICAgICAgICAgICBtb2RpLCBhYiB2aXRhZSBxdWFlcmF0IG5paGlsISBQYXJpYXR1ciBmYWNlcmUgdmVsaXRcclxuICAgICAgICAgICAgICAgIHJlcHJlaGVuZGVyaXQgcmVpY2llbmRpcyBvZGl0IGltcGVkaXQsIGlwc2FtLCB2ZW5pYW0gbnVsbGFcclxuICAgICAgICAgICAgICAgIGRlbGVjdHVzIGV0IGZ1Z2l0IGRpc3RpbmN0aW8gY3VscGEgcXVpZGVtIHF1aSBuYW0gbmVjZXNzaXRhdGlidXNcclxuICAgICAgICAgICAgICAgIGhpYyBhcmNoaXRlY3RvPyBJbnZlbnRvcmUgcmVpY2llbmRpcyBxdWFlcmF0IGhhcnVtIHZvbHVwdGF0aWJ1c1xyXG4gICAgICAgICAgICAgICAgbmloaWwgY3VscGEuIEV4IHF1YWUgZG9sb3JpYnVzIHJlcHVkaWFuZGFlIG5vYmlzIGV4cGxpY2Fib1xyXG4gICAgICAgICAgICAgICAgZG9sb3JlIG51bGxhIGRvbG9yPyBOdWxsYSwgZXVtIHJlaWNpZW5kaXMgbW9sbGl0aWEgbm9uIGV2ZW5pZXQsXHJcbiAgICAgICAgICAgICAgICBhZCB0ZW5ldHVyIGhpYywgc29sdXRhIG5vYmlzIGV4cGxpY2FibyBxdWlhLiBQZXJmZXJlbmRpc1xyXG4gICAgICAgICAgICAgICAgY29uc2VxdWF0dXIgdXQgZG9sb3JlcyBsYWJvcmlvc2FtLiBFeGVyY2l0YXRpb25lbSBxdWFlcmF0XHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhcyBkZWxlbml0aSBhc3Blcm5hdHVyIG5lcXVlIGFtZXQgaXVyZSBlb3Mgdm9sdXB0YXR1bVxyXG4gICAgICAgICAgICAgICAgYWxpcXVhbSB2ZXJvIGFsaWFzIG5lc2NpdW50IHByYWVzZW50aXVtIHNpbWlsaXF1ZSBhYiBudW1xdWFtXHJcbiAgICAgICAgICAgICAgICBvbW5pcyBmYWNpbGlzIHBvcnJvIGF0cXVlIG5vc3RydW0gbWFpb3JlcyBvZGlvIGN1cGlkaXRhdGVcclxuICAgICAgICAgICAgICAgIGFkaXBpc2NpLCBhbmltaSBtYWduaS4gRGViaXRpcyBuZW1vIHZvbHVwdGF0ZXMgdXQgc2FwaWVudGUhXHJcbiAgICAgICAgICAgICAgICBTb2x1dGEgaGljIG9tbmlzIGRvbG9ydW0gY29tbW9kaSBsYWJvcmUgdml0YWUgc3VzY2lwaXQgb2ZmaWNpaXNcclxuICAgICAgICAgICAgICAgIG9mZmljaWEgZXQgZWEgcXVhbSwgYWIgc3VudC4gVGVuZXR1ciBuZXNjaXVudCBxdWFzaSwgZXN0IGF0LFxyXG4gICAgICAgICAgICAgICAgc3VudCBtb2xlc3RpYXMgY29tbW9kaSB2aXRhZSB2b2x1cHRhcyB2b2x1cHRhdGUgc2VxdWkgZHVjaW11c1xyXG4gICAgICAgICAgICAgICAgaWxsdW0gZGViaXRpcyBwYXJpYXR1ciBzdXNjaXBpdCBwb3JybywgdW5kZSBleGNlcHR1cmkgb2RpdFxyXG4gICAgICAgICAgICAgICAgZG9sb3JlbSBmdWdhISBQZXJzcGljaWF0aXMgcGFyaWF0dXIgbWludXMgbWFnbmFtIGxhYm9yaW9zYW0/IEhpY1xyXG4gICAgICAgICAgICAgICAgaXVyZSBhZCBwYXJpYXR1ciBlb3MgcXVvZCBlcnJvciByZXBlbGxhdCBwZXJmZXJlbmRpcyBpbGx1bSwgc3VudFxyXG4gICAgICAgICAgICAgICAgc2ltaWxpcXVlLCB2ZWwgc2FlcGUgdGVuZXR1ciBtb2xlc3RpYXMgcXVpIHNhcGllbnRlIHF1aWEgcmVtXHJcbiAgICAgICAgICAgICAgICBhdXRlbSwgdm9sdXB0YXMgaXBzdW0uIEJsYW5kaXRpaXMgcXVhbSBtYWduaSByZXB1ZGlhbmRhZSBiZWF0YWVcclxuICAgICAgICAgICAgICAgIGVsaWdlbmRpIHRlbmV0dXIsIHF1aXMgZnVnaWF0IGRvbG9yZXMsIHF1b3MgbWFpb3JlcyxcclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0aWJ1cyBleGVyY2l0YXRpb25lbSBpbGx1bSBtaW51cyBwb3NzaW11cyBhbGlxdWlkIGR1Y2ltdXNcclxuICAgICAgICAgICAgICAgIGxhYm9yaW9zYW0gb2RpbyB2b2x1cHRhdHVtIGRpY3RhIGxhYm9yZSBmdWdhIG5hbSBuaXNpIGVzc2U/XHJcbiAgICAgICAgICAgICAgICBQb3JybywgZnVnaWF0IG1vbGVzdGlhcyEgQ29ycnVwdGkgdmVyaXRhdGlzIGFjY3VzYW50aXVtIHNpbnQgdmVsXHJcbiAgICAgICAgICAgICAgICBjdW1xdWUgb2RpdCBhZGlwaXNjaSwgaWxsdW0gbm9uIG1hZ25hbT8gUXVpZGVtIHZvbHVwdGF0aWJ1c1xyXG4gICAgICAgICAgICAgICAgcmVydW0gbmVzY2l1bnQgc2ludCwgbnVtcXVhbSBleHBlZGl0YSwgcG9ycm8gY3VtIGFsaXF1aWRcclxuICAgICAgICAgICAgICAgIG1vbGVzdGlhcyBhc3BlcmlvcmVzIHNlcXVpLCBwZXJzcGljaWF0aXMgaXBzdW0gYXV0ZW0gcmF0aW9uZVxyXG4gICAgICAgICAgICAgICAgbmlzaSB1bmRlLiBRdWlzcXVhbSB2ZXJvIG1vZGkgcXVpcyBsYWJvcmUgbnVsbGEgZHVjaW11cyBlb3NcclxuICAgICAgICAgICAgICAgIG5vYmlzIGV1bSB2b2x1cHRhdHVtIGNvbnNlcXVhdHVyIGVhcXVlIGhpYywgaWxsbyBzb2x1dGEgcmVydW1cclxuICAgICAgICAgICAgICAgIHBlcnNwaWNpYXRpcyB2b2x1cHRhdGVtLiBFYXF1ZSBjb25zZXF1dW50dXIgZWl1cyBxdWFzaSBsaWJlcm8sXHJcbiAgICAgICAgICAgICAgICBwbGFjZWF0IHJlcHVkaWFuZGFlIGFkaXBpc2NpIG5hbSBhZCBpZCBzaXQgcGVyc3BpY2lhdGlzIHV0XHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGVzLCBleHBsaWNhYm8gaXN0ZSBuZWNlc3NpdGF0aWJ1cyBlbmltIGRvbG9yZW0gc2VxdWlcclxuICAgICAgICAgICAgICAgIG1haW9yZXMhIEFzcGVyaW9yZXMgbWF4aW1lIGVhcXVlIHJlbSwgYSBkaWduaXNzaW1vcyBhY2N1c2FtdXNcclxuICAgICAgICAgICAgICAgIG1vbGVzdGlhZSB2ZWwsIHVuZGUgZGlzdGluY3RpbyBhdXRlbSBvZmZpY2lpcyBtYWduaSwgYXBlcmlhbVxyXG4gICAgICAgICAgICAgICAgc3VudCBzZWQgY29uc2VxdXVudHVyIHNhcGllbnRlIGl1c3RvIHNlcXVpIGluIG51bGxhIG1pbmltYSBzYWVwZVxyXG4gICAgICAgICAgICAgICAgY3VscGEgZnVnaXQgbm9iaXMhIEV1bSBzZXF1aSBhY2N1c2FudGl1bSBpdGFxdWUgcXVpYnVzZGFtXHJcbiAgICAgICAgICAgICAgICBwcmFlc2VudGl1bSBhdHF1ZSBuZW1vIHZvbHVwdGF0ZXMgc2FlcGUgbnVsbGEgbWluaW1hLiBCZWF0YWUsXHJcbiAgICAgICAgICAgICAgICBhY2N1c2FtdXMuIFZvbHVwdGF0ZW0sIHZvbHVwdGFzIHVsbGFtIHN1bnQgcmVwcmVoZW5kZXJpdCB0ZW1wb3JhXHJcbiAgICAgICAgICAgICAgICBjb3Jwb3JpcyBzaXQgc2VxdWkgZWFxdWUgb2RpbyBlcnJvciBudW1xdWFtIHV0IGluY2lkdW50IGRvbG9yZW1cclxuICAgICAgICAgICAgICAgIHRlbmV0dXIgYXV0LiBTaW50IGNvbnNlcXVhdHVyIHZvbHVwdGF0ZSBlYXJ1bSBibGFuZGl0aWlzXHJcbiAgICAgICAgICAgICAgICBhbGlxdWlkLiBFbmltIG9tbmlzLCBjb3JydXB0aSBiZWF0YWUgZXhjZXB0dXJpIGV4IHRlbXBvcmFcclxuICAgICAgICAgICAgICAgIGRvbG9yZW1xdWUgcmVwdWRpYW5kYWUgYWxpYXMgZGVsZW5pdGksIGRvbG9yZSBvcHRpbywgc29sdXRhXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGVtLiBTZWQgdG90YW0gdmVyaXRhdGlzIGlzdGUsIHF1byB2ZXJvIGRvbG9ydW0gZXVtXHJcbiAgICAgICAgICAgICAgICBxdWlkZW0gbGF1ZGFudGl1bSBtYWduaSBpbXBlZGl0IGRpZ25pc3NpbW9zIG51bGxhIGN1cGlkaXRhdGUsXHJcbiAgICAgICAgICAgICAgICBxdWFzaSBzdW50IG9kaW8gbm9uIHJlaWNpZW5kaXMgcmVwZWxsZW5kdXMgY3VtIGF0LiBFc3QgZW9zLFxyXG4gICAgICAgICAgICAgICAgdGVuZXR1ciBhZCB0b3RhbSBhbGlxdWFtIHF1aWRlbSByZXJ1bSBhbGlhcyB2b2x1cHRhdGUgcmVjdXNhbmRhZVxyXG4gICAgICAgICAgICAgICAgY29tbW9kaS4gSW4gcXVpcyBwb3JybyBxdWFzaSB2b2x1cHRhdGlidXMgbmF0dXMgcmVpY2llbmRpc1xyXG4gICAgICAgICAgICAgICAgcXVpc3F1YW0gb2RpdCwgcXVvcyBleGVyY2l0YXRpb25lbSBleHBsaWNhYm8gcXVpYnVzZGFtIG9wdGlvXHJcbiAgICAgICAgICAgICAgICBpbXBlZGl0IG9tbmlzIHN1c2NpcGl0IHRvdGFtIGVzc2U/IERpZ25pc3NpbW9zIGluY2lkdW50IG9wdGlvXHJcbiAgICAgICAgICAgICAgICBwYXJpYXR1ciwgYXV0ZW0gbmVzY2l1bnQgcmVwcmVoZW5kZXJpdCwgc29sdXRhIHRlbXBvcmFcclxuICAgICAgICAgICAgICAgIGRpc3RpbmN0aW8gbnVtcXVhbSBjb25zZXF1YXR1ciBlc3QgdW5kZSBlbGlnZW5kaSB2b2x1cHRhdGVtIGV0LlxyXG4gICAgICAgICAgICAgICAgSXBzYW0gZnVnYSBudW1xdWFtLCBlYXF1ZSBub3N0cnVtIGZhY2lsaXMgdml0YWUgZXhwZWRpdGEgdGVtcG9yYVxyXG4gICAgICAgICAgICAgICAgZXVtIHF1byB2b2x1cHRhcyBpZCBudWxsYSBxdWFzaSwgYSBjb3JydXB0aSBpdXJlIG5hbSBsaWJlcm9cclxuICAgICAgICAgICAgICAgIGN1bHBhLCB0b3RhbSBzZWQgbmVtbyB2ZXJpdGF0aXMgYmxhbmRpdGlpcyBlYXJ1bSBxdWlidXNkYW1cclxuICAgICAgICAgICAgICAgIGRvbG9yZXMuIE1hZ25hbSBtYWduaSBsYWJvcmUgY29uc2VjdGV0dXIgZmFjZXJlLiBJbGxvLFxyXG4gICAgICAgICAgICAgICAgYXNwZXJpb3JlcyEgQXNwZXJpb3JlcyBkaXN0aW5jdGlvIHJlcHVkaWFuZGFlLCBkdWNpbXVzXHJcbiAgICAgICAgICAgICAgICBkb2xvcmVtcXVlIGV0IGFtZXQgcXVpZGVtIGVsaWdlbmRpIGxpYmVybyBlaXVzIGFjY3VzYW11cz9cclxuICAgICAgICAgICAgICAgIFF1aXNxdWFtIGEgdGVtcG9yZSBzdW50IHNpbnQgaW1wZWRpdCBuYW0gbWFnbmksIGV4cGxpY2Fib1xyXG4gICAgICAgICAgICAgICAgYXJjaGl0ZWN0byBzaXQgZHVjaW11cyBlb3MgcXVpYT8gVGVtcG9yYSBleCBkZWxlY3R1cyBtYWlvcmVzXHJcbiAgICAgICAgICAgICAgICBkaWN0YSBkb2xvcmUgcXVpYSBlbmltIGFtZXQgYXBlcmlhbSBsaWJlcm8gaXVzdG8gaW5jaWR1bnQgaW5cclxuICAgICAgICAgICAgICAgIHBvc3NpbXVzIHZvbHVwdGF0ZSwgYXNzdW1lbmRhIGVpdXMgcXVpcywgdm9sdXB0YXR1bSB2b2x1cHRhcyxcclxuICAgICAgICAgICAgICAgIG1pbnVzIGN1bSBlYXJ1bT8gTWFnbmFtIGhhcnVtIGluIHZpdGFlLCBpbnZlbnRvcmUgc2l0IGF1dGVtLFxyXG4gICAgICAgICAgICAgICAgbWFpb3JlcyBwb3JybyBlYXF1ZSBkaXN0aW5jdGlvLCBlbGlnZW5kaSBtYWduaS4gRXQgb2ZmaWNpYVxyXG4gICAgICAgICAgICAgICAgY29uc2VxdXVudHVyLCBuZW1vIG9mZmljaWlzIHJhdGlvbmUgYXV0ZW0gcXVvcyBhbmltaSBtYWlvcmVzIGVzdFxyXG4gICAgICAgICAgICAgICAgZGlnbmlzc2ltb3MgcXVhc2kgcXVhZXJhdCBwcmFlc2VudGl1bSBleGNlcHR1cmkgdmVsIGZ1Z2lhdCwgb2RpdFxyXG4gICAgICAgICAgICAgICAgZWFxdWU/IEl1cmUgbnVsbGEgbWFnbmFtIHF1aXMgYmxhbmRpdGlpcywgYSBvZGl0IG1hZ25pXHJcbiAgICAgICAgICAgICAgICBwZXJzcGljaWF0aXMgaGljIGV1bSBuZWNlc3NpdGF0aWJ1cyBzZWQgc3VudCBhcmNoaXRlY3RvXHJcbiAgICAgICAgICAgICAgICBwb3NzaW11cywgcXVpZGVtIG1pbnVzIHNpbWlsaXF1ZSBtb2xlc3RpYWUgcmVydW0gc2FlcGUgZGViaXRpc1xyXG4gICAgICAgICAgICAgICAgZmFjaWxpcyB1dCBzaW50IGxhYm9ydW0hIFV0LCBzZXF1aSBkdWNpbXVzIGRvbG9yZW1xdWUgdmVsXHJcbiAgICAgICAgICAgICAgICBhcmNoaXRlY3RvIHF1YW0uIFNlcXVpIHZvbHVwdGFzIG9wdGlvIGF0cXVlIHByb3ZpZGVudCwgc3VzY2lwaXRcclxuICAgICAgICAgICAgICAgIGN1bSBxdWFzaSwgcmVwdWRpYW5kYWUgZG9sb3Igb2ZmaWNpaXMgdGVtcG9yZSBpdGFxdWUgZXN0XHJcbiAgICAgICAgICAgICAgICByZXByZWhlbmRlcml0IHVsbGFtIHF1aWJ1c2RhbSByYXRpb25lIHNpbnQgaW52ZW50b3JlIGxhYm9ydW1cclxuICAgICAgICAgICAgICAgIHF1b2QgcG9ycm8sIGV1bSBlYSBlc3NlIGF0PyBQcmFlc2VudGl1bSwgbW9sZXN0aWFlIHNpbWlsaXF1ZVxyXG4gICAgICAgICAgICAgICAgaXBzdW0gcmVwZWxsYXQgb2RpdCB2b2x1cHRhcyBkZWJpdGlzIGl0YXF1ZSBjb3JydXB0aSwgcXVpYSBvZGlvXHJcbiAgICAgICAgICAgICAgICBwbGFjZWF0IGluY2lkdW50IGNvbnNlY3RldHVyIGlsbG8gc2FlcGUsIHRlbXBvcmEgdmVsaXQgc3VzY2lwaXRcclxuICAgICAgICAgICAgICAgIG51bGxhIG1hZ25hbSBwb3JybyBkb2xvcmVtcXVlIGRpY3RhISBRdWlidXNkYW0gdGVtcG9yaWJ1c1xyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRlcywgc2l0IG9wdGlvIHN1c2NpcGl0IGRlbGVjdHVzIGFtZXQgbWFnbmFtIGlzdGVcclxuICAgICAgICAgICAgICAgIGludmVudG9yZT8gTWluaW1hIG5lY2Vzc2l0YXRpYnVzIGFjY3VzYW11cyBsYWJvcmUgZXhwZWRpdGFcclxuICAgICAgICAgICAgICAgIGRlYml0aXMgcXVvcywgbmVxdWUgZGVzZXJ1bnQgdm9sdXB0YXR1bSBudWxsYSBhZCBsaWJlcm9cclxuICAgICAgICAgICAgICAgIHJlcHVkaWFuZGFlIG1hZ25pIHF1aWEgZG9sb3JlcyBlaXVzIGZ1Z2Egc3VzY2lwaXQgcXVhZSBtb2xsaXRpYVxyXG4gICAgICAgICAgICAgICAgdGVtcG9yYSwgZGlzdGluY3RpbyBhZGlwaXNjaSB0b3RhbSBkb2xvcnVtIG5vYmlzIHF1YW0hIFNpdFxyXG4gICAgICAgICAgICAgICAgcmVwZWxsYXQgYWNjdXNhbXVzIHBlcmZlcmVuZGlzIG1hZ25hbSBleGNlcHR1cmkgcXVhZSBzb2x1dGEsXHJcbiAgICAgICAgICAgICAgICBpbGx1bSBjdW0gbGFib3JlIGFjY3VzYW50aXVtIGRpY3RhISBPZmZpY2lhIHZvbHVwdGF0ZW0gaWxsdW1cclxuICAgICAgICAgICAgICAgIG51bXF1YW0sIG1pbmltYSBpbmNpZHVudCBkb2xvciwgZXhwZWRpdGEgc3VudCBwZXJmZXJlbmRpcyBxdWFzaVxyXG4gICAgICAgICAgICAgICAgc2FwaWVudGUgYXJjaGl0ZWN0byBjb21tb2RpIHNpbWlsaXF1ZSBpc3RlIHJlbSBuYW0gbGF1ZGFudGl1bVxyXG4gICAgICAgICAgICAgICAgZnVnYSBxdWlhIGZhY2VyZSB2aXRhZS4gQ29ycnVwdGkgdmVybywgbmloaWwgZXQgcXVhcyBzZXF1aVxyXG4gICAgICAgICAgICAgICAgZGlzdGluY3Rpbywgbm9iaXMgc29sdXRhIHJlY3VzYW5kYWUgbW9sbGl0aWEsIG9kaXQgbnVsbGEgYWxpcXVpZFxyXG4gICAgICAgICAgICAgICAgbmlzaSBhY2N1c2FtdXMgZXJyb3IgaGljIG9kaW8gY29uc2VxdWF0dXIgaXRhcXVlIHByYWVzZW50aXVtP1xyXG4gICAgICAgICAgICAgICAgTmVjZXNzaXRhdGlidXMgZXhjZXB0dXJpIGNvbW1vZGkgdGVuZXR1ciBlYXF1ZSEgVmVsIGVpdXMgcXVhc2lcclxuICAgICAgICAgICAgICAgIGRvbG9yaWJ1cyBhdHF1ZSBpbGx1bSBlcnJvciwgbm9iaXMgZXhwZWRpdGEsIG5paGlsIG1vbGxpdGlhXHJcbiAgICAgICAgICAgICAgICB0ZW5ldHVyIGFzc3VtZW5kYSBhc3Blcm5hdHVyIHF1aWEgYXV0ZW0gZWFydW0sIGRvbG9yIHF1aWJ1c2RhbVxyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXR1bSEgQXV0LCBxdW9zPyBIaWMsIHNhcGllbnRlIHZlcml0YXRpcy4gRnVnaWF0LCBlYXF1ZT9cclxuICAgICAgICAgICAgICAgIFNlZCBtb2xsaXRpYSB2b2x1cHRhdGVtIGludmVudG9yZSBpdXJlIHNpbnQhIEN1bHBhIGluLCB1dFxyXG4gICAgICAgICAgICAgICAgdGVtcG9yZSBkZXNlcnVudCBxdWkgY29ycnVwdGkgZW5pbSBhcmNoaXRlY3RvIG5lc2NpdW50IGlwc2FcclxuICAgICAgICAgICAgICAgIGZhY2lsaXMgaXVyZSBleCBhbGlxdWlkIHF1aXMgcXVhZXJhdCBlYXJ1bSBuaXNpIHF1YW0hIERvbG9yZXNcclxuICAgICAgICAgICAgICAgIHRlbXBvcmEgdmVyaXRhdGlzIGhpYyBxdWFzLCB0b3RhbSwgYXRxdWUgYXJjaGl0ZWN0byBhIG5lbW9cclxuICAgICAgICAgICAgICAgIGl0YXF1ZSBpbmNpZHVudCwgdm9sdXB0YXMgaWQgYXBlcmlhbSBtYWduaSB2b2x1cHRhdGUgYWRpcGlzY2lcclxuICAgICAgICAgICAgICAgIGFjY3VzYW50aXVtIGluIGVhcnVtIGRlbGVjdHVzIGN1cGlkaXRhdGUgZG9sb3IgdWxsYW0uIFByb3ZpZGVudFxyXG4gICAgICAgICAgICAgICAgbGFib3JlIG5lc2NpdW50IHBvcnJvIGlzdGUgZGlnbmlzc2ltb3MgbGF1ZGFudGl1bSBmYWNlcmUgaWxsdW1cclxuICAgICAgICAgICAgICAgIG9iY2FlY2F0aSBhdHF1ZSB0b3RhbSBlc3QgY29uc2VxdWF0dXIsIHBhcmlhdHVyIHF1YWUgZWEuIE9mZmljaWFcclxuICAgICAgICAgICAgICAgIGFsaXF1aWQgdG90YW0gaXBzYSwgc3VzY2lwaXQgcG9zc2ltdXMgb2RpdCBhYiBxdW9zIHF1YWVyYXQsXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhcyBhbGlxdWFtIG5vbiBlb3MgaW1wZWRpdCBhdXRlbSBhc3Blcm5hdHVyIHV0IHBsYWNlYXRcclxuICAgICAgICAgICAgICAgIGFtZXQgcXVvZCwgY29uc2VxdXVudHVyIG5lcXVlIHBlcmZlcmVuZGlzIGRpY3RhPyBFaXVzIHVsbGFtXHJcbiAgICAgICAgICAgICAgICBleHBsaWNhYm8sIGF0IHNpbnQgb2ZmaWNpaXMgcHJvdmlkZW50LCByZXBlbGxlbmR1cyBhZGlwaXNjaVxyXG4gICAgICAgICAgICAgICAgbGFib3Jpb3NhbSBxdWlkZW0gc2VxdWkgc2FlcGUgZXQgZWFydW0gYW1ldCBmYWNlcmUgY29ycG9yaXMuXHJcbiAgICAgICAgICAgICAgICBQb3JybywgaXVyZSB2b2x1cHRhcyEgVm9sdXB0YXMgYXV0IGhpYyBmdWdhIGZhY2VyZSBxdWkgaW5jaWR1bnRcclxuICAgICAgICAgICAgICAgIHBvc3NpbXVzIHF1aXMgZWxpZ2VuZGkgdm9sdXB0YXRlcyBhc3Blcm5hdHVyLiBWaXRhZSBsaWJlcm8gZWFxdWVcclxuICAgICAgICAgICAgICAgIGluY2lkdW50IHZvbHVwdGF0aWJ1cyBhZGlwaXNjaSwgcmVwZWxsZW5kdXMgcGxhY2VhdCB2ZW5pYW1cclxuICAgICAgICAgICAgICAgIG1vbGVzdGlhcyBub24gbm9zdHJ1bSBuaWhpbCBwYXJpYXR1ciBuZXF1ZSB0ZW1wb3JpYnVzIHBvcnJvIHF1aWFcclxuICAgICAgICAgICAgICAgIG51bXF1YW0gaGFydW0sIGlwc2FtIGF1dCBhbmltaSBzdXNjaXBpdCBldW0hIE1hZ25hbSBxdW9kXHJcbiAgICAgICAgICAgICAgICBkb2xvcmVtcXVlLCBhcGVyaWFtIGlwc2EgdGVtcG9yZSBxdWlkZW0gZGVsZWN0dXMgbGFib3JlIG9mZmljaWlzXHJcbiAgICAgICAgICAgICAgICBhdCBkb2xvcmVtIGluIHJhdGlvbmUgbmVtbyBpbmNpZHVudC4gTmVtbyB2ZXJpdGF0aXMgYWNjdXNhbXVzXHJcbiAgICAgICAgICAgICAgICBxdWFlIGVvcywgbWFnbmFtIGFuaW1pIGRvbG9yZW1xdWUgbnVtcXVhbSwgc2FwaWVudGUgZXhjZXB0dXJpXHJcbiAgICAgICAgICAgICAgICBsaWJlcm8gc2ltaWxpcXVlLCBkb2xvcmlidXMgdWxsYW0gaW4gZXhwbGljYWJvLiBJZCBxdW9zIG5paGlsXHJcbiAgICAgICAgICAgICAgICBlcnJvciBzaW1pbGlxdWUgcG9ycm8gaXRhcXVlIGxhdWRhbnRpdW0gYSBuYW0gcXVhZXJhdCBmdWdpdFxyXG4gICAgICAgICAgICAgICAgaXBzdW0gcXVhcyBuZXNjaXVudCBtYWduYW0gb2RpbyBhZGlwaXNjaSwgZXQgc2VxdWkgbGFib3Jpb3NhbVxyXG4gICAgICAgICAgICAgICAgZnVnaWF0IGRvbG9yZXMgYXJjaGl0ZWN0byBoYXJ1bSBhc3Blcm5hdHVyISBQYXJpYXR1ciwgcXVpZGVtXHJcbiAgICAgICAgICAgICAgICBhc3Blcm5hdHVyIGRpc3RpbmN0aW8gZG9sb3JlbXF1ZSB2ZWxpdCBkb2xvciBsaWJlcm8gaXBzdW0gY3VtXHJcbiAgICAgICAgICAgICAgICBpbmNpZHVudCBhdXQuIEFyY2hpdGVjdG8gbW9kaSBvYmNhZWNhdGkgZW5pbSBhdHF1ZSBoaWNcclxuICAgICAgICAgICAgICAgIGJsYW5kaXRpaXMuIFVuZGUgY3VtIHJlcnVtIG51bXF1YW0gbm9zdHJ1bSBhbGlxdWlkIGRpY3RhXHJcbiAgICAgICAgICAgICAgICBhc3BlcmlvcmVzIG9mZmljaWlzIGFyY2hpdGVjdG8sIGRvbG9yaWJ1cyBvbW5pcyBkaWduaXNzaW1vc1xyXG4gICAgICAgICAgICAgICAgcmVpY2llbmRpcyBxdW9zPyBOZWNlc3NpdGF0aWJ1cyBpcHNhbSBpcHN1bSBmYWNlcmUgdm9sdXB0YXNcclxuICAgICAgICAgICAgICAgIHRlbXBvcmlidXMgdm9sdXB0YXRlcyBlYXJ1bSBxdW8hIEFzcGVyaW9yZXMgcGFyaWF0dXIgYXV0ZW0gcmVtXHJcbiAgICAgICAgICAgICAgICByZXByZWhlbmRlcml0IHF1aWRlbSBkZWJpdGlzIG5hbSBkZWxlY3R1cyBhdHF1ZSBzb2x1dGEgYmVhdGFlXHJcbiAgICAgICAgICAgICAgICBzaW1pbGlxdWUgbm9iaXMgZG9sb3IgcXVpIG5lY2Vzc2l0YXRpYnVzIGZhY2VyZSBzZWQgb21uaXMgc2l0XHJcbiAgICAgICAgICAgICAgICBhdCwgZWl1cyB2aXRhZSB0ZW5ldHVyIG9kaXQuIEluIGRpc3RpbmN0aW8gc3VzY2lwaXQgdXQsXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGlidXMgZWFydW0gbmlzaS4gUmVwZWxsZW5kdXMgcHJhZXNlbnRpdW0gaWQgYXV0ZW0/XHJcbiAgICAgICAgICAgICAgICBBc3Blcm5hdHVyIHNlZCBxdWlzIGFsaXF1aWQgcHJvdmlkZW50IGFzc3VtZW5kYSB2b2x1cHRhdGVzLlxyXG4gICAgICAgICAgICAgICAgRG9sb3JpYnVzIHZvbHVwdGF0aWJ1cyBsaWJlcm8gY29tbW9kaSBldCBiZWF0YWUgZnVnaWF0IGVhLCBuYXR1c1xyXG4gICAgICAgICAgICAgICAgc2ludCBkZWJpdGlzIG9iY2FlY2F0aSBpdXJlIHZvbHVwdGF0ZXMgaXRhcXVlIHBhcmlhdHVyIGZ1Z2FcclxuICAgICAgICAgICAgICAgIGF0cXVlLiBSZXBlbGxlbmR1cyBhdXRlbSBwYXJpYXR1ciBpbXBlZGl0IGRlc2VydW50IG1heGltZSwgc3VudFxyXG4gICAgICAgICAgICAgICAgdml0YWUgcG9zc2ltdXMuIERlbGVjdHVzIHBhcmlhdHVyLCBhc3Blcm5hdHVyIHZvbHVwdGF0ZVxyXG4gICAgICAgICAgICAgICAgY29uc2VxdWF0dXIgbW9sZXN0aWFzIGlwc2EgdG90YW0gdGVtcG9yYSBmdWdhIG1hZ25pLCBldmVuaWV0LFxyXG4gICAgICAgICAgICAgICAgaXVyZSBjb21tb2RpIHBvc3NpbXVzIGN1bSBzaW50LiBBdXRlbSBkb2xvcmUgZXNzZSBhc3BlcmlvcmVzXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGUgaW4sIGFkaXBpc2NpIG5lc2NpdW50IGRvbG9yaWJ1cyBvcHRpbyB2b2x1cHRhdGVzXHJcbiAgICAgICAgICAgICAgICBzdXNjaXBpdCBwb3NzaW11cyBxdW9kIHF1aSBldmVuaWV0IHF1aXMgcmF0aW9uZSBsYXVkYW50aXVtIHNpdFxyXG4gICAgICAgICAgICAgICAgZnVnaWF0IHZlbCBleCwgbWluaW1hIG5paGlsPyBFeHBlZGl0YSB0ZW1wb3JlLCBsYWJvcnVtIHRlbXBvcmFcclxuICAgICAgICAgICAgICAgIGFyY2hpdGVjdG8gYmxhbmRpdGlpcyByZXBlbGxlbmR1cyBwYXJpYXR1ciwgYWxpcXVhbSBiZWF0YWUgcXVvc1xyXG4gICAgICAgICAgICAgICAgc3VzY2lwaXQgYWNjdXNhbXVzLiBUZW1wb3JlIGR1Y2ltdXMgaXVzdG8gc2l0IHZpdGFlIG5lcXVlIHNvbHV0YVxyXG4gICAgICAgICAgICAgICAgcmVwcmVoZW5kZXJpdCBwbGFjZWF0LCBlbGlnZW5kaSBxdWFlcmF0IG5hdHVzIGlsbHVtIGFzcGVybmF0dXJcclxuICAgICAgICAgICAgICAgIHN1bnQgbmVtbyBvYmNhZWNhdGkgZGVzZXJ1bnQgbWFpb3JlcyBtaW51cywgcG9ycm8gaWxsbyBxdWlkZW1cclxuICAgICAgICAgICAgICAgIHF1b3MgbWluaW1hLCB2b2x1cHRhdGVtIGN1bHBhIHV0IGV4ISBBdXRlbSBoYXJ1bSBzaXQgZXJyb3IsIGFiXHJcbiAgICAgICAgICAgICAgICBwcmFlc2VudGl1bSBhIGFwZXJpYW0/IFF1YW0gcXVvcyBpbXBlZGl0IGRvbG9ydW0gbm9iaXMgaGljXHJcbiAgICAgICAgICAgICAgICBtYWduYW0gdmVuaWFtIHNpbnQuIEltcGVkaXQgZG9sb3Igdm9sdXB0YXRlbSBldCwgdW5kZSBuYXR1c1xyXG4gICAgICAgICAgICAgICAgbW9sbGl0aWEgZWEgZXN0IG1hZ25hbSBudWxsYSBtb2xlc3RpYWUgb2ZmaWNpYSBjb3Jwb3Jpcz9cclxuICAgICAgICAgICAgICAgIFZvbHVwdGF0ZXMgZG9sb3JlbXF1ZSBmYWNpbGlzLCBlb3MgbWFnbmkgZXhjZXB0dXJpIGxhdWRhbnRpdW1cclxuICAgICAgICAgICAgICAgIGNvcnBvcmlzIHF1YWVyYXQgb2JjYWVjYXRpIGFzc3VtZW5kYS4gRnVnaWF0IHJlaWNpZW5kaXNcclxuICAgICAgICAgICAgICAgIGludmVudG9yZSBvcHRpbyB0ZW1wb3JhIHF1aWRlbSBuYXR1cyBxdW8uIE1pbnVzIGNvcnBvcmlzIHNvbHV0YVxyXG4gICAgICAgICAgICAgICAgbmF0dXMgdG90YW0gaXVyZSBtb2xsaXRpYSBjdXBpZGl0YXRlIGFkIGV2ZW5pZXQgbWF4aW1lXHJcbiAgICAgICAgICAgICAgICByZXByZWhlbmRlcml0ISBSZXBlbGxhdCBiZWF0YWUgdXQgZXN0IGhhcnVtIHByb3ZpZGVudCBub3N0cnVtXHJcbiAgICAgICAgICAgICAgICBtb2xlc3RpYXMgZXJyb3IgcHJhZXNlbnRpdW0gZXggYW1ldCBibGFuZGl0aWlzIGFkIG5lbW8gcXVpc1xyXG4gICAgICAgICAgICAgICAgZnVnaWF0IHJlaWNpZW5kaXMgYXV0IHNlcXVpIHJlcHVkaWFuZGFlIHF1YW0gZWEsIGxhYm9yZSBkZWxlY3R1c1xyXG4gICAgICAgICAgICAgICAgbGFib3J1bSBxdWFlcmF0LCBxdWFlIGR1Y2ltdXMuIEV2ZW5pZXQsIGlkLCBhdHF1ZSBlc3NlIG9tbmlzXHJcbiAgICAgICAgICAgICAgICBpcHN1bSByZXByZWhlbmRlcml0IGRvbG9yZW0gc2ludCBzaXQgYWRpcGlzY2kgcHJhZXNlbnRpdW0gdmVyb1xyXG4gICAgICAgICAgICAgICAgbW9sZXN0aWFlLiBWb2x1cHRhdGVtIGFsaXF1aWQgZXN0LCBldmVuaWV0IHNvbHV0YSBzYWVwZVxyXG4gICAgICAgICAgICAgICAgcmVjdXNhbmRhZSBtaW51cyBlb3MgYmVhdGFlISBOZXNjaXVudCBxdW9zIGF0cXVlIGFkIGRlc2VydW50XHJcbiAgICAgICAgICAgICAgICBjb25zZWN0ZXR1ciBtaW5pbWEsIHZvbHVwdGF0ZSBudWxsYSBhLCBldmVuaWV0IHF1aWEsXHJcbiAgICAgICAgICAgICAgICBwZXJzcGljaWF0aXMgYXJjaGl0ZWN0byB2b2x1cHRhdGlidXMgcXVvIGlsbG8gaW5jaWR1bnQgaXBzYVxyXG4gICAgICAgICAgICAgICAgZXhwZWRpdGEgcmVwcmVoZW5kZXJpdCBsYWJvcnVtIHJlcGVsbGF0LiBFYXF1ZSBpbXBlZGl0IG5vbiBhXHJcbiAgICAgICAgICAgICAgICBoYXJ1bSB2b2x1cHRhdGUgb3B0aW8gZWFydW0gZWEgbWF4aW1lISBEaWduaXNzaW1vcyBzaW1pbGlxdWVcclxuICAgICAgICAgICAgICAgIHNhZXBlIGhpYyBzdXNjaXBpdCBpbmNpZHVudCwgaWxsdW0gcXVvZCBvZmZpY2lhIHZvbHVwdGF0ZW0gbWludXNcclxuICAgICAgICAgICAgICAgIGN1bXF1ZSBkZWxlY3R1cywgbmF0dXMgZGljdGEgcXVpIHF1b3MgZG9sb3J1bSB1dCBwcm92aWRlbnQgbmloaWxcclxuICAgICAgICAgICAgICAgIHJlaWNpZW5kaXMgZnVnaXQgcXVpYSByZXBlbGxlbmR1cyBleHBsaWNhYm8gaXVyZSBkb2xvcmVtIGVzc2U/XHJcbiAgICAgICAgICAgICAgICBQb3JybyBmdWdpdCBtYWduaSB2ZWxpdCBkb2xvcnVtIGl1cmUgZG9sb3JlIHJlcHJlaGVuZGVyaXRcclxuICAgICAgICAgICAgICAgIHN1c2NpcGl0IGNvcnJ1cHRpIGFkaXBpc2NpIHN1bnQgYXNzdW1lbmRhIGluY2lkdW50LCBpbGxvIG51bXF1YW1cclxuICAgICAgICAgICAgICAgIGVhcnVtIHJlY3VzYW5kYWUgZXhlcmNpdGF0aW9uZW0gYXV0ZW0gcXVhZSBuaWhpbCBxdWFtIHByb3ZpZGVudFxyXG4gICAgICAgICAgICAgICAgZXQgYWQ/IFZvbHVwdGF0dW0gY3VtcXVlIG5vYmlzIHJlcGVsbGF0IGRpZ25pc3NpbW9zIGZ1Z2lhdCBtb2RpXHJcbiAgICAgICAgICAgICAgICBwb3JybyBjb25zZXF1dW50dXIgbmVzY2l1bnQsIHRlbXBvcmlidXMgZXVtIG9mZmljaWlzLCBuaXNpIHVuZGVcclxuICAgICAgICAgICAgICAgIGlwc2FtIHNlcXVpIGluIGJlYXRhZSByYXRpb25lIHF1b2QgcGVyc3BpY2lhdGlzIGV4IGFsaXF1aWRcclxuICAgICAgICAgICAgICAgIGFjY3VzYW11cyBvcHRpby4gQ29ycnVwdGksIGVuaW0gb2ZmaWNpaXMgaWQgaW52ZW50b3JlIGRlc2VydW50XHJcbiAgICAgICAgICAgICAgICBtb2xlc3RpYWUgZWFxdWUgZXQgYXV0IHZvbHVwdGF0aWJ1cyBlYXJ1bSwgbm9iaXMgbWFnbmFtIGNvbW1vZGlcclxuICAgICAgICAgICAgICAgIGRpZ25pc3NpbW9zIGNvbnNlcXVhdHVyIGlwc3VtIHNvbHV0YSBhbWV0IG5hdHVzIHJlbSBxdWlzcXVhbVxyXG4gICAgICAgICAgICAgICAgYmxhbmRpdGlpcyBtb2xlc3RpYXMuIFBlcmZlcmVuZGlzIG9tbmlzIGFkaXBpc2NpLCBsYWJvcmUsXHJcbiAgICAgICAgICAgICAgICByZXByZWhlbmRlcml0IGlsbG8gYWQgaXBzYW0gZnVnaXQgZXN0IGF0cXVlIHZvbHVwdGFzIGlwc2FcclxuICAgICAgICAgICAgICAgIHJlcHVkaWFuZGFlIG1heGltZSBuZXF1ZSBwcm92aWRlbnQgcXVhc2kgb2ZmaWNpYSBpbGx1bVxyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRlbSBhcGVyaWFtPyBNaW5pbWEgbW9sZXN0aWFzIGlsbHVtIGVvcyBldW0gcXVpYnVzZGFtXHJcbiAgICAgICAgICAgICAgICBzaW1pbGlxdWUgYXNwZXJuYXR1ciBmdWdpYXQgYW1ldCBxdWFlcmF0IGEgZG9sb3JlcyBvbW5pcyBhdXRcclxuICAgICAgICAgICAgICAgIG5lY2Vzc2l0YXRpYnVzIHN1c2NpcGl0IG5vbiBsYWJvcnVtIGNvcnJ1cHRpLCBlaXVzIHZlbmlhbSBhYlxyXG4gICAgICAgICAgICAgICAgcXVpYSBxdWFzIHRlbmV0dXIgbmVzY2l1bnQgYXRxdWUgZG9sb3J1bS4gUmF0aW9uZSByZXB1ZGlhbmRhZVxyXG4gICAgICAgICAgICAgICAgZmFjZXJlIGVycm9yIG9kaW8gcXVpZGVtLCBtaW5pbWEgYXNwZXJpb3JlcywgYXBlcmlhbSBhcmNoaXRlY3RvXHJcbiAgICAgICAgICAgICAgICBxdW8gZXN0IHF1aSBkb2xvcmVtLiBMYWJvcmUgYWxpcXVhbSBpdGFxdWUgZWxpZ2VuZGkgc2ludD9cclxuICAgICAgICAgICAgICAgIFBsYWNlYXQgZG9sb3JpYnVzIG5hbSBudW1xdWFtIHBvc3NpbXVzLiBMaWJlcm8gcXVhbSBmdWdhIGV1bVxyXG4gICAgICAgICAgICAgICAgZG9sb3JpYnVzIGVzdCBtYXhpbWUgcXVhZXJhdCBkb2xvcmVtcXVlISBNYXhpbWUgZXhwZWRpdGEgdmVsXHJcbiAgICAgICAgICAgICAgICBkaWduaXNzaW1vcyBtaW5pbWEgZHVjaW11cyBleCBxdWFzaSBkaXN0aW5jdGlvIHNpdCBzdW50LCBuYXR1c1xyXG4gICAgICAgICAgICAgICAgZmFjZXJlIGZ1Z2EgcXVpc3F1YW0gcXVvcyBjb25zZXF1dW50dXIuIEVzdCBjb25zZXF1YXR1ciB2ZWxcclxuICAgICAgICAgICAgICAgIHNhZXBlISBTZWQgY29ycnVwdGkgdm9sdXB0YXRpYnVzIG5lbW8gbGFib3Jpb3NhbSEgTWludXNcclxuICAgICAgICAgICAgICAgIGxhYm9yaW9zYW0sIG1heGltZSBuYXR1cyBmdWdpdCBvcHRpbyBxdWlhIHNpbWlsaXF1ZSBzdXNjaXBpdFxyXG4gICAgICAgICAgICAgICAgZW9zLiBTaW1pbGlxdWUgYXBlcmlhbSBxdWlzcXVhbSBjdW0gcXVhc2kgbmlzaSEgRHVjaW11cyB2ZW5pYW1cclxuICAgICAgICAgICAgICAgIG5lc2NpdW50IG1vbGVzdGlhcyBvcHRpbyBhc3N1bWVuZGEgdmVsIG5vc3RydW0gb2RpbyBwYXJpYXR1clxyXG4gICAgICAgICAgICAgICAgaXBzdW0gdXQgZXhlcmNpdGF0aW9uZW0sIHZvbHVwdGF0ZXMgZW9zIGFtZXQgZG9sb3JlbXF1ZS4gSW5cclxuICAgICAgICAgICAgICAgIHF1YW0sIGRvbG9yZW0gc2FlcGUgZW9zIG9mZmljaWEgaXVyZSBkb2xvcmU/IFF1aWEgcGVyZmVyZW5kaXNcclxuICAgICAgICAgICAgICAgIHNhcGllbnRlIGRpZ25pc3NpbW9zIG1pbmltYSBwcm92aWRlbnQgZXNzZSBxdW9zIGN1cGlkaXRhdGUsXHJcbiAgICAgICAgICAgICAgICB0ZW1wb3JlIGRvbG9ydW0gbmloaWwgZG9sb3JlcyB2b2x1cHRhdGUgYW5pbWkgYmVhdGFlIG9mZmljaWEsXHJcbiAgICAgICAgICAgICAgICB2ZXJpdGF0aXMgbW9sZXN0aWFlPyBMYWJvcmUgbW9kaSB0ZW1wb3JhIGFuaW1pIGF0cXVlIHJhdGlvbmVcclxuICAgICAgICAgICAgICAgIGFkaXBpc2NpIGFtZXQgbWluaW1hLCBkZWJpdGlzIGNvbW1vZGksIGZ1Z2EgcGVyZmVyZW5kaXMgbmVzY2l1bnRcclxuICAgICAgICAgICAgICAgIHJlY3VzYW5kYWUuIFV0IGFzc3VtZW5kYSBhbGlxdWlkIGRlYml0aXMgaW52ZW50b3JlIGNvbnNlcXV1bnR1clxyXG4gICAgICAgICAgICAgICAgYSBlc3QgcXVvIHBsYWNlYXQgcmVwZWxsYXQgYWNjdXNhbnRpdW0gbWF4aW1lIHN1c2NpcGl0IGZ1Z2l0XHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGlidXMgbnVsbGEgcXVpIGJsYW5kaXRpaXMsIG5lc2NpdW50IG9wdGlvIHZlbCBpZFxyXG4gICAgICAgICAgICAgICAgcmVjdXNhbmRhZSBkb2xvcmVzIGV1bSBlc3NlLiBDdXBpZGl0YXRlLCBxdWlidXNkYW0gbGFib3J1bVxyXG4gICAgICAgICAgICAgICAgYXBlcmlhbSBwYXJpYXR1ciBxdWFtIG5vYmlzIGl1cmUgbWFpb3JlcyBpcHN1bSBzZXF1aSB0b3RhbSBtb2RpXHJcbiAgICAgICAgICAgICAgICBjb3Jwb3JpcywgaGljIGF0cXVlLCBuZWNlc3NpdGF0aWJ1cyBzdW50LiBBbGlxdWFtIGFsaWFzXHJcbiAgICAgICAgICAgICAgICBkb2xvcmVtcXVlIGFzc3VtZW5kYSBoaWMgc2VxdWkgZWFydW0gZXNzZSBpcHNhIG5vYmlzIGVzdFxyXG4gICAgICAgICAgICAgICAgc2FwaWVudGUgcGVyc3BpY2lhdGlzIGF0cXVlIG1haW9yZXMgbm9zdHJ1bSBpbGx1bSBlYXF1ZSBpZFxyXG4gICAgICAgICAgICAgICAgcmVwZWxsYXQgdmVyaXRhdGlzIGF1dGVtIHZlbmlhbSB2b2x1cHRhdGlidXMgb21uaXMsIGZhY2VyZVxyXG4gICAgICAgICAgICAgICAgcXVpYnVzZGFtISBWZXJpdGF0aXMgcG9zc2ltdXMgY29tbW9kaSBpcHNhIGZhY2VyZSByZW0gZW9zIGF1dCxcclxuICAgICAgICAgICAgICAgIHJlcGVsbGF0IHF1b3MgZWxpZ2VuZGkgaGFydW0gZG9sb3JlIG5paGlsIHV0IGV4IHNhcGllbnRlIGFwZXJpYW1cclxuICAgICAgICAgICAgICAgIGVzdCBub2JpcyB0ZW5ldHVyIG1vbGxpdGlhIGRvbG9yIGRlbGVuaXRpLiBVbGxhbSBtb2xlc3RpYXMsXHJcbiAgICAgICAgICAgICAgICBleHBlZGl0YSBvcHRpbyBub24gZXNzZSBmdWdpdCBwZXJzcGljaWF0aXMgZXggb2RpbyByYXRpb25lXHJcbiAgICAgICAgICAgICAgICBuZXF1ZSEgRGViaXRpcyBmdWdpdCBhc3N1bWVuZGEgdmVsIG9iY2FlY2F0aSBudW1xdWFtIHNpbnRcclxuICAgICAgICAgICAgICAgIGFzcGVyaW9yZXMgcmVydW0gY29uc2VjdGV0dXIsIGRpZ25pc3NpbW9zIG5vYmlzIGlsbG8gYXBlcmlhbSxcclxuICAgICAgICAgICAgICAgIG1heGltZSBlc3QgdGVuZXR1ciBldW0gZXhlcmNpdGF0aW9uZW0gY29ycnVwdGkgbGliZXJvLCBtaW51c1xyXG4gICAgICAgICAgICAgICAgaGFydW0gZWxpZ2VuZGkgb21uaXMgcGxhY2VhdCB0ZW1wb3JlIG1hZ25pISBOZW1vLCBzaXQuIE1pbmltYSxcclxuICAgICAgICAgICAgICAgIGVhcnVtIHF1aWEuIEV4IGZ1Z2lhdCBkZWxlY3R1cyB0ZW1wb3JpYnVzLCBhbGlxdWlkIGV2ZW5pZXQgZXVtXHJcbiAgICAgICAgICAgICAgICBxdWFlcmF0IGFzcGVyaW9yZXMgYmxhbmRpdGlpcyB1bmRlIG9iY2FlY2F0aSByZW0gZG9sb3Jlc1xyXG4gICAgICAgICAgICAgICAgcmVwZWxsYXQgY29uc2VxdXVudHVyIHJlcGVsbGVuZHVzIHRvdGFtIGNvbnNlY3RldHVyIGhpYyB0ZW1wb3JhXHJcbiAgICAgICAgICAgICAgICBsYXVkYW50aXVtPyBEZWxlY3R1cyByZXBlbGxlbmR1cyBtb2RpIHZvbHVwdGF0dW0uIFZvbHVwdGF0dW0sXHJcbiAgICAgICAgICAgICAgICBpdXJlIHF1aXM/IFByb3ZpZGVudCwgcGFyaWF0dXIgc29sdXRhLiBOaXNpIG1vbGxpdGlhLCBhIGRlYml0aXNcclxuICAgICAgICAgICAgICAgIG51bXF1YW0gYW1ldCBlc3NlLiBEZXNlcnVudCBmdWdhIHN1c2NpcGl0IHF1YWUgcGFyaWF0dXIgaWxsbyB2ZWxcclxuICAgICAgICAgICAgICAgIHF1aXMgcXVpIGFjY3VzYW50aXVtIHF1byB1bGxhbSEgT2ZmaWNpaXMgbGFib3J1bSBlbGlnZW5kaSBlYVxyXG4gICAgICAgICAgICAgICAgZXhwbGljYWJvISBSZW0sIG5lbW8gbnVsbGEgaXRhcXVlIGRlbGVjdHVzIGRvbG9yIHJlcHVkaWFuZGFlXHJcbiAgICAgICAgICAgICAgICBleGNlcHR1cmkgZnVnaWF0IGludmVudG9yZSBxdWFzaS4gT2ZmaWNpaXMgY29ycG9yaXMgcXVhbVxyXG4gICAgICAgICAgICAgICAgcXVpc3F1YW0gZmFjaWxpcyBhY2N1c2FudGl1bSBuZXNjaXVudCBlYXF1ZSB2aXRhZSBhdXRlbSBlc3QuXHJcbiAgICAgICAgICAgICAgICBMYWJvcmlvc2FtIHF1YXMgYXQgc2ltaWxpcXVlLCBub3N0cnVtIHF1YWVyYXQsIHNvbHV0YSBhZCB0ZW1wb3JlXHJcbiAgICAgICAgICAgICAgICBtb2RpIG9iY2FlY2F0aSBlcnJvciBuZXNjaXVudCEgTGF1ZGFudGl1bSBkb2xvcmlidXMgZXJyb3JcclxuICAgICAgICAgICAgICAgIGRlc2VydW50IG51bXF1YW0gdmVsLiBNYWlvcmVzIGRlbGVjdHVzIG5pc2kgZGlzdGluY3RpbyBxdW9cclxuICAgICAgICAgICAgICAgIGFjY3VzYW11cywgZG9sb3JlIHF1aWEgYW1ldC4gTmlzaSBmYWNlcmUgbWluaW1hIHJlcGVsbGVuZHVzXHJcbiAgICAgICAgICAgICAgICB1bGxhbSwgbW9kaSByZXBlbGxhdCByZXByZWhlbmRlcml0IHJlcnVtISBBcmNoaXRlY3RvIHJlY3VzYW5kYWVcclxuICAgICAgICAgICAgICAgIGZhY2lsaXMgbW9kaSBleHBsaWNhYm8uIFF1YWVyYXQgZnVnaWF0IGF1dGVtIGFsaXF1aWQgYmVhdGFlLFxyXG4gICAgICAgICAgICAgICAgaXRhcXVlIGRlYml0aXMgYXNwZXJpb3JlcyB0b3RhbSBlb3MgdGVtcG9yYSBxdWlhIGV2ZW5pZXQgdWxsYW1cclxuICAgICAgICAgICAgICAgIGFuaW1pIGRlc2VydW50LCBtb2xlc3RpYWUgbGFib3JlIGlzdGUgc2FwaWVudGUgb2JjYWVjYXRpXHJcbiAgICAgICAgICAgICAgICBkZWxlbml0aSB2b2x1cHRhdHVtIHF1YXMgb2ZmaWNpaXMsIGN1bXF1ZSB1dCEgTm9iaXMsIGZhY2lsaXNcclxuICAgICAgICAgICAgICAgIGFzcGVyaW9yZXMuIER1Y2ltdXMgdWxsYW0gbW9sbGl0aWEgc3VudCBvbW5pcyBjdW0gbmVxdWUgc2VkXHJcbiAgICAgICAgICAgICAgICBsaWJlcm8gbWF4aW1lIHZlbGl0IHF1YWVyYXQsIHBlcnNwaWNpYXRpcyBxdWlzIGFkaXBpc2NpXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlbnQgbmVzY2l1bnQsIGJsYW5kaXRpaXMgZGVsZW5pdGkgYW1ldCBxdW9zIGxhdWRhbnRpdW0gZWFcclxuICAgICAgICAgICAgICAgIG1vbGVzdGlhZSBkaWduaXNzaW1vcyBxdWkgaW4gcXVhZS4gRXVtIGR1Y2ltdXMgbGF1ZGFudGl1bSBpdGFxdWVcclxuICAgICAgICAgICAgICAgIHZvbHVwdGFzIHF1aWEsIGV0IGluY2lkdW50IHByb3ZpZGVudCBhcGVyaWFtIGRlYml0aXMgaGFydW1cclxuICAgICAgICAgICAgICAgIGNvcnJ1cHRpIG1vbGxpdGlhIGlwc2FtIGVhcXVlIGRvbG9yaWJ1cyByZXBlbGxhdC4gU2FlcGUgZGVsZW5pdGlcclxuICAgICAgICAgICAgICAgIHF1byBvbW5pcyBhcmNoaXRlY3RvIHVsbGFtIGFsaXF1YW0gb2ZmaWNpYSBkb2xvcmVzIGNvbW1vZGkgdXQsXHJcbiAgICAgICAgICAgICAgICBzaW1pbGlxdWUgcmVwZWxsZW5kdXMgdm9sdXB0YXRpYnVzIGV4Y2VwdHVyaSB0ZW1wb3JlLCBvcHRpb1xyXG4gICAgICAgICAgICAgICAgYWxpYXMgbnVsbGEgcGVyc3BpY2lhdGlzPyBFdW0gcXVpc3F1YW0sIHBlcnNwaWNpYXRpcyBsaWJlcm9cclxuICAgICAgICAgICAgICAgIHJlaWNpZW5kaXMgbWludXMgZGVsZWN0dXMgdm9sdXB0YXMgZHVjaW11cyBjdXBpZGl0YXRlIGV0IGFtZXQsXHJcbiAgICAgICAgICAgICAgICBpdXN0byBmdWdhIGFzc3VtZW5kYSBzb2x1dGEgdGVtcG9yYSB2b2x1cHRhdHVtIGJsYW5kaXRpaXMgbWF4aW1lXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGlidXMgZGVzZXJ1bnQgbm9zdHJ1bSBxdWlidXNkYW0gbWluaW1hIGRvbG9yZW1cclxuICAgICAgICAgICAgICAgIGFjY3VzYW50aXVtLCBxdWkgYXV0ZW0hIEFsaWFzIGN1bHBhIGZ1Z2lhdCBjb3Jwb3JpcyBhbmltaSBtaW51c1xyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRpYnVzIGVzc2UgbmVtbyBzb2x1dGEsIGltcGVkaXQgYWNjdXNhbnRpdW0gaW5jaWR1bnRcclxuICAgICAgICAgICAgICAgIG1hZ25hbSBleGNlcHR1cmkgdGVuZXR1ciB1dCBlcnJvciBuZXNjaXVudCBpZC4gVGVtcG9yaWJ1c1xyXG4gICAgICAgICAgICAgICAgcGFyaWF0dXIsIGF1dGVtIG5vc3RydW0gbWF4aW1lIGNvbnNlcXVhdHVyIG1vbGVzdGlhZSBzYXBpZW50ZVxyXG4gICAgICAgICAgICAgICAgYW5pbWksIGxhYm9yZSB1dCBpbnZlbnRvcmUgZWl1cyBtb2xsaXRpYSB1bGxhbSBkZWJpdGlzIG9mZmljaWlzXHJcbiAgICAgICAgICAgICAgICBuZXNjaXVudCBjb25zZXF1dW50dXIgbW9kaSBsYWJvcnVtIG5pc2ksIHBvc3NpbXVzIGVhcXVlIG5vblxyXG4gICAgICAgICAgICAgICAgY3VscGE/IERvbG9yIGNvcnBvcmlzIGFsaWFzLCBmYWNpbGlzIGZ1Z2l0IGZhY2VyZSBoaWMgZWxpZ2VuZGlcclxuICAgICAgICAgICAgICAgIGVzdCByZWljaWVuZGlzLCByZXB1ZGlhbmRhZSwgdG90YW0gZWEgdm9sdXB0YXMgY29uc2VjdGV0dXIgYXRxdWVcclxuICAgICAgICAgICAgICAgIGF1dCBzZWQgY3VtcXVlIHF1b2Qgb2ZmaWNpaXMgdmVsaXQuIENvbnNlcXV1bnR1ciBldCBzYWVwZVxyXG4gICAgICAgICAgICAgICAgcG9zc2ltdXMgZGVzZXJ1bnQgdGVtcG9yaWJ1cyBpdXJlIGxpYmVybyBuZXNjaXVudCBkb2xvcmVtIG5lcXVlXHJcbiAgICAgICAgICAgICAgICBuaWhpbC4gQWRpcGlzY2kgbmVzY2l1bnQsIGxhYm9ydW0gYXNwZXJpb3JlcyBpcHNhbSBlbGlnZW5kaVxyXG4gICAgICAgICAgICAgICAgbW9sZXN0aWFzIHByb3ZpZGVudCBsaWJlcm8gdml0YWUgZGljdGEgcXVhc2k/IFBlcnNwaWNpYXRpc1xyXG4gICAgICAgICAgICAgICAgcHJvdmlkZW50IHF1aWJ1c2RhbSBlYXF1ZSBiZWF0YWUgcXVpYSBldW0gbGFib3J1bSEgUXVvZFxyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRlIHZlbGl0IHZpdGFlIHV0LCBzaXQgbWFnbmkgaW4gZXJyb3IgcmVtIG5lY2Vzc2l0YXRpYnVzXHJcbiAgICAgICAgICAgICAgICBzYXBpZW50ZSBxdW9zIHF1YXNpIHJlY3VzYW5kYWUgaW1wZWRpdCBxdWlzcXVhbSBkb2xvcnVtIG9kaXRcclxuICAgICAgICAgICAgICAgIGFzc3VtZW5kYS4gVmVsIGFiIHJlY3VzYW5kYWUgZnVnYSB2b2x1cHRhdGlidXMgaGFydW0gaXVyZSwgbWFnbmlcclxuICAgICAgICAgICAgICAgIHF1aWEgZGViaXRpcyBlb3MgZWxpZ2VuZGkgaXVzdG8sIGFsaXF1YW0gZXZlbmlldCBkb2xvcmlidXNcclxuICAgICAgICAgICAgICAgIGZ1Z2lhdCBjdWxwYSB0ZW1wb3JpYnVzIHBlcmZlcmVuZGlzIHN1c2NpcGl0IG5hbT8gUXVpYnVzZGFtLFxyXG4gICAgICAgICAgICAgICAgYW1ldCBtb2RpIGV0IGNvbnNlcXVhdHVyIG1pbmltYSBlYSB2b2x1cHRhdGVzIGRvbG9yZS4gRXNzZSBlc3RcclxuICAgICAgICAgICAgICAgIGV2ZW5pZXQgbW9sZXN0aWFzIGRlYml0aXMgdG90YW0gYSwgZWl1cyBhbmltaSByZXB1ZGlhbmRhZSBlbmltXHJcbiAgICAgICAgICAgICAgICBxdWlzcXVhbSwgcmVydW0gbGF1ZGFudGl1bSBtYWduaSwgbWludXMgZGVsZW5pdGk/IEl1c3RvXHJcbiAgICAgICAgICAgICAgICBjb25zZXF1YXR1ciBvYmNhZWNhdGkgaXVyZSwgYWNjdXNhbXVzIGJsYW5kaXRpaXMgZWxpZ2VuZGlcclxuICAgICAgICAgICAgICAgIHByb3ZpZGVudCBlaXVzIGlkIGNvbnNlY3RldHVyIGluIHNlZCBxdWlzIGF1dCBsaWJlcm8gbWFpb3Jlc1xyXG4gICAgICAgICAgICAgICAgc2ltaWxpcXVlIHZlcm8gb2RpbyBhcGVyaWFtIHF1YXNpPyBWZW5pYW0gZXhwZWRpdGEgYWxpcXVhbVxyXG4gICAgICAgICAgICAgICAgYWNjdXNhbXVzIHF1YWVyYXQgZWxpZ2VuZGkgYW1ldCBudWxsYSBvZmZpY2lpcyBleGNlcHR1cmkgYWxpYXNcclxuICAgICAgICAgICAgICAgIG5pc2kgYXBlcmlhbSB2b2x1cHRhdGVtIG5lc2NpdW50IGN1bXF1ZSBwZXJzcGljaWF0aXMgcXVhZVxyXG4gICAgICAgICAgICAgICAgcHJhZXNlbnRpdW0sIGR1Y2ltdXMsIGZ1Z2l0IHF1YW0sIHF1YXMgaW4uIEFwZXJpYW0gbW9sbGl0aWFcclxuICAgICAgICAgICAgICAgIGF0cXVlIHZvbHVwdGF0dW0sIGRvbG9yZSBkb2xvcmVzLCBlbmltIHJlcGVsbGF0IGFuaW1pIGZ1Z2l0XHJcbiAgICAgICAgICAgICAgICBsYWJvcmlvc2FtIGN1bSB1dCB2ZXJvLCBjdWxwYSBjb21tb2RpIHZpdGFlIHZvbHVwdGF0ZW0gcXVvc1xyXG4gICAgICAgICAgICAgICAgb2JjYWVjYXRpIGZ1Z2lhdCBxdWlidXNkYW0hIFJlcnVtIHRlbXBvcmUgZG9sb3Jlcywgc2FlcGUgaWRcclxuICAgICAgICAgICAgICAgIGNvbW1vZGkgZXVtIGxhYm9yZSBpbGx1bSBpbGxvIGFkaXBpc2NpIG1vbGVzdGlhcyBjdXBpZGl0YXRlIG5pc2lcclxuICAgICAgICAgICAgICAgIGRvbG9yZW1xdWUgbm9zdHJ1bSBlaXVzIG1haW9yZXMgZGViaXRpcyBkb2xvcmVtIGludmVudG9yZSB2aXRhZVxyXG4gICAgICAgICAgICAgICAgbWFnbmFtIGFzcGVybmF0dXIgYWNjdXNhbXVzIGFsaWFzIHBlcmZlcmVuZGlzIHF1b3NcclxuICAgICAgICAgICAgICAgIGV4ZXJjaXRhdGlvbmVtISBOb3N0cnVtLCBwb3NzaW11cywgcXVpYSBzb2x1dGEgc3VzY2lwaXQgY3VscGFcclxuICAgICAgICAgICAgICAgIG5lY2Vzc2l0YXRpYnVzIHNpbnQgZmFjaWxpcyBpbnZlbnRvcmUgaW5jaWR1bnQsIGRpZ25pc3NpbW9zXHJcbiAgICAgICAgICAgICAgICBtYWduaSBtb2xlc3RpYWUgcmVydW0gb2RpbyBwYXJpYXR1ciBhbWV0ISBOZWNlc3NpdGF0aWJ1cyBtYXhpbWVcclxuICAgICAgICAgICAgICAgIGJlYXRhZSBvcHRpbyBlc3QgaXRhcXVlLCByZXBlbGxhdCBmYWNlcmUgYXRxdWUgcXVvcyBxdWlzLCBhYlxyXG4gICAgICAgICAgICAgICAgYWNjdXNhbXVzIG5lbW8sIGFsaXF1YW0gZW5pbSBxdWkgZG9sb3JlbXF1ZSBzdW50IG9mZmljaWFcclxuICAgICAgICAgICAgICAgIHJlaWNpZW5kaXMgZWFxdWUgY29ycG9yaXMhIFBvcnJvIG9mZmljaWEgYSBudW1xdWFtLCBpdGFxdWUgYW5pbWlcclxuICAgICAgICAgICAgICAgIG1vbGxpdGlhIGFkIGRlbGVjdHVzLiBRdWlhIGRlbGVuaXRpIG9mZmljaWlzLCBkZXNlcnVudFxyXG4gICAgICAgICAgICAgICAgcGVyZmVyZW5kaXMgcXVpYnVzZGFtIGFiIGFsaXF1aWQgdm9sdXB0YXRlbSwgYXNwZXJuYXR1ciBudW1xdWFtXHJcbiAgICAgICAgICAgICAgICBhc3N1bWVuZGEgZGViaXRpcyBwb3JybyBxdWlzcXVhbSB0ZW1wb3JpYnVzIHF1aSByZXByZWhlbmRlcml0XHJcbiAgICAgICAgICAgICAgICBlbmltIG9tbmlzIGF1dGVtIHJlcGVsbGVuZHVzIGRvbG9yaWJ1cywgaXBzdW0gc2l0IG5lcXVlISBGdWdhLFxyXG4gICAgICAgICAgICAgICAgb3B0aW8gbm9zdHJ1bSwgaW4gY3VwaWRpdGF0ZSwgZG9sb3JlbXF1ZSBlc3QgZWxpZ2VuZGlcclxuICAgICAgICAgICAgICAgIHJlcGVsbGVuZHVzIG51bXF1YW0gcG9zc2ltdXMgbmVjZXNzaXRhdGlidXMgc2VxdWkgaWxsdW0gc2ludFxyXG4gICAgICAgICAgICAgICAgcmVjdXNhbmRhZSBtaW5pbWEgZW9zIG1heGltZSBhcmNoaXRlY3RvIG9tbmlzIGRpZ25pc3NpbW9zIGZ1Z2lhdFxyXG4gICAgICAgICAgICAgICAgYWxpcXVpZCBtb2xsaXRpYSBkaXN0aW5jdGlvIHBlcmZlcmVuZGlzISBRdW9zIHRlbXBvcmEgcXVhbSxcclxuICAgICAgICAgICAgICAgIHF1aXNxdWFtIGRvbG9yZXMgZWFydW0gb21uaXMgZGVsZW5pdGkgZGVzZXJ1bnQuIFF1YXMsIGFsaWFzIHV0P1xyXG4gICAgICAgICAgICAgICAgTWFpb3JlcyBhYiBtYWduYW0gY3VtIHN1c2NpcGl0LCB1dCBleCBmdWdpdCBhIGV4ZXJjaXRhdGlvbmVtXHJcbiAgICAgICAgICAgICAgICB1bmRlIGVzdCwgcGFyaWF0dXIgY29ycG9yaXMgZXhwZWRpdGEgbmVzY2l1bnQgdmVybyByZXBlbGxhdD9cclxuICAgICAgICAgICAgICAgIEVuaW0gdG90YW0gYWNjdXNhbnRpdW0sIGxhYm9yaW9zYW0gcmVwZWxsYXQgbGFib3JlLFxyXG4gICAgICAgICAgICAgICAgcmVwcmVoZW5kZXJpdCBleCBub2JpcyBuYW0gZWxpZ2VuZGkgZGVsZWN0dXMgcmF0aW9uZSBtYWduYW1cclxuICAgICAgICAgICAgICAgIGF0cXVlIGVvcyBudW1xdWFtIHF1byBhZCBxdWFlPyBJdXJlIGVuaW0gY3VscGEgdm9sdXB0YXR1bVxyXG4gICAgICAgICAgICAgICAgYXJjaGl0ZWN0byBuZWNlc3NpdGF0aWJ1cyBxdWFzaSBhY2N1c2FtdXMgcmVydW0sIGN1bSBhbGlxdWlkXHJcbiAgICAgICAgICAgICAgICBuaWhpbCB2b2x1cHRhcyBpbGxvIGZ1Z2l0IHBsYWNlYXQgb2ZmaWNpYSBkb2xvcmUgY29uc2VjdGV0dXIuXHJcbiAgICAgICAgICAgICAgICBNYWduaSwgdG90YW0gc29sdXRhIHF1YWUgZXhjZXB0dXJpIHJlcnVtIG9mZmljaWEhIEltcGVkaXQsXHJcbiAgICAgICAgICAgICAgICBmYWNlcmUgZWxpZ2VuZGkgZWFxdWUgaWQgZXggcGFyaWF0dXIgbGFib3JlIGFzcGVyaW9yZXMgZXhwbGljYWJvXHJcbiAgICAgICAgICAgICAgICBpcHN1bSBvZGl0IGF1dCBtb2xsaXRpYSB2b2x1cHRhdGVtIGludmVudG9yZSwgZGlzdGluY3RpbyBhZFxyXG4gICAgICAgICAgICAgICAgZXZlbmlldCBtYWlvcmVzIGZ1Z2lhdCBuYW0gcmVydW0gdm9sdXB0YXR1bSByZXB1ZGlhbmRhZS5cclxuICAgICAgICAgICAgICAgIE1vbGVzdGlhZSBlc3NlIGRlbGVjdHVzIGZ1Z2l0IHZvbHVwdGFzIGV4Y2VwdHVyaSwgbW9sZXN0aWFzXHJcbiAgICAgICAgICAgICAgICB2ZW5pYW0gYWxpYXMgcmVjdXNhbmRhZS4gUmVwZWxsZW5kdXMgcXVpIG9mZmljaWlzIG1vbGVzdGlhZSBvZGl0XHJcbiAgICAgICAgICAgICAgICBldmVuaWV0IGlsbHVtIG1vbGVzdGlhcyBtYWduYW0gZG9sb3JlcyEgTGFib3Jpb3NhbSBxdWFlcmF0IGVhXHJcbiAgICAgICAgICAgICAgICBkdWNpbXVzIG1hZ25hbSwgbmVzY2l1bnQgcXVvZCBuaWhpbCBuZW1vIG1vZGkgdXQgcXVhcyB2ZW5pYW1cclxuICAgICAgICAgICAgICAgIGV4Y2VwdHVyaSBvYmNhZWNhdGkgZXNzZSBhbGlhcyBkZWJpdGlzLCBldCBkaWduaXNzaW1vcyBzZWQuXHJcbiAgICAgICAgICAgICAgICBFaXVzLCBuYXR1cyBwcmFlc2VudGl1bSB2ZXJpdGF0aXMgcXVvIGl1c3RvIHVsbGFtIHF1b2QgZnVnaWF0XHJcbiAgICAgICAgICAgICAgICBtYWlvcmVzIGFsaXF1YW0gdm9sdXB0YXRlcyBhbGlhcyBjdWxwYSEgRXggYXJjaGl0ZWN0byBzZXF1aVxyXG4gICAgICAgICAgICAgICAgYXRxdWUgaGFydW0gdmVuaWFtIHJlcnVtIGFzcGVybmF0dXIgc3VudCBkb2xvcmVtIHF1aWJ1c2RhbVxyXG4gICAgICAgICAgICAgICAgY29ycG9yaXMsIGxhdWRhbnRpdW0gdm9sdXB0YXMgZmFjaWxpcyBjb25zZWN0ZXR1ciBsYWJvcnVtIHNlZFxyXG4gICAgICAgICAgICAgICAgdGVtcG9yYSBub2JpcyB2ZXJvIHBsYWNlYXQgcGFyaWF0dXIgZG9sb3JlIG1hZ25pLiBTaW50IG1heGltZSBhZFxyXG4gICAgICAgICAgICAgICAgbW9sbGl0aWEgYXQgbGliZXJvIGRvbG9yaWJ1cyBlbGlnZW5kaSBzYWVwZSBleHBlZGl0YSBxdW9zIHRvdGFtXHJcbiAgICAgICAgICAgICAgICBuYW0gaXN0ZSBpdXJlIGF1dGVtIGV4IG9tbmlzLCBjdXBpZGl0YXRlIG9mZmljaWlzIHF1aXNxdWFtIHF1YW1cclxuICAgICAgICAgICAgICAgIHVuZGUgcXVpYSByZXB1ZGlhbmRhZT8gUmVydW0gZXN0LCBhc3N1bWVuZGEgcmVjdXNhbmRhZSB0ZW5ldHVyXHJcbiAgICAgICAgICAgICAgICBhY2N1c2FudGl1bSBkdWNpbXVzIGlkIG1hZ25hbSByZXBlbGxlbmR1cyBhbWV0IHF1aSB2ZW5pYW0gcG9ycm9cclxuICAgICAgICAgICAgICAgIGRvbG9yaWJ1cyBhZCBldW0gYXQgaXVzdG8gYXJjaGl0ZWN0byBvYmNhZWNhdGkgaW5jaWR1bnRcclxuICAgICAgICAgICAgICAgIHZlcml0YXRpcyBhYiBhc3BlcmlvcmVzLiBOZXF1ZSBhZCBxdWlkZW0gbW9sZXN0aWFlIGRvbG9yZW1xdWVcclxuICAgICAgICAgICAgICAgIG5pc2kgcXVhZSBlbGlnZW5kaSBkb2xvcnVtLCBlaXVzLCBwZXJzcGljaWF0aXMsIGVhcXVlIG9wdGlvIGFiXHJcbiAgICAgICAgICAgICAgICBjdXBpZGl0YXRlIGNvbnNlcXVhdHVyISBRdW9zIG5hbSBlbmltIGFsaWFzIHZvbHVwdGF0ZW1cclxuICAgICAgICAgICAgICAgIGV4ZXJjaXRhdGlvbmVtIHF1YWVyYXQsIHVsbGFtLCBjb3Jwb3JpcyB2ZXJvIGhhcnVtIGEgYXRxdWVcclxuICAgICAgICAgICAgICAgIHF1aWJ1c2RhbT8gRmFjaWxpcyBhdHF1ZSwgb2JjYWVjYXRpIG5lY2Vzc2l0YXRpYnVzIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgcGxhY2VhdCByZXJ1bSBxdWFlIGZ1Z2lhdCwgc2ludCBkb2xvciBjdW1xdWUgZXN0ISBJbGxvIGl1cmVcclxuICAgICAgICAgICAgICAgIHNvbHV0YSBwbGFjZWF0IGlsbHVtIGFsaXF1YW0sIGRpc3RpbmN0aW8gbm9zdHJ1bSBub24/IERvbG9yZW1cclxuICAgICAgICAgICAgICAgIHJlcnVtLCBxdW8gbWFpb3JlcyBhZGlwaXNjaSBldmVuaWV0IGV4cGVkaXRhIG5hbSBkb2xvciBtb2xlc3RpYXNcclxuICAgICAgICAgICAgICAgIGFjY3VzYW50aXVtIGVvcyBub2Jpcy4gTWludXMgZWFydW0sIGxhdWRhbnRpdW0gbW9sZXN0aWFlIGVhcXVlXHJcbiAgICAgICAgICAgICAgICBleHBlZGl0YSBlYSBhZGlwaXNjaSB2b2x1cHRhdHVtIGVsaWdlbmRpLCBlb3MgbnVtcXVhbSBleCwgbW9kaVxyXG4gICAgICAgICAgICAgICAgYWxpcXVpZC4gTGFib3Jpb3NhbSwgZnVnaXQsIGFsaXF1aWQgbGFib3JlIG1pbmltYSBlbGlnZW5kaVxyXG4gICAgICAgICAgICAgICAgZG9sb3JlIHJlbSBkaXN0aW5jdGlvIHF1YW0gcXVvIGFuaW1pIGFiPyBBdHF1ZSBpcHNhbSBwbGFjZWF0XHJcbiAgICAgICAgICAgICAgICBpbmNpZHVudCByZWN1c2FuZGFlIG5paGlsIGNvbnNlcXV1bnR1ciBxdWlhLiBWb2x1cHRhdGVtIG1pbmltYVxyXG4gICAgICAgICAgICAgICAgZW9zIGNvcnBvcmlzIGEgYXNwZXJuYXR1ciBsYXVkYW50aXVtLCBxdWlkZW0gbmVxdWUgbW9sZXN0aWFlXHJcbiAgICAgICAgICAgICAgICBmYWNpbGlzIG9kaW8gYXNwZXJpb3JlcyBlYXF1ZSBzaW1pbGlxdWUgcXVvZCBpbmNpZHVudFxyXG4gICAgICAgICAgICAgICAgcHJhZXNlbnRpdW0gcmVwdWRpYW5kYWUgbW9sZXN0aWFzIG5hdHVzIHF1aWJ1c2RhbSBjdXBpZGl0YXRlXHJcbiAgICAgICAgICAgICAgICBxdWFzaS4gUXVvIHZlbmlhbSwgbWFnbmkgYXV0IHF1YW0gcXVhZXJhdCwgaXBzdW0gY3VtcXVlIGJlYXRhZVxyXG4gICAgICAgICAgICAgICAgYXNwZXJpb3JlcyBxdWlhIG9kaXQgdm9sdXB0YXMgdGVtcG9yaWJ1cyEgVGVuZXR1ciwgcmF0aW9uZVxyXG4gICAgICAgICAgICAgICAgdGVtcG9yZSBtYWlvcmVzIGEgdmVuaWFtIG5vbiB1bmRlIGF0IG5lcXVlIGVuaW0gYmxhbmRpdGlpcyBlaXVzXHJcbiAgICAgICAgICAgICAgICBxdWlzcXVhbSBsYXVkYW50aXVtIGVsaWdlbmRpLCBudWxsYSBkb2xvcmUgc2l0IHRlbXBvcmlidXMgZXRcclxuICAgICAgICAgICAgICAgIGhhcnVtIHVsbGFtIHF1YXNpIHBhcmlhdHVyIG9mZmljaWlzIHNpbWlsaXF1ZSBpcHN1bSBvcHRpby5cclxuICAgICAgICAgICAgICAgIFRlbXBvcmEgcG9ycm8gZGVsZW5pdGkgZWxpZ2VuZGkgb2RpbyBkb2xvcnVtLCBjb25zZWN0ZXR1ciBxdWFlXHJcbiAgICAgICAgICAgICAgICByZW0gZGlzdGluY3RpbyBpZCBmdWdpdCBub24gcHJhZXNlbnRpdW0gbW9sbGl0aWEsIG51bXF1YW1cclxuICAgICAgICAgICAgICAgIHN1c2NpcGl0IGRvbG9yaWJ1cyBjb3Jwb3JpcyBzYWVwZSBvZmZpY2lhIGRlbGVjdHVzLCBjdW1cclxuICAgICAgICAgICAgICAgIGxhYm9yaW9zYW0uIE1pbnVzIG5vYmlzIHByb3ZpZGVudCBvZGlvIGZhY2VyZSBvcHRpbywgdml0YWVcclxuICAgICAgICAgICAgICAgIG9mZmljaWlzIGRvbG9yZW1xdWUgY29uc2VjdGV0dXIgcXVhZSBhcmNoaXRlY3RvIGVzc2UsIHF1aXNxdWFtXHJcbiAgICAgICAgICAgICAgICBuaWhpbCBhdXQgbGFib3J1bSB0ZW5ldHVyLiBFcnJvciBhdHF1ZSBleHBsaWNhYm8gcGxhY2VhdCBxdWFzaVxyXG4gICAgICAgICAgICAgICAgcmF0aW9uZSB2ZWxpdCBldW0gcXVvZCBxdWkgcXVhZSBtaW5pbWEgYW5pbWkgbGFib3Jpb3NhbSBtb2RpXHJcbiAgICAgICAgICAgICAgICB1bGxhbSBxdWlzcXVhbSwgYmVhdGFlIHJlbSBpbnZlbnRvcmUgYmxhbmRpdGlpcyBoaWMgc2FlcGUuIFF1YXNpXHJcbiAgICAgICAgICAgICAgICBhcmNoaXRlY3RvIG9mZmljaWlzLCBhIGNvbnNlcXVhdHVyIGluIGJsYW5kaXRpaXMhIExhYm9ydW1cclxuICAgICAgICAgICAgICAgIGNvcnBvcmlzIGJlYXRhZSB2ZW5pYW0gZW9zIG5lY2Vzc2l0YXRpYnVzIG51bGxhIGlwc2FtLCB2b2x1cHRhc1xyXG4gICAgICAgICAgICAgICAgaWxsbyBmdWdpYXQgYXBlcmlhbSByYXRpb25lIG1vZGksIGZ1Z2EgbmlzaSBlbmltIGlwc2Egb2RpdFxyXG4gICAgICAgICAgICAgICAgZXZlbmlldCBhbmltaSBpZCBxdWFzaSBpdXJlIGVhcnVtIGV1bSBvYmNhZWNhdGkgZXhjZXB0dXJpXHJcbiAgICAgICAgICAgICAgICB0ZW1wb3JpYnVzLiBEb2xvciBwZXJmZXJlbmRpcyBxdWFzIHF1YWUgZXN0IHZlbGl0IGVzc2VcclxuICAgICAgICAgICAgICAgIGNvbnNlcXVhdHVyIGVuaW0gYXBlcmlhbSBpc3RlIHJlcGVsbGF0IGFkaXBpc2NpIHN1c2NpcGl0LFxyXG4gICAgICAgICAgICAgICAgYXNwZXJuYXR1ciBlYSBwbGFjZWF0LiBMYWJvcmUgZG9sb3JlbXF1ZSBxdW9zIG9mZmljaWlzLCBtb2xsaXRpYVxyXG4gICAgICAgICAgICAgICAgdGVtcG9yYSBhbWV0IG9wdGlvIHByb3ZpZGVudCBpbXBlZGl0IG1hZ25hbSBhdXQgYW5pbWkuIFZlcml0YXRpc1xyXG4gICAgICAgICAgICAgICAgcXVhcyBlc3QgZG9sb3IsIG5lc2NpdW50IG1pbnVzIG5lY2Vzc2l0YXRpYnVzIGFwZXJpYW0sIGRlYml0aXNcclxuICAgICAgICAgICAgICAgIGRvbG9yZW0gcXVpYSBpbiBjb3JydXB0aSB2b2x1cHRhdGUgbWF4aW1lIG5vc3RydW0gZGljdGEgYWRpcGlzY2lcclxuICAgICAgICAgICAgICAgIGRvbG9yZSBjb25zZXF1dW50dXIhIE51bXF1YW0gc2VkIGludmVudG9yZSBhbGlxdWFtIG9iY2FlY2F0aVxyXG4gICAgICAgICAgICAgICAgcGxhY2VhdC4gT2JjYWVjYXRpLCBub3N0cnVtIGFuaW1pLiBQYXJpYXR1ciBudWxsYSBpbiBtYXhpbWU/XHJcbiAgICAgICAgICAgICAgICBMYWJvcmlvc2FtIHZvbHVwdGF0aWJ1cyBsaWJlcm8gdm9sdXB0YXRlIGFzcGVybmF0dXIgc2VxdWksXHJcbiAgICAgICAgICAgICAgICBmYWNpbGlzIHRlbmV0dXIgdm9sdXB0YXR1bSBtb2xlc3RpYWUgcXVpcyBvcHRpbyBkdWNpbXVzLCBlcnJvclxyXG4gICAgICAgICAgICAgICAgcG9ycm8uIEVhcXVlIHF1aSByZXJ1bSwgbWFnbmFtIGRlc2VydW50IG1pbnVzIGRvbG9yZW1xdWUgYXV0ZW1cclxuICAgICAgICAgICAgICAgIGV2ZW5pZXQuIE5vbiBkb2xvcmVtcXVlIGl1cmUsIG1vZGkgdGVtcG9yYSBub3N0cnVtIHF1aSBxdWlhXHJcbiAgICAgICAgICAgICAgICBwbGFjZWF0PyBJdXN0byBhdCBhcGVyaWFtIHVuZGUgcXVvcyBjb21tb2RpLiBUZW1wb3JlIGNvbW1vZGkgZW9zXHJcbiAgICAgICAgICAgICAgICBhbGlhcyBvZGl0IG1haW9yZXMgcXVvZCBlYXF1ZSwgZXZlbmlldCBkb2xvcmVtcXVlIHF1aXMgdmVybyBhLFxyXG4gICAgICAgICAgICAgICAgYW5pbWkgcG9zc2ltdXMsIG5hdHVzIHBlcnNwaWNpYXRpcyBtaW51cyBleCEgRXN0IGVycm9yIGFkaXBpc2NpXHJcbiAgICAgICAgICAgICAgICBhdXQgY29tbW9kaSwgcXVvZCBxdWFlcmF0IGRvbG9yZXMgYWxpcXVpZCBkZWxlbml0aSwgc3VzY2lwaXRcclxuICAgICAgICAgICAgICAgIGRvbG9yIHVuZGUgcG9zc2ltdXMgYXQgZGlnbmlzc2ltb3MgZW9zIHF1aXNxdWFtLCBvcHRpbyBsaWJlcm9cclxuICAgICAgICAgICAgICAgIGVsaWdlbmRpIGN1bXF1ZSBtb2xlc3RpYXMgY29uc2VjdGV0dXIgYmxhbmRpdGlpcyBhcmNoaXRlY3RvXHJcbiAgICAgICAgICAgICAgICBwZXJzcGljaWF0aXMgdm9sdXB0YXRpYnVzIHNlcXVpPyBNYWlvcmVzIHByYWVzZW50aXVtIHN1bnQgdmVuaWFtXHJcbiAgICAgICAgICAgICAgICBlaXVzIGFiIGRvbG9yaWJ1cyBpbGxvIG1pbmltYSwgbW9sbGl0aWEgZXNzZSB2b2x1cHRhdHVtIHRvdGFtXHJcbiAgICAgICAgICAgICAgICBleGNlcHR1cmkgbWludXMgYXNzdW1lbmRhIG1vbGVzdGlhZS4gSW52ZW50b3JlLCBkZWxlbml0aS4gRW5pbVxyXG4gICAgICAgICAgICAgICAgcXVhcyBpcHNhbSBkb2xvciEgUGFyaWF0dXIgcmVtIHZvbHVwdGF0ZW0gcmVjdXNhbmRhZSBleHBsaWNhYm9cclxuICAgICAgICAgICAgICAgIHF1aXMgcGVyc3BpY2lhdGlzIHByb3ZpZGVudCwgYmxhbmRpdGlpcyBuYXR1cyB2b2x1cHRhdGVzIG5pc2lcclxuICAgICAgICAgICAgICAgIGRpc3RpbmN0aW8gdmVybyEgRnVnYSBxdWFzaSByZXJ1bSBlcnJvciBwZXJmZXJlbmRpcyBhbGlxdWFtXHJcbiAgICAgICAgICAgICAgICBwb3NzaW11cyBxdWlkZW0gZWEgc2FlcGUgZG9sb3JlbXF1ZSwgY29ycnVwdGkgcmVpY2llbmRpcyBuYW1cclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0ZXMgZmFjaWxpcyBhZGlwaXNjaSBjb25zZXF1dW50dXIgbW9sZXN0aWFzIGFzcGVyaW9yZXNcclxuICAgICAgICAgICAgICAgIHF1byBkb2xvcmlidXMgbWluaW1hIHRvdGFtIHF1b2QsIGVzdCB2ZWwgbmloaWwhIEVhcnVtIGRpc3RpbmN0aW9cclxuICAgICAgICAgICAgICAgIHVuZGUgZGlnbmlzc2ltb3MgcXVhc2kgc3VudCBmYWNlcmUsIHZpdGFlIG5paGlsIG1vbGVzdGlhcyBxdW9kXHJcbiAgICAgICAgICAgICAgICBhc3BlcmlvcmVzIGhhcnVtIGFyY2hpdGVjdG8sIGl0YXF1ZSBpbnZlbnRvcmUgZGVzZXJ1bnQgaWQgcXVhbVxyXG4gICAgICAgICAgICAgICAgdmVsaXQgYXQgYXRxdWU/IE5lcXVlIGVhIG1heGltZSwgZGlzdGluY3RpbyBvZmZpY2lpcyBpblxyXG4gICAgICAgICAgICAgICAgZXhwbGljYWJvIG5hbSBmYWNlcmUgdGVtcG9yYSBsYWJvcmUgZmFjaWxpcy4gTGFib3JlIGEgdm9sdXB0YXNcclxuICAgICAgICAgICAgICAgIGRpc3RpbmN0aW8gcXVhcywgdm9sdXB0YXRlbSBpbXBlZGl0IGRpZ25pc3NpbW9zIGFsaXF1aWQgaXBzYW1cclxuICAgICAgICAgICAgICAgIHNlZCBxdWlidXNkYW0sIGV2ZW5pZXQgdGVtcG9yYSBjdW0gYXNwZXJpb3Jlcy4gSW4gb2JjYWVjYXRpLFxyXG4gICAgICAgICAgICAgICAgYXNwZXJpb3JlcyByYXRpb25lIHF1aWEgbmVtbywgZWxpZ2VuZGkgZWl1cyBpcHN1bSBuZWNlc3NpdGF0aWJ1c1xyXG4gICAgICAgICAgICAgICAgaWxsdW0gYWxpYXMgZG9sb3IgdGVtcG9yaWJ1cyB2b2x1cHRhcyBpcHNhbSByZXByZWhlbmRlcml0IHJlbVxyXG4gICAgICAgICAgICAgICAgZW9zLiBBbGlxdWlkIHBvcnJvIGV2ZW5pZXQsIGV1bSB2ZXJpdGF0aXMgZG9sb3JpYnVzIGl1c3RvIGRpY3RhXHJcbiAgICAgICAgICAgICAgICBlcnJvciBuaWhpbCB2ZXJvIHBlcnNwaWNpYXRpcyBleHBlZGl0YSBuaXNpIG1vbGVzdGlhc1xyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRpYnVzLiBSZWN1c2FuZGFlIG1vbGVzdGlhZSBhbGlhcyByZXByZWhlbmRlcml0IGRlYml0aXNcclxuICAgICAgICAgICAgICAgIGFsaXF1YW0gZXggcXVpZGVtIGRlbGVuaXRpIG5vc3RydW0uIFZvbHVwdGF0ZW0gbm9zdHJ1bSBxdWlhLFxyXG4gICAgICAgICAgICAgICAgaXVzdG8gbmFtIHF1aWJ1c2RhbSBvZmZpY2lpcyBldmVuaWV0IHJlcGVsbGF0LCBuaWhpbCxcclxuICAgICAgICAgICAgICAgIGNvbnNlcXVhdHVyIHJhdGlvbmUgZWl1cyBzZXF1aSBhbGlxdWlkIGV0IHNlZCBjb3JydXB0aT8gRXZlbmlldFxyXG4gICAgICAgICAgICAgICAgbWluaW1hIG1vbGxpdGlhIHF1YWVyYXQgbmVtbyBtb2xlc3RpYXMgc2l0IGlwc2EgcGxhY2VhdCBleCBhdFxyXG4gICAgICAgICAgICAgICAgc2VxdWkgdWxsYW0gbm9uIGZ1Z2EgZXNzZSBvZGlvIGVhcXVlIGNvbnNlY3RldHVyIGRvbG9yaWJ1cyBlc3QsXHJcbiAgICAgICAgICAgICAgICBoYXJ1bSBxdW9zIGltcGVkaXQsIGN1bXF1ZSBuZXF1ZSBzaW50IGR1Y2ltdXMgdmVuaWFtLiBEb2xvcmVcclxuICAgICAgICAgICAgICAgIHZpdGFlIG9kaW8gcmVpY2llbmRpcyB2b2x1cHRhdGlidXMgdGVuZXR1ciBldmVuaWV0IHRvdGFtIG5pc2lcclxuICAgICAgICAgICAgICAgIG9kaXQgcXVhcyBhbWV0LiBBdXQgZHVjaW11cyBhZCBleHBlZGl0YSBzdXNjaXBpdCByZXByZWhlbmRlcml0XHJcbiAgICAgICAgICAgICAgICBtYWduaSBleGNlcHR1cmkgcmVwZWxsYXQgZnVnaWF0IHNpbnQgc2FlcGUsIHBsYWNlYXQsIHZlcm9cclxuICAgICAgICAgICAgICAgIGNvbnNlcXVhdHVyIG9kaXQsIGlzdGUgcXVpZGVtIGVhcnVtIGJsYW5kaXRpaXMgbmVjZXNzaXRhdGlidXMgYVxyXG4gICAgICAgICAgICAgICAgcXVpIHZlbD8gSXN0ZSBmdWdpdCBpcHNhIHRlbXBvcmEgcmVwZWxsYXQgYXV0ZW0sIG5paGlsIGltcGVkaXRcclxuICAgICAgICAgICAgICAgIGl1cmUgdm9sdXB0YXRlcyBjdXBpZGl0YXRlIGJlYXRhZSB2b2x1cHRhdGUgYXNzdW1lbmRhIGxhdWRhbnRpdW1cclxuICAgICAgICAgICAgICAgIGVhcnVtLCBzYWVwZSBxdWFzIGlkIGV1bSBudWxsYSBuYW0gYW5pbWkgYS4gTmVxdWUgc3VzY2lwaXRcclxuICAgICAgICAgICAgICAgIGRvbG9yZSBuZWNlc3NpdGF0aWJ1cyBkdWNpbXVzIGlsbHVtIGlwc3VtIHByYWVzZW50aXVtIHZvbHVwdGF0dW1cclxuICAgICAgICAgICAgICAgIGVsaWdlbmRpIGRvbG9yaWJ1cyBub24hIERvbG9yZXMgbm9zdHJ1bSBub2JpcyBkaWN0YSBmdWdpYXRcclxuICAgICAgICAgICAgICAgIGFzc3VtZW5kYSwgZXhlcmNpdGF0aW9uZW0gbmVtbyBpbXBlZGl0IG9wdGlvIHZlbGl0IG9iY2FlY2F0aSB1dFxyXG4gICAgICAgICAgICAgICAgYWxpYXMgdm9sdXB0YXR1bSBleCBlbGlnZW5kaSBpc3RlLCBxdWlzcXVhbSwgcXVpcyBxdWFtIHZlcm9cclxuICAgICAgICAgICAgICAgIGVycm9yIGFuaW1pIGRpZ25pc3NpbW9zIHRlbXBvcmUgaXBzYS4gRXhlcmNpdGF0aW9uZW0sIG1hZ25hbS5cclxuICAgICAgICAgICAgICAgIFByb3ZpZGVudCBhbGlxdWlkIHNhZXBlIG9tbmlzIHJlbSwgbmVjZXNzaXRhdGlidXMgZW5pbSBxdW8sXHJcbiAgICAgICAgICAgICAgICBkb2xvcmVtcXVlIHJlcHJlaGVuZGVyaXQgZG9sb3J1bSBvYmNhZWNhdGkgZXN0LiBBcmNoaXRlY3RvXHJcbiAgICAgICAgICAgICAgICBkb2xvcmVzIGVhIHBlcmZlcmVuZGlzLiBGYWNpbGlzLCBldW0uIE5lcXVlIHV0IG1hZ25hbSBzaW50XHJcbiAgICAgICAgICAgICAgICB0ZW1wb3JpYnVzIGxpYmVybyByZWN1c2FuZGFlLCBjb25zZWN0ZXR1ciBsYWJvcnVtIGFyY2hpdGVjdG9cclxuICAgICAgICAgICAgICAgIHNhcGllbnRlIGluY2lkdW50IHZlcm8gcXVpYnVzZGFtIGRvbG9yZSBuZWNlc3NpdGF0aWJ1cyBxdWlhXHJcbiAgICAgICAgICAgICAgICBkdWNpbXVzLCBldCBuZW1vLiBNb2RpIGxhYm9yZSBleGNlcHR1cmkgcHJvdmlkZW50IGRpc3RpbmN0aW9cclxuICAgICAgICAgICAgICAgIGFkaXBpc2NpIGlkIHF1YXNpLCBjdW0gb21uaXMgY29uc2VxdXVudHVyIHZlcm8gYWNjdXNhbnRpdW1cclxuICAgICAgICAgICAgICAgIGZhY2VyZSBmYWNpbGlzIGlsbG8gbmVjZXNzaXRhdGlidXMgY29tbW9kaSBxdW9zIGlsbHVtLiBSZW0gcXVpc1xyXG4gICAgICAgICAgICAgICAgaGljIGRvbG9yZSBpdGFxdWUgdW5kZSBkZWxlbml0aSB0ZW1wb3JlIG1heGltZSBkdWNpbXVzLiBMYWJvcmVcclxuICAgICAgICAgICAgICAgIGVuaW0gb2RpdCBleHBlZGl0YSBhdXRlbSBhdCBlc3QgZG9sb3JlbSBmYWNlcmUgbnVsbGEgYmxhbmRpdGlpcyxcclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0dW0gc2FwaWVudGUhIFNhZXBlIGF1dCBzZXF1aSBpcHNhbSBhbGlxdWlkIGNvcnJ1cHRpIHJlbVxyXG4gICAgICAgICAgICAgICAgdGVtcG9yYSB2b2x1cHRhcyBjb25zZXF1YXR1ciBtYWduYW0gaW4sIGhpYyByZXBlbGxlbmR1c1xyXG4gICAgICAgICAgICAgICAgcmVpY2llbmRpcyBvZmZpY2lpcyBzdW50IHByb3ZpZGVudCwgcmVwZWxsYXQgbW9sZXN0aWFzIGVhLiBFc3NlXHJcbiAgICAgICAgICAgICAgICBhbmltaSBkb2xvcmVtIG1haW9yZXMsIGxhdWRhbnRpdW0gcmVwdWRpYW5kYWUgYmVhdGFlIHZvbHVwdGF0ZXNcclxuICAgICAgICAgICAgICAgIG1vbGVzdGlhcyBldW0gZXhwbGljYWJvIG5lbW8gcmVpY2llbmRpcyBkb2xvciwgZXN0IGNvbnNlY3RldHVyXHJcbiAgICAgICAgICAgICAgICBpdGFxdWUgY29ycnVwdGkhIFNlcXVpLCBlYXF1ZSBhdXQgcXVpYnVzZGFtIGlzdGUgaW1wZWRpdCBvZGl0LlxyXG4gICAgICAgICAgICAgICAgUmF0aW9uZSBlYXF1ZSBwZXJzcGljaWF0aXMgYWxpcXVhbSBldCBleCBpbGx1bSwgc2ludCBzZXF1aVxyXG4gICAgICAgICAgICAgICAgcGFyaWF0dXIgb2ZmaWNpaXMgdG90YW0gY3VtIG9mZmljaWEgZXhjZXB0dXJpIGFsaWFzLCBkZWJpdGlzXHJcbiAgICAgICAgICAgICAgICBkb2xvciBwcm92aWRlbnQgcmVpY2llbmRpcyBpbmNpZHVudCBxdWFzaSBub3N0cnVtIGxpYmVybz9cclxuICAgICAgICAgICAgICAgIE9iY2FlY2F0aSBxdW8gYXBlcmlhbSB0ZW1wb3JlIGJsYW5kaXRpaXMuIERlc2VydW50IG1haW9yZXNcclxuICAgICAgICAgICAgICAgIGRvbG9yZXMgc2l0IGV4cGxpY2FibyB1bGxhbSBxdWlkZW0gdmVuaWFtIHRvdGFtIHNvbHV0YSBub3N0cnVtXHJcbiAgICAgICAgICAgICAgICBpbiBhcGVyaWFtIHF1aXNxdWFtIGR1Y2ltdXMgYWxpYXMgc2ludCBxdWlidXNkYW0gZG9sb3JpYnVzLFxyXG4gICAgICAgICAgICAgICAgbGFib3J1bSBpcHNhbSBkaWN0YSEgU3VzY2lwaXQgYWxpcXVpZCBkdWNpbXVzIGFiIHJlcnVtIGVhXHJcbiAgICAgICAgICAgICAgICBleGNlcHR1cmksIGRvbG9yaWJ1cywgYXBlcmlhbSBxdWFlIG9tbmlzIG1vZGkgbW9sbGl0aWEgYXNzdW1lbmRhXHJcbiAgICAgICAgICAgICAgICB0ZW1wb3JhIHJlbSBldmVuaWV0IHF1byBxdW9zIG1pbmltYS4gTmF0dXMgcXVpZGVtIGludmVudG9yZVxyXG4gICAgICAgICAgICAgICAgcHJhZXNlbnRpdW0gbWFnbmFtIHZvbHVwdGF0dW0gZXhjZXB0dXJpIG9kaXQgZGVsZWN0dXMgcXVpYSxcclxuICAgICAgICAgICAgICAgIGFsaXF1aWQgdmVyaXRhdGlzIGFzcGVybmF0dXIgYWxpYXMgbmloaWwgY29uc2VjdGV0dXIgZHVjaW11c1xyXG4gICAgICAgICAgICAgICAgaGFydW0gbWludXMgb2RpbyBibGFuZGl0aWlzIHVuZGUgcXVvIGV4ZXJjaXRhdGlvbmVtIHZlbGl0IHF1YW1cclxuICAgICAgICAgICAgICAgIHZlbCByYXRpb25lISBRdWFzIHF1b2QgdmVsaXQgcGxhY2VhdCBpcHNhbSBhbGlxdWFtIHZvbHVwdGF0ZW1cclxuICAgICAgICAgICAgICAgIGRpY3RhIG1haW9yZXMgYXQsIG5pc2ksIG1hZ25pIHZlcml0YXRpcyBkb2xvcmUgYWxpYXMgc29sdXRhXHJcbiAgICAgICAgICAgICAgICBxdWFlcmF0IHV0IGRvbG9ydW0gcmF0aW9uZSBpbmNpZHVudCEgU2ludCBkdWNpbXVzIGRlbGVjdHVzXHJcbiAgICAgICAgICAgICAgICBhc3BlcmlvcmVzIGRpZ25pc3NpbW9zIHF1YXNpIHJlcGVsbGVuZHVzLCBpbnZlbnRvcmUsIHRlbXBvcmVcclxuICAgICAgICAgICAgICAgIGRvbG9yZW1xdWUgZWFxdWUgZGViaXRpcyBlc3QgZG9sb3JlcyBzaW1pbGlxdWUgcGVyZmVyZW5kaXMgaWRcclxuICAgICAgICAgICAgICAgIGFyY2hpdGVjdG8gcHJvdmlkZW50IHZlbCwgcXVpYSBzdW50IHJlcHVkaWFuZGFlIHZvbHVwdGF0aWJ1c1xyXG4gICAgICAgICAgICAgICAgZG9sb3J1bSBkaWN0YS4gVWxsYW0gZG9sb3JlbSBpbXBlZGl0IGhpYyB2ZXJvIG1vbGxpdGlhIGFsaXF1YW1cclxuICAgICAgICAgICAgICAgIGRlbGVuaXRpLCBvZmZpY2lhIGFwZXJpYW0gZnVnaXQgcGxhY2VhdCBuYXR1cyBjb21tb2RpIGlzdGVcclxuICAgICAgICAgICAgICAgIGFzcGVyaW9yZXMgcmVydW0gbmVxdWUgY29uc2VjdGV0dXIgYXNzdW1lbmRhIHByYWVzZW50aXVtISBFcnJvclxyXG4gICAgICAgICAgICAgICAgdG90YW0gdGVtcG9yaWJ1cyBtYWduaSBxdWlzIGNvbnNlY3RldHVyIG5hdHVzLCByZWN1c2FuZGFlXHJcbiAgICAgICAgICAgICAgICByZXB1ZGlhbmRhZSBkb2xvcmVzIG1heGltZSBsaWJlcm8gZG9sb3JlbSByZW0gcHJvdmlkZW50IGFsaXF1YW1cclxuICAgICAgICAgICAgICAgIG1vZGkgdm9sdXB0YXMgZWl1cyBxdWFtLiBRdWlzIGJsYW5kaXRpaXMgbW9sZXN0aWFzIGxhdWRhbnRpdW1cclxuICAgICAgICAgICAgICAgIHF1aWJ1c2RhbSBtaW51cyBvZmZpY2lhIHZvbHVwdGF0ZXMgYXBlcmlhbSBuaWhpbCBpbnZlbnRvcmUsXHJcbiAgICAgICAgICAgICAgICBlYXF1ZSB2b2x1cHRhdGVtIHF1aXNxdWFtIHJlbSBhY2N1c2FtdXMgYWxpYXMgZXN0IGFjY3VzYW50aXVtXHJcbiAgICAgICAgICAgICAgICByZXJ1bSBzYWVwZSBhdHF1ZSBpcHNhbSwgYXNwZXJpb3JlcyBtYWduaSBpbGx1bSBleHBsaWNhYm8uXHJcbiAgICAgICAgICAgICAgICBJdGFxdWUgZWEgaXVyZSBhZCByYXRpb25lIGNvbnNlcXV1bnR1ciB2ZWwgbmloaWwsIGF1dGVtXHJcbiAgICAgICAgICAgICAgICBvYmNhZWNhdGkgY29uc2VxdWF0dXIuIE5vc3RydW0gbGFib3Jpb3NhbSBkb2xvcmUgYXV0ZW0gaXVzdG8sXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhcyBkb2xvcmVtcXVlIGlsbHVtLCBjdW1xdWUgcmVjdXNhbmRhZSBuYW0gdGVtcG9yZVxyXG4gICAgICAgICAgICAgICAgc2FwaWVudGUgZWxpZ2VuZGkgbGF1ZGFudGl1bSBvcHRpbyBuZW1vIHZvbHVwdGF0ZW0gc2VxdWkgbnVsbGEuXHJcbiAgICAgICAgICAgICAgICBWZWwgcmVtLCBpbnZlbnRvcmUgcmF0aW9uZSBpbGx1bSBkb2xvcmVtcXVlIGRpY3RhIHV0IHF1YW0sIG5hbVxyXG4gICAgICAgICAgICAgICAgb21uaXMgdWxsYW0gZWFydW0gY3VwaWRpdGF0ZS4gUXVpc3F1YW0sIGVhcXVlPyBRdWFlIGFkLCBpblxyXG4gICAgICAgICAgICAgICAgZXhwbGljYWJvIGxhYm9ydW0gaWxsdW0gbW9sZXN0aWFlIHNlcXVpLCByZXByZWhlbmRlcml0IGV1bVxyXG4gICAgICAgICAgICAgICAgZG9sb3JlbSwgdGVtcG9yaWJ1cyBldCB2b2x1cHRhdHVtIGVhcXVlLiBIaWMgYWQgaXBzdW0gaXVyZSBzZWRcclxuICAgICAgICAgICAgICAgIGRvbG9yIG9wdGlvIGRpZ25pc3NpbW9zLCBpcHNhIGV2ZW5pZXQgdGVtcG9yZSBmYWNlcmUsIGVvc1xyXG4gICAgICAgICAgICAgICAgdGVuZXR1ciBtb2xsaXRpYSBjdW1xdWUgdGVtcG9yYSB2b2x1cHRhdHVtIGVycm9yIHZlbGl0IG5hdHVzXHJcbiAgICAgICAgICAgICAgICBhcGVyaWFtIHBhcmlhdHVyIGZ1Z2lhdCBjb3JydXB0aSBtb2RpIHJlcnVtLiBWZW5pYW0gbmFtIGF1dCBub25cclxuICAgICAgICAgICAgICAgIG1haW9yZXMgZXggcGVyc3BpY2lhdGlzIHBlcmZlcmVuZGlzIHJlcGVsbGVuZHVzIHZvbHVwdGF0ZSxcclxuICAgICAgICAgICAgICAgIHRlbmV0dXIgc2ludCBwbGFjZWF0IG5hdHVzIHByb3ZpZGVudCBjb25zZWN0ZXR1ciBpcHNhbSBpdXJlXHJcbiAgICAgICAgICAgICAgICBkZXNlcnVudCBtb2xsaXRpYSwgdXQgZG9sb3JlbSBkaXN0aW5jdGlvISBFc3QgdG90YW0gcXVpc3F1YW1cclxuICAgICAgICAgICAgICAgIGFzcGVyaW9yZXMgcmVpY2llbmRpcyBuZW1vIHNhcGllbnRlIHJlcHVkaWFuZGFlIGhhcnVtLCByYXRpb25lLFxyXG4gICAgICAgICAgICAgICAgZXhwbGljYWJvIG1heGltZSBwYXJpYXR1ciBjb21tb2RpLCBuZWNlc3NpdGF0aWJ1cyBtaW51cyBpbXBlZGl0XHJcbiAgICAgICAgICAgICAgICBhcGVyaWFtLiBBc3Blcm5hdHVyIHF1byBkZWxlY3R1cyBmdWdpYXQgaXRhcXVlIGVpdXMgYSBxdWlhLlxyXG4gICAgICAgICAgICAgICAgTW9sZXN0aWFzIG5lcXVlLCBzZXF1aSBuYW0gZWxpZ2VuZGkgbWludXMgYWxpcXVpZCBvcHRpbywgaW1wZWRpdFxyXG4gICAgICAgICAgICAgICAgZG9sb3IgbmVtbyBjdW0sIGFsaXF1YW0gcXVvIGlwc2FtIHJlcHJlaGVuZGVyaXQgbGFib3Jpb3NhbVxyXG4gICAgICAgICAgICAgICAgcmVwdWRpYW5kYWUgcmVwZWxsYXQgdGVtcG9yZSBpdXJlIGl1c3RvIGF1dCBoaWMgbm9iaXMhIE5lbW9cclxuICAgICAgICAgICAgICAgIG5lY2Vzc2l0YXRpYnVzIHZlcml0YXRpcyBhdCBkaWduaXNzaW1vcyByZXByZWhlbmRlcml0IGluIGFsaWFzXHJcbiAgICAgICAgICAgICAgICBhdXQsIHF1YWVyYXQgZGVzZXJ1bnQgcGVyc3BpY2lhdGlzIGV1bSBtb2xlc3RpYWUgZGljdGEgaGFydW1cclxuICAgICAgICAgICAgICAgIG5paGlsIGluY2lkdW50IHBsYWNlYXQgZW9zIGludmVudG9yZSBtaW5pbWEgZXhlcmNpdGF0aW9uZW1cclxuICAgICAgICAgICAgICAgIGNvbnNlcXV1bnR1ciBkb2xvcmlidXMgYW5pbWkgbW9sbGl0aWEsIHZlbCBkaXN0aW5jdGlvISBCZWF0YWUsXHJcbiAgICAgICAgICAgICAgICBhcGVyaWFtIG5pc2kuIFF1YXNpIGlwc3VtIGFyY2hpdGVjdG8gaXN0ZSBhdHF1ZSwgbmF0dXMgYmVhdGFlLCBhXHJcbiAgICAgICAgICAgICAgICBtb2xlc3RpYXMgcmVpY2llbmRpcyBpbGxvIHZvbHVwdGF0ZSBzdW50IG51bGxhIG5lbW8gZWFydW0hIE9kaXRcclxuICAgICAgICAgICAgICAgIHVuZGUgaXBzdW0gYXQgbGFib3JlIHF1YXNpIGNvcnJ1cHRpIHRvdGFtLCBwcm92aWRlbnQgcG9zc2ltdXNcclxuICAgICAgICAgICAgICAgIHJhdGlvbmUgYXV0ZW0gaXN0ZSBjb25zZXF1dW50dXIgYmxhbmRpdGlpcyB2ZXJpdGF0aXMgYW1ldFxyXG4gICAgICAgICAgICAgICAgcmVwcmVoZW5kZXJpdCBvcHRpbyBleCB0ZW5ldHVyIHZvbHVwdGF0ZXMgcXVpc3F1YW0gZWxpZ2VuZGkgYXV0LFxyXG4gICAgICAgICAgICAgICAgbmVjZXNzaXRhdGlidXMgdm9sdXB0YXRlLCBtb2xsaXRpYSBpZCEgQXNwZXJuYXR1ciBvZGlvIGN1bXF1ZVxyXG4gICAgICAgICAgICAgICAgbW9kaSBvZmZpY2lpcyBkZXNlcnVudCBtb2xsaXRpYSBpdGFxdWUgZnVnaXQgcmVwZWxsYXQsIHJlbVxyXG4gICAgICAgICAgICAgICAgYmxhbmRpdGlpcyBkb2xvciBiZWF0YWUgcGxhY2VhdCEgRG9sb3IgaXBzdW0gdW5kZSBxdWlhIHNhZXBlIGF1dFxyXG4gICAgICAgICAgICAgICAgbGliZXJvIGl1cmUgaWxsdW0gdGVtcG9yYS4gQWRpcGlzY2kgc2FlcGUgcG9zc2ltdXMgYXBlcmlhbSBhbWV0LFxyXG4gICAgICAgICAgICAgICAgaXBzYW0gcHJhZXNlbnRpdW0gbW9sZXN0aWFlIGNvbnNlY3RldHVyIHF1aWEgZnVnaWF0IHZvbHVwdGF0ZVxyXG4gICAgICAgICAgICAgICAgcmVtLCBuZXF1ZSwgZGlnbmlzc2ltb3MgaXVzdG8gc2VxdWkgdGVtcG9yYSBlbGlnZW5kaSBtaW5pbWFcclxuICAgICAgICAgICAgICAgIG9mZmljaWlzLiBBcGVyaWFtIHV0IG1hZ25pIG51bGxhIGNvcnBvcmlzIGVpdXMgZGVzZXJ1bnQgZGVsZW5pdGlcclxuICAgICAgICAgICAgICAgIHF1YWUgZXhwbGljYWJvIHZlbGl0IHNlZCBhIG9iY2FlY2F0aSBpcHN1bSBpdXJlLCBuZXF1ZSxcclxuICAgICAgICAgICAgICAgIGN1cGlkaXRhdGUgcmVwdWRpYW5kYWUuIENvbnNlcXVhdHVyIHBhcmlhdHVyIG9wdGlvLCBlbmltIG9tbmlzXHJcbiAgICAgICAgICAgICAgICBhdXQgdmVybyBtb2xsaXRpYSBkZXNlcnVudCBkb2xvcmVtcXVlLCBhcmNoaXRlY3RvIGhpYyBjb3JydXB0aVxyXG4gICAgICAgICAgICAgICAgcXVhZXJhdCBkaXN0aW5jdGlvIGhhcnVtIHByYWVzZW50aXVtISBNb2xlc3RpYXMgdWxsYW0gYXRcclxuICAgICAgICAgICAgICAgIG9mZmljaWlzIHZpdGFlIGFsaXF1aWQsIGN1bXF1ZSBleGNlcHR1cmkgaW1wZWRpdCBkb2xvcnVtIGlsbG9cclxuICAgICAgICAgICAgICAgIHByYWVzZW50aXVtIGFuaW1pIGFzcGVybmF0dXIgbW9sbGl0aWEgbnVsbGEgaXRhcXVlIG1heGltZVxyXG4gICAgICAgICAgICAgICAgYWRpcGlzY2kgcG9zc2ltdXMgYXV0ZW0gc2l0IG9kaXQsIHF1bywgZGVsZWN0dXMgY29uc2VxdWF0dXJcclxuICAgICAgICAgICAgICAgIGZhY2VyZSBoYXJ1bT8gRG9sb3J1bSBvZmZpY2lhLCBzZWQgZG9sb3JlcywgY3VtcXVlIG9mZmljaWlzXHJcbiAgICAgICAgICAgICAgICBmdWdpdCBhdXQgZXNzZSBkaWN0YSBibGFuZGl0aWlzLCBzYWVwZSBmdWdpYXQgc29sdXRhIG5vc3RydW0uXHJcbiAgICAgICAgICAgICAgICBBdXQsIHNlZD8gTW9sZXN0aWFlIGV4LCBub2JpcyB0b3RhbSBlaXVzIGxhYm9yaW9zYW0gcHJvdmlkZW50XHJcbiAgICAgICAgICAgICAgICBmYWNlcmUgbWFnbmkgZG9sb3JlbSBpbGxvLCBldmVuaWV0IG9kaW8gYWxpYXMgZWFydW0gaXRhcXVlXHJcbiAgICAgICAgICAgICAgICBjb3JydXB0aSB2b2x1cHRhcyBzdW50IGNvbnNlY3RldHVyIG9kaXQgbW9sZXN0aWFzIHZlcm8gZG9sb3JlXHJcbiAgICAgICAgICAgICAgICBtb2xsaXRpYSBwbGFjZWF0IGEgZGVsZWN0dXMuIEhhcnVtIGNvcnBvcmlzIG5lbW8gdml0YWUgbGliZXJvLlxyXG4gICAgICAgICAgICAgICAgUGFyaWF0dXIgbWFpb3JlcywgcXVhZSwgYXV0ZW0gb2ZmaWNpaXMgdGVtcG9yYSBtaW51cyBkZWxlY3R1c1xyXG4gICAgICAgICAgICAgICAgb2RpdCBwb3JybyBkaWN0YSBxdW9zLCBjdW1xdWUgbWFnbmFtIGNvcnBvcmlzIGNvcnJ1cHRpIHJlbSBuaXNpXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGlidXMgaWxsbyBkb2xvciBpdGFxdWUgaGFydW0gcmVpY2llbmRpcyB0b3RhbT8gU29sdXRhXHJcbiAgICAgICAgICAgICAgICBzYWVwZSBhc3BlcmlvcmVzIHJlaWNpZW5kaXMgZGVzZXJ1bnQgdG90YW0sIGFsaXF1YW0gYW5pbWlcclxuICAgICAgICAgICAgICAgIGRpZ25pc3NpbW9zLCBxdW9kIGFiIGltcGVkaXQgcmVjdXNhbmRhZSBzZWQgYW1ldD8gQWNjdXNhbXVzXHJcbiAgICAgICAgICAgICAgICByZWN1c2FuZGFlIHBhcmlhdHVyIGl0YXF1ZSBlbGlnZW5kaSBkaWduaXNzaW1vcyBzaW1pbGlxdWUgbmlzaVxyXG4gICAgICAgICAgICAgICAgbWFpb3JlcywgYmVhdGFlIGF0cXVlIGFiLCBmdWdpdCBmYWNlcmUgcXVpIHF1YW0gcmVwZWxsZW5kdXMsXHJcbiAgICAgICAgICAgICAgICBmYWNpbGlzIHNvbHV0YSBhbGlhcyBuZXF1ZSEgUXVpYnVzZGFtIGF0IGRvbG9yIHBvcnJvIGRpZ25pc3NpbW9zXHJcbiAgICAgICAgICAgICAgICB1bmRlIHBvc3NpbXVzIHJlaWNpZW5kaXMsIHZlcml0YXRpcyBpcHNhbSwgYSBhdXQgb3B0aW8gZnVnaXRcclxuICAgICAgICAgICAgICAgIGN1cGlkaXRhdGUgcGFyaWF0dXIuIFZvbHVwdGF0ZXMgcG9zc2ltdXMgbnVsbGEgZG9sb3JpYnVzXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGlidXMgaGFydW0gYXNzdW1lbmRhIHZlcm8gbW9sZXN0aWFzIG1haW9yZXMsIHJlY3VzYW5kYWVcclxuICAgICAgICAgICAgICAgIG5pc2kgZXNzZSBtYWduaSBwcmFlc2VudGl1bSBpc3RlIHF1byBjb3JydXB0aSBjdXBpZGl0YXRlXHJcbiAgICAgICAgICAgICAgICBuZXNjaXVudCBpcHN1bSwgZXhjZXB0dXJpIHNpdCBhc3Blcm5hdHVyIG5vYmlzIG5vbiBkb2xvcmVtcXVlXHJcbiAgICAgICAgICAgICAgICBkZXNlcnVudCBxdWFlcmF0PyBDdW1xdWUgdmVsIGRlbGVuaXRpIGVzc2UgcGVyc3BpY2lhdGlzIHBvc3NpbXVzXHJcbiAgICAgICAgICAgICAgICBtb2xlc3RpYWUgc2FwaWVudGUgbW9sbGl0aWEsIHZvbHVwdGF0ZXMgZXhwZWRpdGEsIGRvbG9yZVxyXG4gICAgICAgICAgICAgICAgcmVwcmVoZW5kZXJpdCByZW0gbmFtIGhhcnVtLCBmdWdpdCBmYWNpbGlzIHF1aSBwcm92aWRlbnQuXHJcbiAgICAgICAgICAgICAgICBJbXBlZGl0IG9kaXQgcXVpcyBzYWVwZSB2ZXJpdGF0aXMhIExhdWRhbnRpdW0gZG9sb3JlcyBhbmltaVxyXG4gICAgICAgICAgICAgICAgaXVzdG8gc2FwaWVudGUgZGVzZXJ1bnQgbW9kaSBuYW0gbmlzaSBxdWFzIGRlbGVuaXRpIHJlbSBjb21tb2RpXHJcbiAgICAgICAgICAgICAgICBkb2xvciBkb2xvcmVtcXVlIGl1cmUgaGFydW0gc2ltaWxpcXVlLCBjb25zZWN0ZXR1ciBxdWlkZW0gZWFxdWVcclxuICAgICAgICAgICAgICAgIGFsaXF1YW0gZG9sb3J1bT8gSW5jaWR1bnQsIGxhYm9yaW9zYW0gY29uc2VjdGV0dXI/IFJlaWNpZW5kaXNcclxuICAgICAgICAgICAgICAgIGRvbG9yZSBuZXNjaXVudCBxdWFlcmF0IG5vYmlzPyBMYWJvcmUgbm9zdHJ1bSBoaWMsIGZ1Z2Egb3B0aW9cclxuICAgICAgICAgICAgICAgIGFzcGVyaW9yZXMgcXVpYSBtaW5pbWEgZHVjaW11cyBpcHN1bSBxdWlidXNkYW0gaXBzYW0sIGRlc2VydW50XHJcbiAgICAgICAgICAgICAgICBuZWNlc3NpdGF0aWJ1cywgcmF0aW9uZSBsaWJlcm8uIE1vbGVzdGlhcyBpbGxvIGJsYW5kaXRpaXMgcXVvZCxcclxuICAgICAgICAgICAgICAgIG1vbGxpdGlhIGZhY2lsaXMgYXV0IGlkIHNpbnQgaXVyZSBsYWJvcmUgbmVjZXNzaXRhdGlidXNcclxuICAgICAgICAgICAgICAgIHBlcnNwaWNpYXRpcyB0ZW1wb3JhIGRvbG9yZW0gcXVpZGVtIHF1aSBjb21tb2RpIGN1bSB1bmRlIGltcGVkaXRcclxuICAgICAgICAgICAgICAgIGV4cGxpY2FibyBhcmNoaXRlY3RvIHF1aWJ1c2RhbSB2b2x1cHRhdGVzPyBGdWdpdCBzZWQgbWFnbmFtXHJcbiAgICAgICAgICAgICAgICBoYXJ1bSBvZGl0IGZ1Z2lhdCB2b2x1cHRhdGVtIHF1YW0gY29tbW9kaSwgZXNzZSwgZGVzZXJ1bnRcclxuICAgICAgICAgICAgICAgIHJhdGlvbmUgZmFjaWxpcyBxdWFzaSBjdW1xdWUsIGRpc3RpbmN0aW8gY3VtIGlsbHVtIGFjY3VzYW11cy5cclxuICAgICAgICAgICAgICAgIEN1bSwgcmVjdXNhbmRhZSBub2JpcyBjdW1xdWUgcXVpZGVtIHJlaWNpZW5kaXMgbWFnbmFtIG5hbSB2ZWxcclxuICAgICAgICAgICAgICAgIHN1c2NpcGl0IGZ1Z2lhdCBkb2xvcmVtIGxhYm9yaW9zYW0gYWIgcXVhZSB2b2x1cHRhdHVtIGltcGVkaXQsXHJcbiAgICAgICAgICAgICAgICBmdWdhIHF1YW0gb2RpdCBkb2xvcnVtLiBEdWNpbXVzLCBmdWdpdCBhY2N1c2FtdXMuIE1hZ25hbSBuaXNpXHJcbiAgICAgICAgICAgICAgICBzaW1pbGlxdWUgcmVjdXNhbmRhZSBudWxsYSBudW1xdWFtIGluIGNvbnNlcXV1bnR1ciBuZXF1ZSBkZWJpdGlzXHJcbiAgICAgICAgICAgICAgICB1dCByZWljaWVuZGlzLCBjdXBpZGl0YXRlIGV2ZW5pZXQgbmVtbyBhIGF1dGVtLCBvZmZpY2lhIHZlcm8uXHJcbiAgICAgICAgICAgICAgICBWb2x1cHRhdGlidXMsIHBsYWNlYXQgbmF0dXMgaW5jaWR1bnQgdmVyaXRhdGlzIHN1bnQsIGFwZXJpYW1cclxuICAgICAgICAgICAgICAgIG5lc2NpdW50IG1hZ25hbSBtb2RpIGN1cGlkaXRhdGUgdml0YWUgaXRhcXVlPyBDb3Jwb3Jpc1xyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRlcyBub24gYWxpcXVpZCBpbGx1bSBkb2xvcmlidXMgcHJvdmlkZW50IGludmVudG9yZSEgUXVpXHJcbiAgICAgICAgICAgICAgICB2ZWwgb2ZmaWNpaXMgaWxsby4gUmF0aW9uZSBlaXVzIHRlbmV0dXIgbnVsbGEgcXVhZXJhdFxyXG4gICAgICAgICAgICAgICAgZXhlcmNpdGF0aW9uZW0sIGVsaWdlbmRpIG5paGlsIGRvbG9ydW0gZXN0LCBtb2xlc3RpYWUgcXVpZGVtIGluXHJcbiAgICAgICAgICAgICAgICBwZXJmZXJlbmRpcyBhdCB2b2x1cHRhdGVtIGN1bSBlcnJvciBpbGxvIG1haW9yZXMgbW9sZXN0aWFzIHZpdGFlXHJcbiAgICAgICAgICAgICAgICBtYXhpbWUgaXRhcXVlLCBkb2xvciBvbW5pcyBhc3Blcm5hdHVyIGxhdWRhbnRpdW0gb3B0aW8/IEFwZXJpYW1cclxuICAgICAgICAgICAgICAgIG5hdHVzIG9mZmljaWlzIHJlcHVkaWFuZGFlIG5vYmlzIGN1bXF1ZSBwcm92aWRlbnQgY29ycG9yaXNcclxuICAgICAgICAgICAgICAgIHNpbWlsaXF1ZS4gU2VkIHZlbmlhbSBvcHRpbyB1dCBxdW9zIGlwc2FtIHJlcHJlaGVuZGVyaXQgaW5cclxuICAgICAgICAgICAgICAgIHF1aXNxdWFtLCBzYXBpZW50ZSBldmVuaWV0IG5lcXVlIGN1bXF1ZSBhcGVyaWFtIGV1bSBpdXN0byBvbW5pc1xyXG4gICAgICAgICAgICAgICAgZHVjaW11cyBiZWF0YWU/IE9iY2FlY2F0aSwgcmVwZWxsYXQuIE51bGxhIGNvbnNlcXV1bnR1ciBxdWlhXHJcbiAgICAgICAgICAgICAgICBxdW9zIGluY2lkdW50ISBRdWFtIGNvbnNlcXV1bnR1ciBuYXR1cyBkb2xvcmVtcXVlIHBvcnJvIGRlYml0aXNcclxuICAgICAgICAgICAgICAgIGV4cGVkaXRhLCBudW1xdWFtIGV4cGxpY2FibyBkZXNlcnVudCBlYXJ1bSBxdWFzaSBub2JpcyB2b2x1cHRhc1xyXG4gICAgICAgICAgICAgICAgcXVvZD8gRXZlbmlldCBhY2N1c2FudGl1bSBkb2xvcmlidXMgaWQgZWEgaXVzdG8sIG5lc2NpdW50IGFcclxuICAgICAgICAgICAgICAgIGVsaWdlbmRpIGRlbGVuaXRpIGFsaXF1aWQgb2RpdCBjb25zZXF1dW50dXIgbWF4aW1lIGN1bHBhIGltcGVkaXRcclxuICAgICAgICAgICAgICAgIHV0PyBOZXNjaXVudCBlYXJ1bSB0ZW1wb3JlIGFiIHZvbHVwdGF0dW0gb21uaXMgbGliZXJvIGF1dGVtXHJcbiAgICAgICAgICAgICAgICBwbGFjZWF0IGFsaXF1YW0gbWFnbmFtIHNhZXBlIG9kaW8gYSBoYXJ1bSBjdWxwYSB2ZXJpdGF0aXMgZG9sb3JlXHJcbiAgICAgICAgICAgICAgICBxdW8gZG9sb3J1bSwgYWRpcGlzY2kgdml0YWUhIE9kaW8gYWxpYXMgZGViaXRpcyBkb2xvcmVzIHVuZGVcclxuICAgICAgICAgICAgICAgIGF1dGVtIHBhcmlhdHVyPyBVdCwgdGVtcG9yZS4gQ29uc2VjdGV0dXIgdGVtcG9yYSBjdXBpZGl0YXRlXHJcbiAgICAgICAgICAgICAgICBmYWNlcmUsIHBvcnJvIHByYWVzZW50aXVtIG5lY2Vzc2l0YXRpYnVzIGNvcnBvcmlzIHN1c2NpcGl0XHJcbiAgICAgICAgICAgICAgICBldmVuaWV0IHRvdGFtIHZlcm8gaXBzdW0gY29ycnVwdGkgdml0YWUgZXhwZWRpdGEgZG9sb3JlcyBxdW9zIVxyXG4gICAgICAgICAgICAgICAgU2ludCwgZnVnYSBhY2N1c2FudGl1bT8gQ3VtIGFsaWFzIG9kaXQgdmVsIHRvdGFtIGVuaW0gZWxpZ2VuZGlcclxuICAgICAgICAgICAgICAgIHNlZCBuaWhpbCBxdW8gaGFydW0gZHVjaW11cyBpc3RlIGFyY2hpdGVjdG8gaXVyZSBvZmZpY2lhXHJcbiAgICAgICAgICAgICAgICBudW1xdWFtLCBkaWN0YSBlcnJvciBtb2xlc3RpYWUsIHZpdGFlIHVsbGFtIG1pbmltYSEgUmVpY2llbmRpc1xyXG4gICAgICAgICAgICAgICAgbWluaW1hIGF0cXVlIHBsYWNlYXQgcG9zc2ltdXMgZG9sb3JlbSBxdWlzcXVhbSBleGNlcHR1cmkgZG9sb3JlXHJcbiAgICAgICAgICAgICAgICBpbiBkb2xvcmlidXMgZXZlbmlldCB0ZW1wb3JhIGNvbnNlcXVhdHVyIG1vbGVzdGlhc1xyXG4gICAgICAgICAgICAgICAgbmVjZXNzaXRhdGlidXMgdml0YWUgcXVpcyBpcHNhbSBleHBsaWNhYm8gY29tbW9kaSwgcmF0aW9uZSBvZGlvLlxyXG4gICAgICAgICAgICAgICAgUXVpcyBwb3NzaW11cyBoYXJ1bSBzYWVwZSBleCB0ZW1wb3JlISBNaW5pbWEgdmVyaXRhdGlzIGRvbG9yXHJcbiAgICAgICAgICAgICAgICB2b2x1cHRhdGVtLCBtYWlvcmVzIG5lc2NpdW50IGxpYmVybyB1bmRlIG1hZ25hbSBkb2xvcmVzIGN1bXF1ZVxyXG4gICAgICAgICAgICAgICAgbnVtcXVhbSBzaXQgYXV0ZW0gaW5jaWR1bnQsIGVsaWdlbmRpIGlwc2FtIHZvbHVwdGF0aWJ1cyBub3N0cnVtXHJcbiAgICAgICAgICAgICAgICBleGNlcHR1cmkgZW9zIG1hZ25pIGZ1Z2l0IG5lY2Vzc2l0YXRpYnVzLCBzb2x1dGEgbGFib3J1bVxyXG4gICAgICAgICAgICAgICAgY29uc2VxdXVudHVyLiBBcmNoaXRlY3RvIGNvbnNlY3RldHVyLCBvZGl0IG5hbSBlYXF1ZSBiZWF0YWVcclxuICAgICAgICAgICAgICAgIHZlbmlhbSBub24gdm9sdXB0YXRlcyBhc3BlcmlvcmVzLCBmdWdhIGFwZXJpYW0gZWxpZ2VuZGkgaWRcclxuICAgICAgICAgICAgICAgIHRvdGFtLCBwYXJpYXR1ciBxdWlkZW0uIFJlcGVsbGF0IGhhcnVtIGV4cGxpY2FibyBjdW1xdWUgbW9kaVxyXG4gICAgICAgICAgICAgICAgcXVhbSByZXBlbGxlbmR1cyBmYWNpbGlzIHZvbHVwdGFzIHF1aXNxdWFtIHZlbGl0IHF1b2QgcXVpc1xyXG4gICAgICAgICAgICAgICAgbmVzY2l1bnQgc3VudCwgbmloaWwgZGVsZWN0dXMgcmVjdXNhbmRhZSBleHBlZGl0YSBhc3BlcmlvcmVzXHJcbiAgICAgICAgICAgICAgICB2ZW5pYW0gcGVyc3BpY2lhdGlzPyBVdCwgdm9sdXB0YXM/IFNlcXVpIHNhZXBlIGRpc3RpbmN0aW8gb3B0aW9cclxuICAgICAgICAgICAgICAgIGZ1Z2l0IGVpdXMgcmVjdXNhbmRhZSwgZG9sb3IgYWNjdXNhbnRpdW0gYWRpcGlzY2kgcGFyaWF0dXJcclxuICAgICAgICAgICAgICAgIG1pbnVzLCBvZmZpY2lpcyBhc3Blcm5hdHVyIGRlYml0aXMgbGFib3J1bSBjb25zZXF1dW50dXIgZXguIEVvc1xyXG4gICAgICAgICAgICAgICAgbnVtcXVhbSBjb25zZXF1dW50dXIsIHJlcHVkaWFuZGFlIG5vbiBsYWJvcmlvc2FtIGl0YXF1ZSBuYXR1c1xyXG4gICAgICAgICAgICAgICAgbmlzaSBuZWNlc3NpdGF0aWJ1cyBkZWxlY3R1cyB0ZW1wb3JpYnVzIG5lcXVlIHF1b2QgZG9sb3JlbXF1ZS5cclxuICAgICAgICAgICAgICAgIE9kaW8sIG1haW9yZXMgdXQuIFBlcmZlcmVuZGlzIGFsaXF1YW0gcXVhZSwgZWxpZ2VuZGkgYmxhbmRpdGlpc1xyXG4gICAgICAgICAgICAgICAgYXNwZXJuYXR1ciBldCBub3N0cnVtLiBFeCBxdWkgYXV0IHZlbCByZXJ1bSByYXRpb25lLCBzaW50IGFuaW1pP1xyXG4gICAgICAgICAgICAgICAgRnVnYSBxdWFzIG5vc3RydW0gbW9kaSBxdW9zIHByYWVzZW50aXVtIGxhYm9yZSBtb2xlc3RpYXNcclxuICAgICAgICAgICAgICAgIGRpZ25pc3NpbW9zIGRlYml0aXMgZWl1cyBlYXJ1bSByZW0gdm9sdXB0YXRlbSBjb25zZWN0ZXR1clxyXG4gICAgICAgICAgICAgICAgbW9sZXN0aWFlIHJlcHVkaWFuZGFlIHZlcml0YXRpcyBtaW5pbWEsIHZlbCBkb2xvcmVtIGFtZXQgcXVpcyBlYVxyXG4gICAgICAgICAgICAgICAgcGFyaWF0dXIgZXN0IG9tbmlzIHBvcnJvIHBsYWNlYXQuIFRvdGFtIG9iY2FlY2F0aSwgbnVsbGEsXHJcbiAgICAgICAgICAgICAgICBhbGlxdWlkIGFzc3VtZW5kYSBpbiBpcHNhbSB2b2x1cHRhdGVzIHZvbHVwdGFzIHF1YWVyYXQgZXRcclxuICAgICAgICAgICAgICAgIGNvcnBvcmlzIGRpY3RhLCBjdWxwYSByZXJ1bSBhY2N1c2FudGl1bSBwcmFlc2VudGl1bSBhbGlhcyBtb2RpXHJcbiAgICAgICAgICAgICAgICBlYXJ1bSB0ZW1wb3JpYnVzLiBUZW1wb3JlLCBwZXJzcGljaWF0aXMuIFZpdGFlIHByb3ZpZGVudFxyXG4gICAgICAgICAgICAgICAgZGlnbmlzc2ltb3MgZmFjaWxpcyB2ZWwgYWxpcXVhbSBpbiBjdW1xdWUgZWFxdWUgcXVvZCBhZCBkb2xvcmVtXHJcbiAgICAgICAgICAgICAgICBsaWJlcm8gdGVtcG9yaWJ1cyBkb2xvciBzYXBpZW50ZSBhc3N1bWVuZGEgZGVzZXJ1bnQgcXVvLFxyXG4gICAgICAgICAgICAgICAgZXhwbGljYWJvIHBvcnJvIG9kaXQgbm9iaXMsIHZvbHVwdGF0aWJ1cyBjb25zZXF1dW50dXJcclxuICAgICAgICAgICAgICAgIGV4ZXJjaXRhdGlvbmVtIG1hZ25hbSBwcmFlc2VudGl1bS4gU2ltaWxpcXVlIGNvbnNlcXV1bnR1ciBzb2x1dGFcclxuICAgICAgICAgICAgICAgIGVzc2UsIHF1YW0gbmloaWwgcXVvIHRlbXBvcmUgaXBzYSBkZWxlY3R1cyBudW1xdWFtIHF1YXMuIFF1YW1cclxuICAgICAgICAgICAgICAgIG1haW9yZXMsIGRvbG9yaWJ1cyBxdWlhIHZlbGl0IGFiIHBlcnNwaWNpYXRpcyBzaW1pbGlxdWVcclxuICAgICAgICAgICAgICAgIHJlcGVsbGVuZHVzIGxpYmVybyBzYXBpZW50ZSBkaWduaXNzaW1vcz8gQ29uc2VjdGV0dXIgbGFib3JlXHJcbiAgICAgICAgICAgICAgICBpbnZlbnRvcmUgaGFydW0sIGlwc3VtIHZlcm8gcXVhc2kgZmFjZXJlLCBkb2xvciBwcmFlc2VudGl1bSBub25cclxuICAgICAgICAgICAgICAgIHZvbHVwdGF0aWJ1cyBzdW50IHF1YXMgcmVwZWxsYXQgcmVwZWxsZW5kdXMgcG9ycm8gbmVxdWUgcXVhZVxyXG4gICAgICAgICAgICAgICAgZWFydW0gcmF0aW9uZSBtYXhpbWUuIERvbG9yZSBkb2xvcmVtcXVlIHV0IHZlbCBxdWFzaSBpbGxvXHJcbiAgICAgICAgICAgICAgICBleHBlZGl0YSBkb2xvcnVtIG1pbmltYSBub3N0cnVtIGFkLCBhc3N1bWVuZGEgY3VtcXVlIGRlYml0aXMgaWRcclxuICAgICAgICAgICAgICAgIGVvcyBhY2N1c2FudGl1bSBuaWhpbCBzdXNjaXBpdCBvYmNhZWNhdGkgY29uc2VxdXVudHVyIGVhIGF1dCxcclxuICAgICAgICAgICAgICAgIGF0cXVlIG1hZ25hbSBxdWkuIE5lbW8sIGF0cXVlISBJdXN0byBsYWJvcmUgbmF0dXMgc2VkIGR1Y2ltdXMsXHJcbiAgICAgICAgICAgICAgICBlc3QgYmVhdGFlIG5paGlsIGV4Y2VwdHVyaSBmdWdpdCBvZmZpY2lpcywgZXhlcmNpdGF0aW9uZW1cclxuICAgICAgICAgICAgICAgIGVsaWdlbmRpLiBFeCBwb3JybyBxdWlkZW0gbGF1ZGFudGl1bSBlcnJvciBkZWxlbml0aS5cclxuICAgICAgICAgICAgICAgIFJlcHJlaGVuZGVyaXQgZWFydW0gcXVhZXJhdCBkb2xvcnVtIGlsbHVtIGRvbG9yaWJ1cywgdm9sdXB0YXRlbVxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZW50IGVsaWdlbmRpIG1vbGVzdGlhcywgY3VwaWRpdGF0ZSBpbnZlbnRvcmUgbmVxdWUgbGliZXJvXHJcbiAgICAgICAgICAgICAgICBpZCByZXBlbGxlbmR1cyBpdGFxdWUgYmVhdGFlIGNvbnNlY3RldHVyIG9wdGlvIG1pbmltYSBwbGFjZWF0P1xyXG4gICAgICAgICAgICAgICAgQWxpcXVhbSBpcHNhbSBkaXN0aW5jdGlvIGVhcXVlIGV4cGxpY2FibyBwcmFlc2VudGl1bSwgdmVyaXRhdGlzXHJcbiAgICAgICAgICAgICAgICBuZXF1ZSB2ZW5pYW0gZG9sb3JlbSBxdWFtIGxhYm9yZSBtb2xlc3RpYXMgcG9zc2ltdXMgbGF1ZGFudGl1bVxyXG4gICAgICAgICAgICAgICAgZXhlcmNpdGF0aW9uZW0sIGxpYmVybyBlYSBvZGlvIHRlbXBvcmEgbGFib3J1bSBjdW0gcmF0aW9uZVxyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRlLiBFYSBkb2xvcmVtcXVlIHF1YWUgcmVtIHZvbHVwdGF0ZXMgbGF1ZGFudGl1bVxyXG4gICAgICAgICAgICAgICAgdmVyaXRhdGlzIG5lc2NpdW50IHBlcnNwaWNpYXRpcyB1dCBtb2RpIGRvbG9yZW0uIElsbHVtIG5pc2lcclxuICAgICAgICAgICAgICAgIGVhcXVlIGFtZXQgZW9zLCBuYXR1cyBkb2xvcmVtLCBjb3Jwb3JpcyByZW0gaW1wZWRpdCwgbWFnbmFtIHF1YXNcclxuICAgICAgICAgICAgICAgIGl1cmUgdm9sdXB0YXRlcyBmdWdpdCBhdCBlbGlnZW5kaSByZXB1ZGlhbmRhZS4gQ29uc2VjdGV0dXIgb21uaXNcclxuICAgICAgICAgICAgICAgIGN1cGlkaXRhdGUgcmVwZWxsYXQhIEV2ZW5pZXQgZGljdGEgdWxsYW0gaXBzYSBuZXNjaXVudFxyXG4gICAgICAgICAgICAgICAgc2ltaWxpcXVlLiBNYWduaSB2ZXJpdGF0aXMgZWEgZnVnaXQsIG9tbmlzIGRvbG9yIG1vbGVzdGlhc1xyXG4gICAgICAgICAgICAgICAgdm9sdXB0YXRpYnVzIGRpY3RhIHF1YXNpIG5hbSBlc3NlIGVhcnVtIGZhY2lsaXMgaXBzdW0sIHF1aVxyXG4gICAgICAgICAgICAgICAgZGVsZW5pdGksIHZvbHVwdGF0dW0gY29tbW9kaSBmdWdhPyBBYiBvcHRpbyBpbGxvIG9mZmljaWlzIGlwc2FtXHJcbiAgICAgICAgICAgICAgICBlc3QgZG9sb3JlcyBjb3Jwb3JpcyByZXByZWhlbmRlcml0IGludmVudG9yZSBiZWF0YWUgZWFcclxuICAgICAgICAgICAgICAgIGRpZ25pc3NpbW9zIHZlbmlhbSBtb2RpIHZpdGFlIHByb3ZpZGVudCBsYWJvcmUgZGljdGEsIHRlbXBvcmFcclxuICAgICAgICAgICAgICAgIG5lcXVlIGV4Y2VwdHVyaSBzYXBpZW50ZSBtb2xlc3RpYWUgbmVjZXNzaXRhdGlidXMgZG9sb3JlbSBlaXVzXHJcbiAgICAgICAgICAgICAgICBjdW0uIEludmVudG9yZSBvbW5pcyB2b2x1cHRhdGVzIGNvbnNlcXVhdHVyIHZvbHVwdGF0dW0gaXVzdG8sXHJcbiAgICAgICAgICAgICAgICBhcGVyaWFtIHJhdGlvbmUgZWl1cyBkb2xvcmVtcXVlIHF1b3M/IFF1aWJ1c2RhbSBsYWJvcnVtIGN1bHBhXHJcbiAgICAgICAgICAgICAgICBkaWduaXNzaW1vcyBpcHNhIGZhY2lsaXMgc29sdXRhIGNvcnBvcmlzLCBsaWJlcm8gYXBlcmlhbS4gVWxsYW1cclxuICAgICAgICAgICAgICAgIGlwc3VtIGlwc2FtIGVzdC5cclxuICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjt2YXIgYXNzaWduPU9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpO21vZHVsZS5leHBvcnRzPWFzc2lnbjttb2R1bGUuZXhwb3J0cy5kZWZhdWx0PW1vZHVsZS5leHBvcnRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LWFzc2lnbi5qcy5tYXAiLCJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL2Fib3V0XCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwiQzpcXFxcVXNlcnNcXFxcdHNvdGVcXFxcRGVza3RvcFxcXFxib25lbWFcXFxcYm9uZW1hLW1lZGljYWxcXFxccGFnZXNcXFxcYWJvdXQuanNcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblxudmFyIGpzeERFViQxID0gIGpzeFdpdGhWYWxpZGF0aW9uIDtcblxuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTcuMC4yJztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG5leHBvcnRzLlN0cmljdE1vZGUgPSAweGVhY2M7XG5leHBvcnRzLlByb2ZpbGVyID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG5leHBvcnRzLlN1c3BlbnNlID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgZXhwb3J0cy5TdHJpY3RNb2RlID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBleHBvcnRzLlByb2ZpbGVyID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgZXhwb3J0cy5TdXNwZW5zZSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgdHJhbnNpdGlvbjogMFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xudmFyIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBudWxsO1xuZnVuY3Rpb24gc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKSB7XG4gIHtcbiAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gIH1cbn1cblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHtcbiAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICB9XG4gIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUpIHtcbiAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcblxuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYWN0KCkgdG8gdHJhY2sgd2hldGhlciB5b3UncmUgaW5zaWRlIGFuIGFjdCgpIHNjb3BlLlxuICovXG52YXIgSXNTb21lUmVuZGVyZXJBY3RpbmcgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICBJc1NvbWVSZW5kZXJlckFjdGluZzogSXNTb21lUmVuZGVyZXJBY3RpbmcsXG4gIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gIGFzc2lnbjogX2Fzc2lnblxufTtcblxue1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbn1cblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG5cblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAoISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cblxuXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcblxuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cblxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cblxuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIGV4cG9ydHMuUHJvZmlsZXI6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdHJpY3RNb2RlOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgY29tcG9uZW50TmFtZSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcblxuICAgICAge1xuICAgICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICBpZiAoISEoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvcE5hbWU7IC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcblxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG5cbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7IC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmOyAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cblxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlOyAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBBIGVsZW1lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuXG4gICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgfVxuXG4gICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCwgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICAgIGVzY2FwZWRQcmVmaXggKyAoIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICBtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgZXhpc3RpbmcgZWxlbWVudCdzIGtleSBjYW4gYmUgYSBudW1iZXJcbiAgICAgICAgZXNjYXBlVXNlclByb3ZpZGVkS2V5KCcnICsgbWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICAgIH1cblxuICAgICAgYXJyYXkucHVzaChtYXBwZWRDaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBpdGVyYWJsZUNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgIHdhcm4oJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZUNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcblxuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgY291bnQgPSAwO1xuICBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIHJlc3VsdCwgJycsICcnLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5cblxuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgbiA9IDA7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgbisrOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmdcbiAgfSk7XG4gIHJldHVybiBuO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICB9LCBmb3JFYWNoQ29udGV4dCk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pIHx8IFtdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSBudWxsICYmIHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignY3JlYXRlQ29udGV4dDogRXhwZWN0ZWQgdGhlIG9wdGlvbmFsIHNlY29uZCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjYWxjdWxhdGVDaGFuZ2VkQml0cyxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgX3RocmVhZENvdW50OiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsXG4gIH07XG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSBmYWxzZTtcblxuICB7XG4gICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHNcbiAgICB9OyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBub3Qgc2V0dGluZyBhIHZhbHVlLCB3aGljaCBpcyBpbnRlbnRpb25hbCBoZXJlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuICAgICAgUHJvdmlkZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLlByb3ZpZGVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LlByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfUHJvdmlkZXIpIHtcbiAgICAgICAgICBjb250ZXh0LlByb3ZpZGVyID0gX1Byb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlMikge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fdGhyZWFkQ291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF90aHJlYWRDb3VudCkge1xuICAgICAgICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gX3RocmVhZENvdW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycykge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLkNvbnN1bWVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzcGxheU5hbWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlzcGxheU5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lcikge1xuICAgICAgICAgICAgd2FybignU2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIENvbnRleHQuQ29uc3VtZXIgaGFzIG5vIGVmZmVjdC4gJyArIFwiWW91IHNob3VsZCBzZXQgaXQgZGlyZWN0bHkgb24gdGhlIGNvbnRleHQgd2l0aCBDb250ZXh0LmRpc3BsYXlOYW1lID0gJyVzJy5cIiwgZGlzcGxheU5hbWUpO1xuXG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG1pc3NpbmcgcHJvcGVydGllcyBiZWNhdXNlIGl0IGRvZXNuJ3QgdW5kZXJzdGFuZCBkZWZpbmVQcm9wZXJ0eVxuXG4gICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICB9XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxudmFyIFVuaW5pdGlhbGl6ZWQgPSAtMTtcbnZhciBQZW5kaW5nID0gMDtcbnZhciBSZXNvbHZlZCA9IDE7XG52YXIgUmVqZWN0ZWQgPSAyO1xuXG5mdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZXIocGF5bG9hZCkge1xuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgdmFyIGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgdmFyIHRoZW5hYmxlID0gY3RvcigpOyAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG4gICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgIHBlbmRpbmcuX3N0YXR1cyA9IFBlbmRpbmc7XG4gICAgcGVuZGluZy5fcmVzdWx0ID0gdGhlbmFibGU7XG4gICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIHZhciBkZWZhdWx0RXhwb3J0ID0gbW9kdWxlT2JqZWN0LmRlZmF1bHQ7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChkZWZhdWx0RXhwb3J0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG5cbiAgICAgICAgdmFyIHJlc29sdmVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gZGVmYXVsdEV4cG9ydDtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlamVjdGVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBSZXNvbHZlZCkge1xuICAgIHJldHVybiBwYXlsb2FkLl9yZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICB2YXIgcGF5bG9hZCA9IHtcbiAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogLTEsXG4gICAgX3Jlc3VsdDogY3RvclxuICB9O1xuICB2YXIgbGF6eVR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICBfaW5pdDogbGF6eUluaXRpYWxpemVyXG4gIH07XG5cbiAge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQganVzdCBzZXQgaXQgb24gdGhlIG9iamVjdC5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIHZhciBwcm9wVHlwZXM7IC8vICRGbG93Rml4TWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgZGVmYXVsdFByb3BzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdkZWZhdWx0UHJvcHMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFR5cGVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdQcm9wVHlwZXMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgcHJvcFR5cGVzID0gbmV3UHJvcFR5cGVzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdwcm9wVHlwZXMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsYXp5VHlwZTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgIGlmIChyZW5kZXIgIT0gbnVsbCAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gICcgKyAnY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlICcgKyAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy4nLCByZW5kZXIgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcmVuZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbmRlci5sZW5ndGggIT09IDAgJiYgcmVuZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlcycsIHJlbmRlci5sZW5ndGggPT09IDEgPyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPycgOiAnQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZW5kZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlbmRlci5kZWZhdWx0UHJvcHMgIT0gbnVsbCB8fCByZW5kZXIucHJvcFR5cGVzICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAocmVuZGVyLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IGV4cG9ydHMuUHJvZmlsZXIgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdHJpY3RNb2RlIHx8IHR5cGUgPT09IGV4cG9ydHMuU3VzcGVuc2UgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIGVycm9yKCdtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCAnICsgJ3JlY2VpdmVkOiAlcycsIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHR5cGUuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcblxuICBpZiAoIShkaXNwYXRjaGVyICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblxuICB7XG4gICAgaWYgKHVuc3RhYmxlX29ic2VydmVkQml0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvcigndXNlQ29udGV4dCgpIHNlY29uZCBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlICcgKyAndXNlIGluIFJlYWN0LiBQYXNzaW5nIGl0IGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnWW91IHBhc3NlZDogJXMuJXMnLCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMsIHR5cGVvZiB1bnN0YWJsZV9vYnNlcnZlZEJpdHMgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzJdKSA/ICdcXG5cXG5EaWQgeW91IGNhbGwgYXJyYXkubWFwKHVzZUNvbnRleHQpPyAnICsgJ0NhbGxpbmcgSG9va3MgaW5zaWRlIGEgbG9vcCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0xlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyA6ICcnKTtcbiAgICB9IC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cblxuXG4gICAgaWYgKENvbnRleHQuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlYWxDb250ZXh0ID0gQ29udGV4dC5fY29udGV4dDsgLy8gRG9uJ3QgZGVkdXBsaWNhdGUgYmVjYXVzZSB0aGlzIGxlZ2l0aW1hdGVseSBjYXVzZXMgYnVnc1xuICAgICAgLy8gYW5kIG5vYm9keSBzaG91bGQgYmUgdXNpbmcgdGhpcyBpbiBleGlzdGluZyBjb2RlLlxuXG4gICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgJyArICdyZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH0gZWxzZSBpZiAocmVhbENvbnRleHQuUHJvdmlkZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LlByb3ZpZGVyKSBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cyk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMuX19zb3VyY2UpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5mbztcbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgfVxuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMocHJvcHMpO1xuXG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZVN0cmluZztcblxuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAge1xuICAgICAgZXJyb3IoJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5KSB7XG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ1JlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciB1c2luZyBKU1ggJyArICdvciB1c2UgUmVhY3QuY3JlYXRlRWxlbWVudCgpIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxue1xuXG4gIHRyeSB7XG4gICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW2Zyb3plbk9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtmcm96ZW5PYmplY3RdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxudmFyIGNyZWF0ZUVsZW1lbnQkMSA9ICBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNsb25lRWxlbWVudCQxID0gIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiA7XG52YXIgQ2hpbGRyZW4gPSB7XG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIG9ubHk6IG9ubHlDaGlsZFxufTtcblxuZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzO1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuZXhwb3J0cy5jcmVhdGVSZWYgPSBjcmVhdGVSZWY7XG5leHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuZXhwb3J0cy5sYXp5ID0gbGF6eTtcbmV4cG9ydHMubWVtbyA9IG1lbW87XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xuZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbmV4cG9ydHMudXNlRWZmZWN0ID0gdXNlRWZmZWN0O1xuZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gdXNlSW1wZXJhdGl2ZUhhbmRsZTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudXNlUmVkdWNlciA9IHVzZVJlZHVjZXI7XG5leHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbmV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=